[{"authors":["admin"],"categories":null,"content":"My name is Mark Rieke and I am a senior consumer experience (CX) analyst at Memorial Hermann Health System where I use survey data to improve patient satisfaction. I love making beautiful charts, working on home improvement projects, and playing jazzy piano.\nI earned my bachelor\u0026rsquo;s degree in Mechanical Engineering from the University of Tulsa in 2018. I worked with Siemens Energy for three years designing mobile gas-turbine power plants before moving into a more data-centric role. I currently use R and tidymodels to provide actionable insights from Qualtrics survey data. In my spare time, I love analyzing public political datasets. You can find my work on GitHub and my unedited stream of consciousness on Twitter.\nI live in Houston, TX, with my fiance and two obnoxious yet lovable pets.\nThis blog is built with blogdown and Hugo, and deployed using Netlify. The content on this site is released under the MIT License.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://www.thedatadiary.net/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"My name is Mark Rieke and I am a senior consumer experience (CX) analyst at Memorial Hermann Health System where I use survey data to improve patient satisfaction. I love making beautiful charts, working on home improvement projects, and playing jazzy piano.","tags":null,"title":"Mark Rieke","type":"authors"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"9e444dc08a7e5966c7f50d6ff66c3efb","permalink":"https://www.thedatadiary.net/project/workboots/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/workboots/","section":"project","summary":"Generate prediction intervals from a tidymodel workflow.","tags":["Demo","Deep Learning"],"title":"workboots","type":"project"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"b4cf901b8564a98e45d09ced4f9fc79c","permalink":"https://www.thedatadiary.net/project/nplyr/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/nplyr/","section":"project","summary":"A grammar of (nested) data manipulation.","tags":["Demo","robotics"],"title":"nplyr","type":"project"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"7a4afc8967f0fb3a76241e1e351573b2","permalink":"https://www.thedatadiary.net/project/riekelib/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/riekelib/","section":"project","summary":"A collection of functions I use regularly.","tags":["Demo","Deep Learning"],"title":"riekelib","type":"project"},{"authors":[],"categories":["rstats","stan","healthcare"],"content":"\rHierarchical Hospitals\rIf the past year of working at a large hospital system has taught me one thing, it’s that hospitals are a Russian nesting doll of structure. Within the hospital system, there are several campuses. Within each campus, there are several service areas (inpatient, outpatient, emergency, day surgery, etc.). And finally, within each service area at each campus, there can be many individual hospital units.\nHaving worked with patient satisfaction data, I know that each of these levels contains useful information that may be beneficial to include in a model. Hospital A, for example, tends to receive better reviews than Hospital B, but within Hospital A the labor \u0026amp; delivery unit tends to receive better reviews than the intensive care unit. Including every single unit as a categorical predictor isn’t a great modeling choice, since information about each unit remains separate (no pooling). On the other hand, ignoring the nested structure lumps all data points together (complete pooling), implicitly making the assumption that the data is independent, which can generate misleading predictions!\nThis is where hierarchical models come into play! Hierarchical models offer a happy middle ground and allow for partial pooling of information between groups. This approach allows for information to be shared across groups while still treating each group as unique (this is a pretty simplistic summary of hierarchical models; for a more detailed introduction, see Chapter 15 of Bayes Rules!).\nWhile there are non-Bayesian approaches to hierarchical models, they mesh well with a Bayesian framework, so in this post I’ll build a Bayesian model to predict satisfaction scores based on simulated hospital data.\n\rSimulating Hospital Data\rI can’t share live data, so I’ll need to simulate some fake data for this example. Let’s start with five hospitals, each with different baseline levels of satisfaction.\nlibrary(tidyverse)\rlibrary(rstanarm)\rlibrary(tidybayes)\rlibrary(ggdist)\rlibrary(tidytext)\r# reproducibility!\rset.seed(54321)\r# manually assign hospital-level intercept\rhospital_prob \u0026lt;- tibble(hospital = paste(\u0026quot;Hospital\u0026quot;, seq(1:5)),\rhospital_prob = seq(from = 0.6, to = 0.8, length.out = 5) ,\rhospital_sigma = rep(0.2, 5))\rhospital_prob %\u0026gt;%\rknitr::kable()\r\r\rhospital\rhospital_prob\rhospital_sigma\r\r\r\rHospital 1\r0.60\r0.2\r\rHospital 2\r0.65\r0.2\r\rHospital 3\r0.70\r0.2\r\rHospital 4\r0.75\r0.2\r\rHospital 5\r0.80\r0.2\r\r\r\rIn this example, Hospital 1 will tend to have the lowest scores while Hospital 5 will tend to have the highest scores. Within each hospital, we want individual unit-level scores to be able to vary randomly.\n# simulate 5 hospitals within the system, each with 100 units (500 total)\rsatisfaction \u0026lt;- tibble(hospital = rep(paste(\u0026quot;Hospital\u0026quot;, seq(1:5)), 100)) %\u0026gt;%\rarrange(hospital) %\u0026gt;%\r# add in the units at each hospital\rbind_cols(unit = rep(paste(\u0026quot;Unit\u0026quot;, seq(1:100)), 5)) %\u0026gt;%\rmutate(unit = paste(hospital, unit)) %\u0026gt;%\r# add in the hospital-level intercept\rleft_join(hospital_prob, by = \u0026quot;hospital\u0026quot;) %\u0026gt;%\r# estimate a unit-level intercept rowwise() %\u0026gt;%\rmutate(unit_offset = rnorm(1, 0, 0.05),\runit_prob = gamlss.dist::rBE(1, hospital_prob + unit_offset, hospital_sigma)) %\u0026gt;%\rselect(hospital, unit, unit_prob) %\u0026gt;%\r# generate fake responses\rmutate(n = round(rlnorm(1, log(100), 1.5)),\rtopbox = rbinom(1, n, unit_prob)) %\u0026gt;%\rungroup() %\u0026gt;%\rselect(-unit_prob)\r# display example at each hospital\rset.seed(333)\rsatisfaction %\u0026gt;%\rgroup_by(hospital) %\u0026gt;%\rslice_sample(n = 1) %\u0026gt;%\rmutate(score = topbox/n) %\u0026gt;%\rknitr::kable()\r\r\rhospital\runit\rn\rtopbox\rscore\r\r\r\rHospital 1\rHospital 1 Unit 14\r35\r21\r0.6000000\r\rHospital 2\rHospital 2 Unit 41\r137\r107\r0.7810219\r\rHospital 3\rHospital 3 Unit 55\r298\r252\r0.8456376\r\rHospital 4\rHospital 4 Unit 66\r12\r7\r0.5833333\r\rHospital 5\rHospital 5 Unit 39\r211\r169\r0.8009479\r\r\r\rThis unit level variation is important! Even though units within certain hospitals tend to perform worse than units in others, individual units at lower-rated hospitals can still outperform units at highly-rated hospitals! An easier way to see both the hospital-level and unit-level variation is to place all on the same plot.\nsatisfaction %\u0026gt;%\rmutate(score = topbox/n) %\u0026gt;%\rggplot(aes(x = hospital,\ry = score,\rsize = n,\rcolor = hospital)) + geom_boxplot() + geom_jitter(alpha = 0.25) + coord_flip() +\rscale_color_brewer(palette = \u0026quot;Dark2\u0026quot;) +\rscale_size_continuous(range = c(1, 15)) +\rscale_y_continuous(labels = scales::label_percent()) +\rtheme(legend.position = \u0026quot;none\u0026quot;) +\rlabs(title = \u0026quot;It\u0026#39;s in the way that you Units\u0026quot;,\rsubtitle = \u0026quot;Satisfaction scores vary both **across** and **within** hospitals\u0026quot;,\rx = NULL,\ry = NULL)\rHere, each point represents an individual unit within a hospital — larger points indicate units with more responses. There’s clearly variation across hospitals, but also variation within each hospital. We can generally trust that the satisfaction score for a unit with lots of responses is accurate, but a unit with few responses can provide misleading scores — some have scores of 100%! I don’t think that these units are actually perfect, it’s likelier that they got lucky.\nA hierarchical model will allow us to pool all this information together — when a unit has lots of responses, the model’s estimate of their true score will land pretty close to their raw score. When a unit only has a few responses, however, the model will shrink the estimate of their true score towards the hospital group-level average.\n\rFitting a Model\rI’ve found recently that writing out a model specification helps, so let’s write out the model and priors.\n\\[\r\\begin{gather}\ry_{unit} \\sim Binomial(\\pi_{unit}, n_{unit}) \\\\\rlogit(\\pi_{unit}) = \\mu + \\beta_{hospital} + \\beta_{unit} \\\\\r\\mu \\sim Normal(0, 2) \\\\\r\\beta_{hospital} \\sim Normal(0, 2) \\\\\r\\beta_{unit} \\sim Normal(0, 2)\r\\end{gather}\r\\]\nIn this case, the number of topbox responses at each unit, \\(y_{unit}\\), is estimated with a binomial distribution where each patient within that visits the unit has a probability \\(\\pi_{unit}\\) of selecting the topbox response. \\(\\pi_{unit}\\) is allowed to vary from the global mean, \\(\\mu\\), both by hospital (\\(\\beta_{hospital}\\)) and by unit (\\(\\beta_{unit}\\)). This can be implemented in Stan via the {rstanarm} package.\n# run chains on separte cores\roptions(mc.cores = parallel::detectCores())\r# fit a bayesian model!\rsatisfaction_model \u0026lt;- stan_glmer(\rcbind(topbox, n - topbox) ~ (1 | hospital) + (1 | unit),\rdata = satisfaction,\rfamily = binomial(),\rprior_intercept = normal(0, 2, autoscale = TRUE),\rprior = normal(0, 2, autoscale = TRUE),\rprior_covariance = decov(regularization = 1, concentration = 1, shape = 1, scale = 1),\rchains = 4,\riter = 2000,\rseed = 999\r)\rThis model gives us exactly what we were looking for — units with many responses have posterior estimations of \\(\\pi_{unit}\\) that are close to the raw score and have relatively small credible intervals, while the posterior estimate of \\(\\pi_{unit}\\) for a unit with few responses is shrunken towards the hospital average with relatively wide credible intervals.\nset.seed(88)\rsatisfaction %\u0026gt;%\r# draw 1000 posterior predictions of pi for each unit\rtidybayes::add_epred_draws(satisfaction_model, ndraws = 1000) %\u0026gt;%\rungroup() %\u0026gt;%\r# select a sample of 3 random units from each hospital to plot\rnest(preds = -c(hospital, unit, n, topbox)) %\u0026gt;%\rgroup_by(hospital) %\u0026gt;%\rslice_sample(n = 3) %\u0026gt;%\rmutate(unit = str_sub(unit, start = 12),\runit = glue::glue(\u0026quot;{unit}\\n(n = {scales::label_comma()(n)})\u0026quot;),\rmed_pred = map_dbl(preds, ~quantile(.x$.epred, probs = 0.5))) %\u0026gt;%\rungroup() %\u0026gt;%\runnest(preds) %\u0026gt;%\r# plot!\rggplot(aes(x = reorder_within(unit, med_pred, hospital),\ry = .epred,\rcolor = hospital)) +\rstat_pointinterval() +\rscale_x_reordered() +\rscale_y_continuous(labels = scales::label_percent()) +\rcoord_flip() +\rfacet_wrap(~hospital, scales = \u0026quot;free\u0026quot;) +\rtheme(legend.position = \u0026quot;none\u0026quot;) +\rlabs(title = \u0026quot;\\u03C0 in the sky\u0026quot;,\rsubtitle = \u0026quot;Posterior estimations of \\u03C0 for a random sampling of units\u0026quot;, x = NULL,\ry = NULL,\rcaption = \u0026quot;Pointrange indicates the\u0026lt;br\u0026gt;66% \u0026amp; 95% posterior credible interval\u0026quot;) +\rscale_color_brewer(palette = \u0026quot;Dark2\u0026quot;)\rWith a hierarchical model, we can even make predictions for new units that didn’t appear in the original training data. If we were to introduce a new unit at each hospital, the model can still rely on the hospital-level term to estimate scores.\nset.seed(1)\rtibble(hospital = paste(\u0026quot;Hospital\u0026quot;, seq(1:5))) %\u0026gt;%\rmutate(unit = glue::glue(\u0026quot;{hospital}\\nNew Unit\u0026quot;)) %\u0026gt;%\radd_epred_draws(satisfaction_model) %\u0026gt;%\rggplot(aes(x = unit,\ry = .epred,\rcolor = unit)) + stat_pointinterval() +\rscale_y_continuous(labels = scales::label_percent()) +\rcoord_flip() +\rscale_color_brewer(palette = \u0026quot;Dark2\u0026quot;) +\rtheme(legend.position = \u0026quot;none\u0026quot;) +\rlabs(title = \u0026quot;New unit, who this?\u0026quot;,\rsubtitle = \u0026quot;Posterior estimations of \\u03C0 for hypothetical new units at each hospital\u0026quot;,\rx = NULL,\ry = NULL,\rcaption = \u0026quot;Pointrange indicates the\u0026lt;br\u0026gt;66% and 95% posterior credible interval\u0026quot;)\r\rSome closing thoughts\rThe model I used here can be referred to as a random intercept model. In this case, the intercept is allowed to vary by hospital and unit. Had I included a predictor term — age, for example — I could have put together a random slope model, which would have allowed the age term to also vary by hospital and unit. This would allow for one hospital to be modeled as having better scores for young patients while another hospital could see better scores for older patients. This sort of flexibility is useful, but in my experience, simply accounting for the hierarchical structure of the data with an intercept-only model gets you 90% of where you need to go!\n\r","date":1668384000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1668470930,"objectID":"5c544b8ef9a0da34931b18ab49b6d386","permalink":"https://www.thedatadiary.net/blog/2022-11-14-hierarchical-hospitals/","publishdate":"2022-11-14T00:00:00Z","relpermalink":"/blog/2022-11-14-hierarchical-hospitals/","section":"blog","summary":"Hierarchical Hospitals\rIf the past year of working at a large hospital system has taught me one thing, it’s that hospitals are a Russian nesting doll of structure. Within the hospital system, there are several campuses.","tags":[],"title":"Hierarchical Hospitals","type":"blog"},{"authors":[],"categories":["politics"],"content":"\rFor those who aren’t glued to electoral politics, Labor Day typically marks the beginning of election season. Primaries are settled, pollsters stop sampling all adults to prioritize likely voters, and campaigns kick into high-gear. Labor Day also marks the release of my 2022 midterm forecast:\n🚨big project launch🚨\ntoday I’m launching my 2022 midterms forecast! As of today, Democrats are favored to keep the senate and Republicans are favored to flip the house - more deets below but you can find the full forecasts here:\nhttps://t.co/xh1GCVkuwYhttps://t.co/Zh9KGGGqWI pic.twitter.com/I9mciZoLbX\n\u0026mdash; Mark Rieke (@markjrieke) September 6, 2022  At the time of this writing, Democrats are favored to keep the senate while Republicans are favored to flip the House:\nThe most up-to-date information for each chamber (as well as individual races) can be found on the respective pages for the Senate and House. There is also a forecast for each Governor’s race.\nIn this post, I’ll walk through how the model works and point out some of its shortcomings. I’ll cover the broad strokes here, but for those who are interested in digging into the source code, I’ve released the model publicly on github.\n\rHi! I’ll put extra math-y details in note blocks, like this. You can skip over these without missing out on any of the important stuff, this just gives some extra details for dorks like me.\n\rHow this works\rFilter down candidates/races\rThe first step taken is to filter out non-competitive races and candidates. Non-competitive, used here, doesn’t mean “races that aren’t close” but instead means “races that literally don’t have any competition.” In each race, only the chances of the top democrat/republican (or independent that would caucus with one of the major parties) are modeled. In uncontested races or races between two members of the same party, the controlling party’s probability of winning is set to 100%.\n\rRemoving third parties and intra-party races allows us to model each candidate’s projected voteshare via a beta distribution, which is useful for modeling proportional data of binary outcomes.\n\r\rEstimate the polling average\rThe next step is to estimate the polling average in each race. For races with polls, this can be done directly, but most races (especially in the House), aren’t polled. For these races, the poll average is constructed from the generic congressional ballot (GCB) and the seat’s partisan voter index (PVI). For example, for a R+5 seat, if the GCB is at D+1 the seats poll average will be R+4.\n\rThe poll model is really simple, but does increase slightly with complexity as more polls come in/as election day draws nearer. When there are three or fewer polls, a simple average is used. When there are between 4 and 6 polls, a linear model is used (i.e., lm(pct ~ date)). When there are more than 6 polls, a loess model is used (loess(pct ~ date, span = span)). The span parameter is scaled by the number of days between the polling period and election day — as election day approaches, span moves from 1 to 0.75.\n\r\rTrain the model\rPolls are a great tool and the most reliable predictor, but not the only one! With the polling average in each seat, the model is trained to estimate the outcome based on polls, partisanship (via PVI), incumbency, and a blend of demographics.\n# here\u0026#39;s the actual model itself!\r# estimate: poll average, # poll_bucket: has this race been polled, y/n?\r# incumbent: incumbent party - democrat/republican/neither?\relections_model \u0026lt;-\rgamlss(result ~ estimate * poll_bucket + pvi + incumbent + white + black + hispanic + aapi,\rsigma.formula = ~ log10(num_polls + 2),\rfamily = BE(),\rdata = elections_train)\r\rSimulate outcomes\rThe final step is to simulate! To do so, 10,000 possible voteshare outcomes are generated each day for each race. The probability of any candidate winning is simply the percentage of simulations where the candidate has the greater voteshare. Similarly, the probability that each party controls each chamber is simply the percentage of simulations where that party controls a majority of seats (though Democrats only need 50 seats for control of the Senate, as Vice-President Harris serves as the tie-breaking vote).\n\rIn each of the simulations, a bit of polling error is introduced. This introduced error is normally distributed around 0. There’s been quite a bit of debate recently regarding the direction of that error (some folks think we should assume polls are undercounting Republicans, given the errors in 2016 and 2020), but the consensus amongst the modeling at FiveThirtyEight and the Economist is to set the average polling bias to 0. Each prediction is a single draw from one of the 10,000 possible distributions — when aggregated for each candidate we can estimate the 80% quantile range for their expected voteshare.\n\r\r\rModel shortcomings\rWhile I’d love to believe that my model is professional quality, the truth is that this is represents my best (amateur) attempt at putting together a forecast in my limited free time. Of the model’s shortcomings, the three most egregious (in my opinion) are listed below:\nThe poll model is probably too simple. I’d spent a lot of time putting together a custom poll models for the generic ballot average and presidential approval average, both of which are fairly complex and adjust for pollster bias, survey size, sample population, and recency. While these are good enough poll models on their own, they take quite a bit of time to update. Extending this out to all the races in the midterms would mean that daily updates may take hours, which is a non-starter. So instead, I’ve opted for the simpler poll aggregate described above. This simplicity means that it’s a bit jumpy and a bit too bullish on recent polls.\n\rThis is a “now-cast”. Some models allow poll averages to drift between the current day and election day via random walks. This model, however, doesn’t do so — the forecast can really be thought of as the chance each party has if elections were held today with the information available today.\n\rThis is neither a Bayesian, nor a hierarchical model. In this model, the poll average and voteshare forecast are actually two separate models — ideally, these should both be roped-up in an overarching Bayesian model since they are both part of the same data generation process. Furthermore, this model assumes that all races are fully independent, which is wrong. House races in Georgia, for example, are not independent from other house races in Georgia. Ideally, we’d partially pool information across different races — this model doesn’t do that.\n\r\rDespite all this, I believe this relatively simple model results in an overall directionally correct forecast — you should view it in concert with a host of other reputable forecasts (listed below). I’d encourage you to check back intermittently to see how the race for each chamber progresses!\nOther midterm forecasts\r\rFiveThirtyEight: Senate, House, Governor\rThe Economist: Senate, House\rDecision Desk HQ: Senate, House\rSplit Ticket: Senate, House, Governor\rJHK Forecasts: Senate, House\rRace to the WH: Senate, House, Governor\rCNalysis: Senate, House, Governor\r\r\r\r","date":1663545600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1663337100,"objectID":"fb3bd5e9f1a1f552d5cd533cf938ade4","permalink":"https://www.thedatadiary.net/blog/2022-09-16-forecast-launch/","publishdate":"2022-09-19T00:00:00Z","relpermalink":"/blog/2022-09-16-forecast-launch/","section":"blog","summary":"For those who aren’t glued to electoral politics, Labor Day typically marks the beginning of election season. Primaries are settled, pollsters stop sampling all adults to prioritize likely voters, and campaigns kick into high-gear.","tags":[],"title":"Forecast Launch!","type":"blog"},{"authors":[],"categories":["rstats","tidymodels"],"content":"\r\r\r\r\r\r\rLast November, I (finally) popped the big question and proposed! Since then, my fiance and I have been diligently planning our wedding. While we have most of the big-ticket items checked off (venue, catering, photography, etc.), one area we still have more work to do is on the wedding playlist. We’ve started putting together a playlist on spotify, but it feels like it’s come to a bit of a stand-still. Currently, there’s a mix of zesty bops and tame songs on the playlist (we need to accommodate both our college friends and our grandparents!), but spotify’s track recommender only wants to suggest tamer songs right now. Our goal is to have a full dance floor the entire night — to achieve this, we can use spotifyr and the new tidyclust package to pull in the current playlist, cluster the songs based on their features, and find new songs based on the bop cluster.\nlibrary(tidymodels)\rlibrary(tidyclust)\rlibrary(spotifyr)\rIf you’d like to follow along, I’d recommend installing the development versions of parsnip and workflows, as some of the functionality that interacts with tidyclust isn’t yet on CRAN.\nPulling in the playlist\rspotifyr is an R interface to spotify’s web API and gives access to a host of track features (you can follow this tutorial to get it setup). I’ll use the functions get_user_playlists() and get_playlist_tracks() to pull in songs that are currently on our wedding playlist (appropriately named “Ding dong”).\n# get the songs that are currently on the wedding playlist\rding_dong \u0026lt;- get_user_playlists(\u0026quot;12130039175\u0026quot;) %\u0026gt;%\rfilter(name == \u0026quot;Ding dong\u0026quot;) %\u0026gt;%\rpull(id) %\u0026gt;%\rget_playlist_tracks() %\u0026gt;% as_tibble() %\u0026gt;%\rselect(track.id, track.name, track.popularity) %\u0026gt;%\rrename_with(~stringr::str_replace(.x, \u0026quot;\\\\.\u0026quot;, \u0026quot;_\u0026quot;))\r\r\r\r\rtrack_id\rtrack_name\rtrack_popularity\r\r\r\r5jkFvD4UJrmdoezzT1FRoP\rRasputin\r65\r\r1D066zixBwqFYqBhKgdPzp\rFergalicious\r71\r\r12jjuxN1gxlm29cqL5M6MW\rI Got You\r65\r\r2grjqo0Frpf2okIBiifQKs\rSeptember\r81\r\r2RlgNHKcydI9sayD2Df2xp\rMr. Blue Sky\r80\r\r6x4tKaOzfNJpEJHySoiJcs\rMambo No. 5 (a Little Bit of…)\r77\r\r3n3Ppam7vgaVa1iaRUc9Lp\rMr. Brightside\r66\r\r7Cp69rNBwU0gaFT8zxExlE\rYmca\r50\r\r3Gf5nttwcX9aaSQXRWidEZ\rRide Wit Me\r76\r\r3wMUvT6eIw2L5cZFG1yH9j\rCountry Grammar (Hot Shit)\r70\r\r\r\rSpotify estimates quite a few features for each song in their catalog: speechiness (the presence of words on a track), acousticness (whether or not a song includes acoustic instruments), liveness (estimates whether or not the track is live or studio-recorded), etc. We can use get_track_audio_features() to get the features for each song based on its track_id.\n# pull in track features of songs on the playlist\rtrack_features \u0026lt;- ding_dong %\u0026gt;%\rpull(track_id) %\u0026gt;%\rget_track_audio_features()\r# join together\rding_dong \u0026lt;- ding_dong %\u0026gt;%\rleft_join(track_features, by = c(\u0026quot;track_id\u0026quot; = \u0026quot;id\u0026quot;))\rIn my case, I’m interested in the energy and valence (positivity) of each song, so I’ll select these variables to use in the cluster analysis.\n\r\rtrack_name\rvalence\renergy\r\r\r\rRasputin\r0.966\r0.893\r\rFergalicious\r0.829\r0.583\r\rI Got You\r0.544\r0.399\r\rSeptember\r0.979\r0.832\r\rMr. Blue Sky\r0.478\r0.338\r\rMambo No. 5 (a Little Bit of…)\r0.892\r0.807\r\rMr. Brightside\r0.240\r0.918\r\rYmca\r0.671\r0.951\r\rRide Wit Me\r0.722\r0.700\r\rCountry Grammar (Hot Shit)\r0.565\r0.664\r\r\r\r\rClustering with tidyclust\rCurrently, the playlist covers a wide spectrum of songs. For new songs on the playlist, I’m really just interested in songs similar to others in the top right corner of the below chart with high energy and valence.\n\r{\"x\":{\"html\":\"\\n\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\",\"js\":null,\"uid\":\"svg_75dd45b0-ea2e-49f1-b888-7d8bba500393\",\"ratio\":1.2,\"settings\":{\"tooltip\":{\"css\":\".tooltip_SVGID_ { background-color:gray;color:white;padding:2px;border-radius:2px;font-family:Roboto Slab; ; position:absolute;pointer-events:none;z-index:999;}\",\"placement\":\"doc\",\"offx\":10,\"offy\":0,\"use_cursor_pos\":true,\"opacity\":0.8,\"usefill\":false,\"usestroke\":false,\"delay\":{\"over\":200,\"out\":500}},\"hover\":{\"css\":\".hover_SVGID_ { fill:#1279BF;stroke:#1279BF;cursor:pointer; }\",\"reactive\":false},\"hoverkey\":{\"css\":\".hover_key_SVGID_ { stroke:red; }\",\"reactive\":false},\"hovertheme\":{\"css\":\".hover_theme_SVGID_ { fill:green; }\",\"reactive\":false},\"hoverinv\":{\"css\":\"\"},\"zoom\":{\"min\":1,\"max\":1},\"capture\":{\"css\":\".selected_SVGID_ { fill:red;stroke:gray; }\",\"type\":\"multiple\",\"only_shiny\":true,\"selected\":[]},\"capturekey\":{\"css\":\".selected_key_SVGID_ { stroke:gray; }\",\"type\":\"single\",\"only_shiny\":true,\"selected\":[]},\"capturetheme\":{\"css\":\".selected_theme_SVGID_ { stroke:gray; }\",\"type\":\"single\",\"only_shiny\":true,\"selected\":[]},\"toolbar\":{\"position\":\"topright\",\"saveaspng\":true,\"pngname\":\"diagram\"},\"sizing\":{\"rescale\":true,\"width\":1}}},\"evals\":[],\"jsHooks\":[]}\rBroadly, there are three generic categories that the songs on the current playlist fall into: high energy and valence, low energy, or low valence (songs with low energy and valence will fall into one of the “low” categories). Rather than manually assign categories, we can use tidyclust to cluster the songs into three groups using the kmeans algorithm.\nThere’s some great documentation on the tidyclust site, but to get started, we’ll categorize the songs on the current playlist by “fitting” a kmeans model (using the stats engine under the hood).\n# create a clustering obj\rset.seed(918)\rding_dong_clusters \u0026lt;- k_means(num_clusters = 3) %\u0026gt;%\rfit(~ valence + energy,\rdata = ding_dong) \r\r{\"x\":{\"html\":\"\\n\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\",\"js\":null,\"uid\":\"svg_ee9c31d0-913e-4862-ba09-ebb9bab7d017\",\"ratio\":1.2,\"settings\":{\"tooltip\":{\"css\":\".tooltip_SVGID_ { color:white;padding:2px;border-radius:2px;font-family:Roboto Slab; ; position:absolute;pointer-events:none;z-index:999;}\",\"placement\":\"doc\",\"offx\":10,\"offy\":0,\"use_cursor_pos\":true,\"opacity\":0.8,\"usefill\":true,\"usestroke\":false,\"delay\":{\"over\":200,\"out\":500}},\"hover\":{\"css\":\".hover_SVGID_ { fill:#1279BF;stroke:#1279BF;cursor:pointer; }\",\"reactive\":false},\"hoverkey\":{\"css\":\".hover_key_SVGID_ { stroke:red; }\",\"reactive\":false},\"hovertheme\":{\"css\":\".hover_theme_SVGID_ { fill:green; }\",\"reactive\":false},\"hoverinv\":{\"css\":\"\"},\"zoom\":{\"min\":1,\"max\":1},\"capture\":{\"css\":\".selected_SVGID_ { fill:red;stroke:gray; }\",\"type\":\"multiple\",\"only_shiny\":true,\"selected\":[]},\"capturekey\":{\"css\":\".selected_key_SVGID_ { stroke:gray; }\",\"type\":\"single\",\"only_shiny\":true,\"selected\":[]},\"capturetheme\":{\"css\":\".selected_theme_SVGID_ { stroke:gray; }\",\"type\":\"single\",\"only_shiny\":true,\"selected\":[]},\"toolbar\":{\"position\":\"topright\",\"saveaspng\":true,\"pngname\":\"diagram\"},\"sizing\":{\"rescale\":true,\"width\":1}}},\"evals\":[],\"jsHooks\":[]}\rAs expected, the majority of songs in the current playlist fall into the bop cluster. Let’s explore this cluster using in more detail with the custom metric vibe.\n# assign to clusters\rding_dong_vibes \u0026lt;- ding_dong_clusters %\u0026gt;%\raugment(ding_dong) %\u0026gt;%\rselect(track_name,\rvalence, energy, .pred_cluster) %\u0026gt;%\rmutate(vibe = valence + energy)\r# what are songs with the biggest vibe?\rding_dong_vibes %\u0026gt;%\rarrange(desc(vibe)) %\u0026gt;%\rslice_head(n = 10) %\u0026gt;%\rknitr::kable()\r\r\r\rtrack_name\rvalence\renergy\r.pred_cluster\rvibe\r\r\r\rHey Ya!\r0.965\r0.974\rCluster_1\r1.939\r\rRasputin\r0.966\r0.893\rCluster_1\r1.859\r\rSeptember\r0.979\r0.832\rCluster_1\r1.811\r\rShe Bangs - English Version\r0.858\r0.950\rCluster_1\r1.808\r\rTake on Me\r0.876\r0.902\rCluster_1\r1.778\r\rThe Legend of Chavo Guerrero\r0.913\r0.858\rCluster_1\r1.771\r\rCan’t Hold Us (feat. Ray Dalton)\r0.847\r0.922\rCluster_1\r1.769\r\rToxic\r0.924\r0.838\rCluster_1\r1.762\r\rTimber (feat. Ke$ha)\r0.788\r0.963\rCluster_1\r1.751\r\rShake It Off\r0.942\r0.800\rCluster_1\r1.742\r\r\r\rAs expected, when arranging by vibe, the top songs are all a part of the first cluster. And they are, indeed, a vibe:\n\rCompare that with the second cluster, which are generally lower energy (I’d personally disagree with spotify ranking Mr. Blue Sky and Single Ladies as “low energy,” but most others make sense).\nding_dong_vibes %\u0026gt;%\rfilter(.pred_cluster == \u0026quot;Cluster_2\u0026quot;) %\u0026gt;%\rarrange(vibe) %\u0026gt;%\rslice_head(n = 10) %\u0026gt;%\rknitr::kable()\r\r\r\r\rtrack_name\rvalence\renergy\r.pred_cluster\rvibe\r\r\r\rMr. Blue Sky\r0.478\r0.338\rCluster_2\r0.816\r\rSingle Ladies (Put a Ring on It)\r0.272\r0.584\rCluster_2\r0.856\r\rLow (feat. T-Pain)\r0.304\r0.609\rCluster_2\r0.913\r\rI Got You\r0.544\r0.399\rCluster_2\r0.943\r\rWake Up in the Sky\r0.367\r0.578\rCluster_2\r0.945\r\rSummer, Highland Falls - Live at the Bayou, Washington, D.C. - July 1980\r0.452\r0.544\rCluster_2\r0.996\r\rWagon Wheel\r0.634\r0.403\rCluster_2\r1.037\r\rHung Up\r0.405\r0.647\rCluster_2\r1.052\r\rTake Me Out\r0.527\r0.663\rCluster_2\r1.190\r\rCountry Grammar (Hot Shit)\r0.565\r0.664\rCluster_2\r1.229\r\r\r\r\rFinally, the third cluster mostly contains songs with low valence but relatively high energy.\nding_dong_vibes %\u0026gt;%\rfilter(.pred_cluster == \u0026quot;Cluster_3\u0026quot;) %\u0026gt;%\rarrange(vibe) %\u0026gt;%\rslice_head(n = 10) %\u0026gt;%\rknitr::kable()\r\r\r\r\rtrack_name\rvalence\renergy\r.pred_cluster\rvibe\r\r\r\rClarity\r0.176\r0.781\rCluster_3\r0.957\r\rTitanium (feat. Sia)\r0.301\r0.787\rCluster_3\r1.088\r\rMr. Brightside\r0.240\r0.918\rCluster_3\r1.158\r\rAll Night (feat. Knox Fortune)\r0.392\r0.777\rCluster_3\r1.169\r\rForever\r0.445\r0.819\rCluster_3\r1.264\r\rShout, Pts. 1 \u0026amp; 2\r0.416\r0.866\rCluster_3\r1.282\r\rThe Spins\r0.550\r0.766\rCluster_3\r1.316\r\rClub Can’t Handle Me (feat. David Guetta)\r0.473\r0.869\rCluster_3\r1.342\r\rBody (feat. Brando)\r0.582\r0.764\rCluster_3\r1.346\r\rLevels - Radio Edit\r0.464\r0.889\rCluster_3\r1.353\r\r\r\r\rNow that I have the songs in the current playlist sorted by cluster, let’s pull in some new songs and assign them to the appropriate cluster!\n\rAdding new songs\rTo go searching for new songs, we’ll start by casting a wide net then narrow the search with some of the get_*() functions from spotifyr. I’ll start by using get_categories() to explore the categories available in spotify.\nget_categories() %\u0026gt;%\ras_tibble() %\u0026gt;%\rselect(id, name) %\u0026gt;%\rslice_head(n = 10) %\u0026gt;%\rknitr::kable()\r\r\rid\rname\r\r\r\rtoplists\rTop Lists\r\rhiphop\rHip-Hop\r\rpop\rPop\r\rcountry\rCountry\r\r0JQ5DAqbMKFxXaXKP7zcDp\rLatin\r\rrock\rRock\r\rsummer\rSummer\r\r0JQ5DAqbMKFAXlCG6QvYQ4\rWorkout\r\r0JQ5DAqbMKFEZPnFQSFB1T\rR\u0026amp;B\r\redm_dance\rDance/Electronic\r\r\r\rI don’t really want to play country music or R\u0026amp;B during the wedding, so I’ll filter to a few categories before using get_category_playlists() to pull in the featured playlists available in each category.\n# pull in playlist ids\rplaylists \u0026lt;- get_categories() %\u0026gt;%\ras_tibble() %\u0026gt;%\rfilter(id %in% c(\u0026quot;toplists\u0026quot;, \u0026quot;hiphop\u0026quot;, \u0026quot;pop\u0026quot;, \u0026quot;rock\u0026quot;, \u0026quot;summer\u0026quot;)) %\u0026gt;%\rpull(id) %\u0026gt;%\rmap_dfr(get_category_playlists) %\u0026gt;%\ras_tibble() %\u0026gt;%\rselect(id, name, description) %\u0026gt;%\rdistinct(id, .keep_all = TRUE)\rplaylists %\u0026gt;%\rslice_head(n = 10) %\u0026gt;%\rknitr::kable()\r\r\r\r\rid\rname\rdescription\r\r\r\r37i9dQZF1DXcBWIGoYBM5M\rToday’s Top Hits\rSteve Lacy is on top of the Hottest 50!\r\r37i9dQZF1DX0XUsuxWHRQd\rRapCaviar\rMusic from Drake, Offset and 42 Dugg.\r\r37i9dQZF1DXcF6B6QPhFDv\rRock This\rThe latest from Panic! At The Disco along with the Rock songs you need to hear today.\r\r37i9dQZF1DX4dyzvuaRJ0n\rmint\rThe world’s biggest dance hits. Cover: Zedd \u0026amp; Maren Morris\r\r37i9dQZF1DX1lVhptIYRda\rHot Country\rToday’s top country hits of the week, worldwide! Cover: Tyler Hubbard\r\r37i9dQZF1DX10zKzsJ2jva\rViva Latino\rToday’s top Latin hits, elevando nuestra música. Cover: Anitta, Maluma.\r\r37i9dQZF1DX4SBhb3fqCJd\rAre \u0026amp; Be\rThe pulse of R\u0026amp;B music today. Cover: Tink\r\r37i9dQZEVXbLRQDuF5jeBp\rTop 50 - USA\rYour daily update of the most played tracks right now - USA.\r\r37i9dQZEVXbMDoHDwVN2tF\rTop 50 - Global\rYour daily update of the most played tracks right now - Global.\r\r37i9dQZEVXbLiRSasKsNU9\rViral 50 - Global\rYour daily update of the most viral tracks right now - Global.\r\r\r\rThere’s a lot of playlists in playlists, so I’ve gone through and selected a few that I’m interested in exploring further.\nselected_playlists \u0026lt;-\rc(\u0026quot;Today\u0026#39;s Top Hits\u0026quot;,\r\u0026quot;mint\u0026quot;,\r\u0026quot;Top 50 - US\u0026quot;,\r\u0026quot;Top 50 - Global\u0026quot;,\r\u0026quot;Viral 50 - US\u0026quot;,\r\u0026quot;Viral 50 - Global\u0026quot;,\r\u0026quot;New Music Friday\u0026quot;,\r\u0026quot;Most Necessary\u0026quot;,\r\u0026quot;Internet People\u0026quot;,\r\u0026quot;Gold School\u0026quot;,\r\u0026quot;Hot Hits USA\u0026quot;,\r\u0026quot;Pop Rising\u0026quot;,\r\u0026quot;teen beats\u0026quot;,\r\u0026quot;big on the internet\u0026quot;,\r\u0026quot;Party Hits\u0026quot;,\r\u0026quot;Mega Hit Mix\u0026quot;,\r\u0026quot;Pumped Pop\u0026quot;,\r\u0026quot;Hit Rewind\u0026quot;,\r\u0026quot;The Ultimate Hit Mix\u0026quot;,\r\u0026quot;00s Rock Anthems\u0026quot;,\r\u0026quot;Summer Hits\u0026quot;,\r\u0026quot;Barack Obama\u0026#39;s Summer 2022 Playlist\u0026quot;,\r\u0026quot;Summer Hits of the 10s\u0026quot;,\r\u0026quot;Family Road Trip\u0026quot;)\rWith this shorter list of playlists, I can pull in the all the songs that appear on each with get_playlist_tracks(). Some songs may appear on multiple playlists, so we’ll only look at unique songs by track_id. I’ve already pulled in features for songs currently on the playlist, so we can filter those out as well. Finally, get_track_audio_features() limits queries to a maximum of 100 songs, so we’ll select the top 100 most popular songs within the sample.\nnew_songs \u0026lt;- playlists %\u0026gt;%\rfilter(name %in% selected_playlists) %\u0026gt;%\rpull(id) %\u0026gt;%\rmap_dfr(get_playlist_tracks) %\u0026gt;%\ras_tibble()\rnew_songs \u0026lt;- new_songs %\u0026gt;%\rselect(track.id,\rtrack.name,\rtrack.popularity) %\u0026gt;%\rrename_with(~stringr::str_replace(.x, \u0026quot;\\\\.\u0026quot;, \u0026quot;_\u0026quot;)) %\u0026gt;%\rdistinct(track_id, .keep_all = TRUE) %\u0026gt;%\rarrange(desc(track_popularity)) %\u0026gt;%\rfilter(!track_id %in% ding_dong$track_id) %\u0026gt;%\rslice_head(n = 100)\r\r\r\r\rtrack_id\rtrack_name\rtrack_popularity\r\r\r\r2tTmW7RDtMQtBk7m2rYeSw\rQuevedo: Bzrp Music Sessions, Vol. 52\r100\r\r6Sq7ltF9Qa7SNFBsV5Cogx\rMe Porto Bonito\r99\r\r1IHWl5LamUGEuP4ozKQSXZ\rTití Me Preguntó\r97\r\r4LRPiXqCikLlN15c3yImP7\rAs It Was\r96\r\r6xGruZOHLs39ZbVccQTuPZ\rGlimpse of Us\r96\r\r5Eax0qFko2dh7Rl2lYs3bx\rEfecto\r96\r\r3k3NWokhRRkEPhCzPmV8TW\rOjitos Lindos\r96\r\r6Xom58OOXk2SoU711L2IXO\rMoscow Mule\r95\r\r0mBP9X2gPCuapvpZ7TGDk3\rLeft and Right (Feat. Jung Kook of BTS)\r94\r\r5ildQOEKmJuWGl2vRkFdYc\rDESPECHÁ\r94\r\r\r\rNow let’s assign these 100 news songs to the clusters we found earlier based on their valence and energy!\nnew_song_features \u0026lt;- new_songs %\u0026gt;%\rpull(track_id) %\u0026gt;%\rget_track_audio_features()\rnew_songs \u0026lt;- new_songs %\u0026gt;%\rleft_join(new_song_features, by = c(\u0026quot;track_id\u0026quot; = \u0026quot;id\u0026quot;))\rnew_songs_clustered \u0026lt;- ding_dong_clusters %\u0026gt;%\raugment(new_songs) %\u0026gt;%\rselect(track_name,\rvalence,\renergy,\r.pred_cluster) %\u0026gt;%\rmutate(vibe = valence + energy)\r\r{\"x\":{\"html\":\"\\n\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\",\"js\":null,\"uid\":\"svg_e250ef41-2c2a-4303-88c6-a049409f1faf\",\"ratio\":1.2,\"settings\":{\"tooltip\":{\"css\":\".tooltip_SVGID_ { color:white;padding:2px;border-radius:2px;font-family:Roboto Slab; ; position:absolute;pointer-events:none;z-index:999;}\",\"placement\":\"doc\",\"offx\":10,\"offy\":0,\"use_cursor_pos\":true,\"opacity\":0.8,\"usefill\":true,\"usestroke\":false,\"delay\":{\"over\":200,\"out\":500}},\"hover\":{\"css\":\".hover_SVGID_ { fill:#1279BF;stroke:#1279BF;cursor:pointer; }\",\"reactive\":false},\"hoverkey\":{\"css\":\".hover_key_SVGID_ { stroke:red; }\",\"reactive\":false},\"hovertheme\":{\"css\":\".hover_theme_SVGID_ { fill:green; }\",\"reactive\":false},\"hoverinv\":{\"css\":\"\"},\"zoom\":{\"min\":1,\"max\":1},\"capture\":{\"css\":\".selected_SVGID_ { fill:red;stroke:gray; }\",\"type\":\"multiple\",\"only_shiny\":true,\"selected\":[]},\"capturekey\":{\"css\":\".selected_key_SVGID_ { stroke:gray; }\",\"type\":\"single\",\"only_shiny\":true,\"selected\":[]},\"capturetheme\":{\"css\":\".selected_theme_SVGID_ { stroke:gray; }\",\"type\":\"single\",\"only_shiny\":true,\"selected\":[]},\"toolbar\":{\"position\":\"topright\",\"saveaspng\":true,\"pngname\":\"diagram\"},\"sizing\":{\"rescale\":true,\"width\":1}}},\"evals\":[],\"jsHooks\":[]}\rNice! It looks like the new songs are far more broad than the original playlist, but we can look at just the songs in the first cluster with the biggest vibe.\nnew_songs_clustered %\u0026gt;%\rfilter(.pred_cluster == \u0026quot;Cluster_1\u0026quot;) %\u0026gt;%\rarrange(desc(vibe)) %\u0026gt;%\rslice_head(n = 10) %\u0026gt;%\rknitr::kable()\r\r\r\r\rtrack_name\rvalence\renergy\r.pred_cluster\rvibe\r\r\r\rBad Decisions (with BTS \u0026amp; Snoop Dogg)\r0.955\r0.861\rCluster_1\r1.816\r\rSuper Freaky Girl\r0.912\r0.891\rCluster_1\r1.803\r\rCold Heart - PNAU Remix\r0.942\r0.798\rCluster_1\r1.740\r\rShivers\r0.822\r0.859\rCluster_1\r1.681\r\rWoman\r0.881\r0.764\rCluster_1\r1.645\r\rLate Night Talking\r0.901\r0.728\rCluster_1\r1.629\r\rI Ain’t Worried\r0.825\r0.797\rCluster_1\r1.622\r\rMAMIII\r0.899\r0.700\rCluster_1\r1.599\r\rINDUSTRY BABY (feat. Jack Harlow)\r0.894\r0.704\rCluster_1\r1.598\r\rAfraid To Feel\r0.680\r0.912\rCluster_1\r1.592\r\r\r\rNow for the true vibe check — do these songs belong on the playlist?\n\rOh hell yeah!\n\rSome notes: this analysis was done on Aug. 20th, 2022 — spotify’s featured playlists and tracks change on on a regular basis and may also depend on unique user data.\n\r\r","date":1660953600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661030444,"objectID":"c2a0788e5d08bccc72bbe2ef3d264fa1","permalink":"https://www.thedatadiary.net/blog/2022-08-20-finding-new-wedding-bops-with-tidyclust-and-spotifyr/","publishdate":"2022-08-20T00:00:00Z","relpermalink":"/blog/2022-08-20-finding-new-wedding-bops-with-tidyclust-and-spotifyr/","section":"blog","summary":"Last November, I (finally) popped the big question and proposed! Since then, my fiance and I have been diligently planning our wedding. While we have most of the big-ticket items checked off (venue, catering, photography, etc.","tags":[],"title":"Finding new wedding bops with {tidyclust} and {spotifyr}","type":"blog"},{"authors":[],"categories":["rstats","nplyr"],"content":"\rData manipulation and transformation is a fundamental part of any analysis. There are excellent tools in the R ecosystem for manipulating data frames (dplyr, data.table, and arrow, to name a few). Sometimes, however, it is desirable to work with nested data frames, for which few tools are readily available.\nThis is where nplyr comes into play! nplyr is a grammar of nested data manipulation that allows users to perform dplyr-like manipulations on data frames nested within a list-col of another data frame. Most dplyr verbs have nested equivalents in nplyr. For example:\n\rnest_mutate() is the nested equivalent of mutate()\rnest_select() is the nested equivalent of select()\rnest_filter() is the nested equivalent of filter()\rnest_summarise() is the nested equivalent of summarise()\rnest_group_by() is the nested equivalent of group_by()\r\rInstallation\rnplyr 0.1.0 is available on CRAN. Alternatively, you can install the development version from github with the devtools or remotes package:\n# install from CRAN\rinstall.packages(\u0026quot;nplyr\u0026quot;)\r# install from github\rdevtools::install_github(\u0026quot;markjrieke/nplyr\u0026quot;)\r\rUsage\rTo get started, we’ll create a nested column for the country data within each continent from the gapminder dataset.\nlibrary(nplyr)\rgm_nest \u0026lt;-\rgapminder::gapminder_unfiltered %\u0026gt;%\rtidyr::nest(country_data = -continent)\rgm_nest\r## # A tibble: 6 × 2\r## continent country_data ## \u0026lt;fct\u0026gt; \u0026lt;list\u0026gt; ## 1 Asia \u0026lt;tibble [578 × 5]\u0026gt; ## 2 Europe \u0026lt;tibble [1,302 × 5]\u0026gt;\r## 3 Africa \u0026lt;tibble [637 × 5]\u0026gt; ## 4 Americas \u0026lt;tibble [470 × 5]\u0026gt; ## 5 FSU \u0026lt;tibble [139 × 5]\u0026gt; ## 6 Oceania \u0026lt;tibble [187 × 5]\u0026gt;\rdplyr can perform operations on the top-level data frame, but with nplyr, we can perform operations on the nested data frames:\ngm_nest_example \u0026lt;-\rgm_nest %\u0026gt;%\rnest_filter(country_data, year == max(year)) %\u0026gt;%\rnest_mutate(country_data, pop_millions = pop/1000000)\r# each nested tibble is now filtered to the most recent year\rgm_nest_example\r## # A tibble: 6 × 2\r## continent country_data ## \u0026lt;fct\u0026gt; \u0026lt;list\u0026gt; ## 1 Asia \u0026lt;tibble [43 × 6]\u0026gt;\r## 2 Europe \u0026lt;tibble [34 × 6]\u0026gt;\r## 3 Africa \u0026lt;tibble [53 × 6]\u0026gt;\r## 4 Americas \u0026lt;tibble [33 × 6]\u0026gt;\r## 5 FSU \u0026lt;tibble [9 × 6]\u0026gt; ## 6 Oceania \u0026lt;tibble [11 × 6]\u0026gt;\r# if we unnest, we can see that a new column for pop_millions has been created\rgm_nest_example %\u0026gt;%\rslice_head(n = 1) %\u0026gt;%\rtidyr::unnest(country_data)\r## # A tibble: 43 × 7\r## continent country year lifeExp pop gdpPercap pop_millions\r## \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Asia Afghanistan 2007 43.8 31889923 975. 31.9 ## 2 Asia Azerbaijan 2007 67.5 8017309 7709. 8.02 ## 3 Asia Bahrain 2007 75.6 708573 29796. 0.709\r## 4 Asia Bangladesh 2007 64.1 150448339 1391. 150. ## 5 Asia Bhutan 2007 65.6 2327849 4745. 2.33 ## 6 Asia Brunei 2007 77.1 386511 48015. 0.387\r## 7 Asia Cambodia 2007 59.7 14131858 1714. 14.1 ## 8 Asia China 2007 73.0 1318683096 4959. 1319. ## 9 Asia Hong Kong, China 2007 82.2 6980412 39725. 6.98 ## 10 Asia India 2007 64.7 1110396331 2452. 1110. ## # … with 33 more rows\rnplyr also supports grouped operations with nest_group_by():\ngm_nest_example \u0026lt;-\rgm_nest %\u0026gt;%\rnest_group_by(country_data, year) %\u0026gt;%\rnest_summarise(\rcountry_data,\rn = n(),\rlifeExp = median(lifeExp),\rpop = median(pop),\rgdpPercap = median(gdpPercap)\r)\rgm_nest_example\r## # A tibble: 6 × 2\r## continent country_data ## \u0026lt;fct\u0026gt; \u0026lt;list\u0026gt; ## 1 Asia \u0026lt;tibble [58 × 5]\u0026gt;\r## 2 Europe \u0026lt;tibble [58 × 5]\u0026gt;\r## 3 Africa \u0026lt;tibble [13 × 5]\u0026gt;\r## 4 Americas \u0026lt;tibble [57 × 5]\u0026gt;\r## 5 FSU \u0026lt;tibble [44 × 5]\u0026gt;\r## 6 Oceania \u0026lt;tibble [56 × 5]\u0026gt;\r# unnesting shows summarised tibbles for each continent\rgm_nest_example %\u0026gt;%\rslice(2) %\u0026gt;%\rtidyr::unnest(country_data)\r## # A tibble: 58 × 6\r## continent year n lifeExp pop gdpPercap\r## \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Europe 1950 22 65.8 7408264 6343.\r## 2 Europe 1951 18 65.7 7165515 6509.\r## 3 Europe 1952 31 65.9 7124673 5210.\r## 4 Europe 1953 17 67.3 7346100 6774.\r## 5 Europe 1954 17 68.0 7423300 7046.\r## 6 Europe 1955 17 68.5 7499400 7817.\r## 7 Europe 1956 17 68.5 7575800 8224.\r## 8 Europe 1957 31 67.5 7363802 6093.\r## 9 Europe 1958 18 69.6 8308052. 8833.\r## 10 Europe 1959 18 69.6 8379664. 9088.\r## # … with 48 more rows\r\rOther use cases\rIn the previous set of examples, the output from nplyr’s nested operations could be obtained by unnesting and performing grouped dplyr operations.\n# we can use nplyr to perform operations on the nested data\rgm_nest %\u0026gt;%\rnest_filter(country_data, year == max(year)) %\u0026gt;%\rnest_mutate(country_data, pop_millions = pop/1000000) %\u0026gt;%\rslice_head(n = 1) %\u0026gt;%\rtidyr::unnest(country_data)\r## # A tibble: 43 × 7\r## continent country year lifeExp pop gdpPercap pop_millions\r## \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Asia Afghanistan 2007 43.8 31889923 975. 31.9 ## 2 Asia Azerbaijan 2007 67.5 8017309 7709. 8.02 ## 3 Asia Bahrain 2007 75.6 708573 29796. 0.709\r## 4 Asia Bangladesh 2007 64.1 150448339 1391. 150. ## 5 Asia Bhutan 2007 65.6 2327849 4745. 2.33 ## 6 Asia Brunei 2007 77.1 386511 48015. 0.387\r## 7 Asia Cambodia 2007 59.7 14131858 1714. 14.1 ## 8 Asia China 2007 73.0 1318683096 4959. 1319. ## 9 Asia Hong Kong, China 2007 82.2 6980412 39725. 6.98 ## 10 Asia India 2007 64.7 1110396331 2452. 1110. ## # … with 33 more rows\r# in this case, we could have obtained the same result with tidyr and dplyr\rgm_nest %\u0026gt;%\rtidyr::unnest(country_data) %\u0026gt;%\rgroup_by(continent) %\u0026gt;%\rfilter(year == max(year)) %\u0026gt;%\rmutate(pop_millions = pop/1000000) %\u0026gt;%\rungroup() %\u0026gt;%\rfilter(continent == \u0026quot;Asia\u0026quot;)\r## # A tibble: 43 × 7\r## continent country year lifeExp pop gdpPercap pop_millions\r## \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Asia Afghanistan 2007 43.8 31889923 975. 31.9 ## 2 Asia Azerbaijan 2007 67.5 8017309 7709. 8.02 ## 3 Asia Bahrain 2007 75.6 708573 29796. 0.709\r## 4 Asia Bangladesh 2007 64.1 150448339 1391. 150. ## 5 Asia Bhutan 2007 65.6 2327849 4745. 2.33 ## 6 Asia Brunei 2007 77.1 386511 48015. 0.387\r## 7 Asia Cambodia 2007 59.7 14131858 1714. 14.1 ## 8 Asia China 2007 73.0 1318683096 4959. 1319. ## 9 Asia Hong Kong, China 2007 82.2 6980412 39725. 6.98 ## 10 Asia India 2007 64.7 1110396331 2452. 1110. ## # … with 33 more rows\rWhy, then, might we need to use nplyr? Well, in other scenarios, it may be far more convenient to work with nested data frames or it may not even be possible to unnest!\nConsider a set of surveys that an organization might use to gather market data. It is common for organization to have separate surveys for separate purposes but to gather the same baseline set of data across all surveys (for example , a respondent’s age and gender may be recorded across all surveys, but each survey will have a different set of questions). Let’s use two fake surveys with the below questions for this example:\nSurvey 1: Job\rHow old are you? (multiple choice)\rWhat city do you live in? (multiple choice)\rWhat field do you work in? (multiple choice)\rOverall, how satisfied are you with your job? (multiple choice)\rWhat is your annual salary? (numeric entry)\r\r\rSurvey 2: Personal Life\rHow old are you? (multiple choice)\rWhat city do you live in? (multiple choice)\rWhat field do you work in? (mulitple choice)\rOverall, how satisfied are you with your personal life (multiple choice)\rPlease provide any additional detail (text entry)\r\rIn this scenario, both surveys are collecting demographic information — age, location, and industry — but differ in the remaining questions. A convenient way to get the response files into the environment would be to use purrr::map() to read each file to a nested data frame.\npath \u0026lt;- \u0026quot;https://raw.githubusercontent.com/markjrieke/nplyr/main/data-raw/\u0026quot;\rsurveys \u0026lt;- tibble::tibble(survey_file = c(\u0026quot;job_survey\u0026quot;, \u0026quot;personal_survey\u0026quot;)) %\u0026gt;%\rmutate(survey_data = purrr::map(survey_file, ~readr::read_csv(paste0(path, .x, \u0026quot;.csv\u0026quot;))))\rsurveys\r## # A tibble: 2 × 2\r## survey_file survey_data ## \u0026lt;chr\u0026gt; \u0026lt;list\u0026gt; ## 1 job_survey \u0026lt;spec_tbl_df [500 × 6]\u0026gt;\r## 2 personal_survey \u0026lt;spec_tbl_df [750 × 6]\u0026gt;\rtidyr::unnest() can usually handle idiosyncracies in layout when unnesting, but in this case unnesting throws an error!\nsurveys %\u0026gt;%\rtidyr::unnest(survey_data)\r## Error:\r## ! Can\u0026#39;t combine `Q5` \u0026lt;double\u0026gt; and `Q5` \u0026lt;character\u0026gt;.\rThis is because the surveys share column names but not necessarily column types! In this case, both data frames contain a column named Q5, but in job_survey it’s a double and in personal_survey it’s a character.\nsurveys %\u0026gt;%\rslice(1) %\u0026gt;%\rtidyr::unnest(survey_data) %\u0026gt;%\rglimpse()\r## Rows: 500\r## Columns: 7\r## $ survey_file \u0026lt;chr\u0026gt; \u0026quot;job_survey\u0026quot;, \u0026quot;job_survey\u0026quot;, \u0026quot;job_survey\u0026quot;, \u0026quot;job_survey\u0026quot;, \u0026quot;j…\r## $ survey_name \u0026lt;chr\u0026gt; \u0026quot;job\u0026quot;, \u0026quot;job\u0026quot;, \u0026quot;job\u0026quot;, \u0026quot;job\u0026quot;, \u0026quot;job\u0026quot;, \u0026quot;job\u0026quot;, \u0026quot;job\u0026quot;, \u0026quot;job\u0026quot;, \u0026quot;j…\r## $ Q1 \u0026lt;dbl\u0026gt; 100, 81, 51, 81, 80, 32, 65, 57, 43, 94, 25, 83, 61, 66, 8…\r## $ Q2 \u0026lt;chr\u0026gt; \u0026quot;Austin\u0026quot;, \u0026quot;San Antonio\u0026quot;, \u0026quot;Austin\u0026quot;, \u0026quot;Austin\u0026quot;, \u0026quot;Dallas\u0026quot;, \u0026quot;Fo…\r## $ Q3 \u0026lt;chr\u0026gt; \u0026quot;Consulting\u0026quot;, \u0026quot;Consulting\u0026quot;, \u0026quot;Consulting\u0026quot;, \u0026quot;Technology\u0026quot;, \u0026quot;C…\r## $ Q4 \u0026lt;chr\u0026gt; \u0026quot;Somewhat dissatisfied\u0026quot;, \u0026quot;Neither satisfied nor dissatisfi…\r## $ Q5 \u0026lt;dbl\u0026gt; 163, 48, 190, 25, 143, 233, 43, 243, 158, 235, 245, 195, 2…\rsurveys %\u0026gt;%\rslice(2) %\u0026gt;%\rtidyr::unnest(survey_data) %\u0026gt;%\rglimpse()\r## Rows: 750\r## Columns: 7\r## $ survey_file \u0026lt;chr\u0026gt; \u0026quot;personal_survey\u0026quot;, \u0026quot;personal_survey\u0026quot;, \u0026quot;personal_survey\u0026quot;, \u0026quot;…\r## $ survey_name \u0026lt;chr\u0026gt; \u0026quot;personal\u0026quot;, \u0026quot;personal\u0026quot;, \u0026quot;personal\u0026quot;, \u0026quot;personal\u0026quot;, \u0026quot;personal\u0026quot;…\r## $ Q1 \u0026lt;dbl\u0026gt; 91, 32, 40, 23, 88, 69, 96, 40, 57, 40, 39, 70, 29, 38, 57…\r## $ Q2 \u0026lt;chr\u0026gt; \u0026quot;Austin\u0026quot;, \u0026quot;San Antonio\u0026quot;, \u0026quot;San Antonio\u0026quot;, \u0026quot;Austin\u0026quot;, \u0026quot;Dallas\u0026quot;…\r## $ Q3 \u0026lt;chr\u0026gt; \u0026quot;Energy\u0026quot;, \u0026quot;Healthcare\u0026quot;, \u0026quot;Consulting\u0026quot;, \u0026quot;Consulting\u0026quot;, \u0026quot;Techn…\r## $ Q4 \u0026lt;chr\u0026gt; \u0026quot;Neither satisfied nor dissatisfied\u0026quot;, \u0026quot;Extremely satisfied…\r## $ Q5 \u0026lt;chr\u0026gt; \u0026quot;Blandit eros! A, ligula facilisis imperdiet! Interdum pla…\rWe could potentially get around this issue with unnesting by reading in all columns as characters via readr::read_csv(x, col_types = cols(.default = \"c\")), but this presents its own challenges. Q5 would still be better represented as a double in job_survey and, from the survey question text, Q4 has similar, but distinctly different, meanings across the survey files.\nThis is where nplyr can assist! Rather than malign the data types or create separate objects for each survey file, we can use nplyr to perform operations directly on the nested data frames.\nsurveys \u0026lt;- surveys %\u0026gt;%\rnest_mutate(survey_data,\rage_group = if_else(Q1 \u0026lt; 65, \u0026quot;Adult\u0026quot;, \u0026quot;Retirement Age\u0026quot;)) %\u0026gt;%\rnest_group_by(survey_data, Q3) %\u0026gt;%\rnest_add_count(survey_data, name = \u0026quot;n_respondents_in_industry\u0026quot;) %\u0026gt;%\rnest_mutate(survey_data, median_industry_age = median(Q1)) %\u0026gt;%\rnest_ungroup(survey_data)\rsurveys %\u0026gt;%\rslice(1) %\u0026gt;%\rtidyr::unnest(survey_data)\r## # A tibble: 500 × 10\r## survey_file survey_name Q1 Q2 Q3 Q4 Q5 age_group\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 job_survey job 100 Austin Consulting Some… 163 Retireme…\r## 2 job_survey job 81 San Antonio Consulting Neit… 48 Retireme…\r## 3 job_survey job 51 Austin Consulting Extr… 190 Adult ## 4 job_survey job 81 Austin Technology Extr… 25 Retireme…\r## 5 job_survey job 80 Dallas Consulting Extr… 143 Retireme…\r## 6 job_survey job 32 Fort Worth Energy Some… 233 Adult ## 7 job_survey job 65 Dallas Consulting Some… 43 Retireme…\r## 8 job_survey job 57 Houston Healthcare Some… 243 Adult ## 9 job_survey job 43 Dallas Government S… Neit… 158 Adult ## 10 job_survey job 94 Fort Worth Healthcare Extr… 235 Retireme…\r## # … with 490 more rows, and 2 more variables: n_respondents_in_industry \u0026lt;int\u0026gt;,\r## # median_industry_age \u0026lt;dbl\u0026gt;\rsurveys %\u0026gt;%\rslice(2) %\u0026gt;%\rtidyr::unnest(survey_data)\r## # A tibble: 750 × 10\r## survey_file survey_name Q1 Q2 Q3 Q4 Q5 age_group\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 personal_survey personal 91 Austin Energy Neit… Blan… Retireme…\r## 2 personal_survey personal 32 San Antonio Healthca… Extr… Elem… Adult ## 3 personal_survey personal 40 San Antonio Consulti… Some… Eget… Adult ## 4 personal_survey personal 23 Austin Consulti… Extr… Scel… Adult ## 5 personal_survey personal 88 Dallas Technolo… Neit… Aene… Retireme…\r## 6 personal_survey personal 69 Fort Worth Technolo… Neit… Inte… Retireme…\r## 7 personal_survey personal 96 Houston Healthca… Extr… Blan… Retireme…\r## 8 personal_survey personal 40 Houston Consulti… Extr… Scel… Adult ## 9 personal_survey personal 57 Fort Worth Energy Extr… Pede… Adult ## 10 personal_survey personal 40 Fort Worth Healthca… Extr… Phar… Adult ## # … with 740 more rows, and 2 more variables: n_respondents_in_industry \u0026lt;int\u0026gt;,\r## # median_industry_age \u0026lt;dbl\u0026gt;\r\r\r","date":1658620800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1658697657,"objectID":"399f9b455ae68e04cab547e933c1022e","permalink":"https://www.thedatadiary.net/blog/2022-07-24-introducing-nplyr/","publishdate":"2022-07-24T00:00:00Z","relpermalink":"/blog/2022-07-24-introducing-nplyr/","section":"blog","summary":"Data manipulation and transformation is a fundamental part of any analysis. There are excellent tools in the R ecosystem for manipulating data frames (dplyr, data.table, and arrow, to name a few).","tags":[],"title":"Introducing {nplyr}","type":"blog"},{"authors":[],"categories":["rstats","workboots"],"content":"\rGenerating prediction intervals with workboots hinges on a few core concepts: bootstrap resampling, estimating prediction error for each resample, and aggregating the resampled prediction errors for each observation. The bootstraps() documentation from {rsample} gives a concise definition of bootstrap resampling:\n\rA bootstrap sample is a sample that is the same size as the original data set that is made using replacement. This results in analysis samples that have multiple replicates of some of the original rows of the data. The assessment set is defined as the rows of the original data that were not included in the bootstrap sample. This is often referred to as the “out-of-bag” (OOB) sample.\n\rThis vignette will walk through the details of estimating and aggregating prediction errors — additional resources can be found in Davison and Hinkley’s book, Bootstrap Methods and their Application, or Efron and Tibshirani’s paper, Improvements on Cross-Validation: The Bootstrap .632+ Method.\nThe Bootstrap .632+ Method\rWhat follows here is largely a summary of this explanation of the .632+ error rate by Benjamin Deonovic.\nWhen working with bootstrap resamples of a dataset, there are two error estimates we can work with: the bootstrap training error and the out-of-bag (oob) error. Using the Sacramento housing dataset, we can estimate the training and oob error for a single bootstrap.\nsacramento_boots\r#\u0026gt; # Bootstrap sampling #\u0026gt; # A tibble: 1 × 2\r#\u0026gt; splits id #\u0026gt; \u0026lt;list\u0026gt; \u0026lt;chr\u0026gt; #\u0026gt; 1 \u0026lt;split [699/261]\u0026gt; Bootstrap1\rUsing a k-nearest-neighbor regression model and rmse as our error metric, we find that the training and oob error differ, with the training error lesser than the oob error.\nsacramento_train_err\r#\u0026gt; [1] 0.08979873\rsacramento_oob_err\r#\u0026gt; [1] 0.1661675\rThe training error is overly optimistic in the model’s performance and likely to under-estimate the prediction error. We are interested in the model’s performance on new data. The oob error, on the other hand, is likely to over-estimate the prediction error! This is due to non-distinct observations in the bootstrap sample that results from sampling with replacement. Given that the average number of distinct observations in a bootstrap training set is about 0.632 * total_observations, Efron and Tibshirani proposed a blend of the training and oob error with the 0.632 estimate:\n\\[\\begin{align*}\rErr_{.632} \u0026amp; = 0.368 Err_{train} + 0.632 Err_{oob}\r\\end{align*}\\]\nsacramento_632 \u0026lt;- 0.368 * sacramento_train_err + 0.632 * sacramento_oob_err\rsacramento_632\r#\u0026gt; [1] 0.1380638\rIf, however, the model is highly overfit to the bootstrap training set, the training error will approach 0 and the 0.632 estimate will under estimate the prediction error.\nAn example from Applied Predictive Modeling shows that as model complexity increases, the reported resample accuracy by the 0.632 estimate continues to increase whereas other resampling strategies report diminishing returns:\nAs an alternative to the 0.632 estimate, Efron \u0026amp; Tibshirani also propose the 0.632+ estimate, which re-weights the blend of training and oob error based on the model overfit rate:\n\\[\\begin{align*}\rErr_{0.632+} \u0026amp; = (1 - w) Err_{train} + w Err_{oob} \\\\\r\\\\\rw \u0026amp; = \\frac{0.632}{1 - 0.368 R} \\\\\r\\\\\rR \u0026amp; = \\frac{Err_{oob} - Err_{train}}{\\gamma - Err_{train}}\r\\end{align*}\\]\nHere, \\(R\\) represents the overfit rate and \\(\\gamma\\) is the no-information error rate, estimated by evaulating all combinations of predictions and actual values in the bootstrap training set.\nsacramento_632_plus \u0026lt;- (1 - w) * sacramento_train_err + w * sacramento_oob_err\rsacramento_632_plus\r#\u0026gt; [1] 0.1450502\rWhen there is no overfitting (i.e., \\(R = 0\\)) the 0.632+ estimate will equal the 0.632 estimate. In this case, however, the model is overfitting the training set and the 0.632+ error estimate is pushed a bit closer to the oob error.\n\rPrediction intervals with many bootstraps\rFor an unbiased estimator, rmse is the standard deviation of the residuals. With this in mind, we can modify our predictions to include a sample from the residual distribution (for more information, see Algorithm 6.4 from Davison and Hinkley’s Bootstrap Methods and their Application):\nset.seed(999)\rresid_train_add \u0026lt;- rnorm(length(preds_train), 0, sacramento_632_plus)\rpreds_train_mod \u0026lt;- preds_train + resid_train_add\rThus far, we’ve been working with a single bootstrap resample. When working with a single bootstrap resample, adding this residual term gives a pretty poor estimate for each observation:\nWith workboots, however, we can repeat this process over many bootstrap datasets to generate a prediction distribution for each observation:\nlibrary(workboots)\r# fit and predict price in sacramento_test from 100 models\r# the default number of resamples is 2000 - dropping here to speed up knitting\rset.seed(555)\rsacramento_pred_int \u0026lt;-\rsacramento_wf %\u0026gt;%\rpredict_boots(\rn = 100,\rtraining_data = sacramento_train,\rnew_data = sacramento_test\r)\rThis methodology produces prediction distributions that are consistent with what we might expect from linear models while making no assumptions about model type (i.e., we can use a non-parametric model; in this case, a k-nearest neighbors regression).\n\r","date":1656979200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1657023994,"objectID":"19f7f74d8f80d49df333a5fc37291d91","permalink":"https://www.thedatadiary.net/blog/2022-07-05-the-math-behind-workboots/","publishdate":"2022-07-05T00:00:00Z","relpermalink":"/blog/2022-07-05-the-math-behind-workboots/","section":"blog","summary":"Generating prediction intervals with workboots hinges on a few core concepts: bootstrap resampling, estimating prediction error for each resample, and aggregating the resampled prediction errors for each observation. The bootstraps() documentation from {rsample} gives a concise definition of bootstrap resampling:","tags":[],"title":"The Math Behind workboots","type":"blog"},{"authors":[],"categories":["rstats","bayes theorem"],"content":"\rI recently picked up David Robinson’s book, Introduction to Empirical Bayes. It’s available online for a price of your own choosing (operating under a “pay-what-you-want” model), so you can technically pick it up for free, but it’s well worth the suggested price of $9.95. The book has a particular focus on practical steps for implementing Bayesian methods with code, which I appreciate. I’ve made it through Part I (of four), which makes for a good stopping point to practice what I’ve read.\nThe first section is highly focused on modeling the probability of success/failure of some binary outcome using a beta distribution. This is highly relevant to my work as an analyst, where whether or not a patient responded positively to a particular question on a survey can be modeled with this method. Thus far, however, I’ve taken the frequentist approach to analyses, which assumes we know nothing about what the data ought to look like prior to analyzing it. This is largely because I didn’t know of a robust way to estimate a prior for a Bayesian analysis.\nThankfully, however, the book walks through examples of exactly how to do this! We can use a maximum likelihood estimator to estimate a reasonable prior given the current data. That’s quite a bit of statistical mumbo-jumbo — in this post I’ll walk through an example that spells it out a bit more clearly using fake hospital satisfaction data (N.B.; this is largely a recreation of the steps taken in the book — practice makes perfect!).\nSetting up the data\rFirst, let’s simulate responses to patient satisfaction surveys. I tend to look at patient satisfaction scores across individual hospital units (e.g., ED, ICU, IMU, etc.). Units can have varying numbers of discharges, so we’ll use a log-normal distribution to estimate the number of responses for each unit.\n# simulate 1,500 hospital units with an average of 150 survey returns per unit\rset.seed(123)\rsurvey_data \u0026lt;- rlnorm(1500, log(150), 1.5) %\u0026gt;%\ras_tibble() %\u0026gt;%\rrename(n = value)\rThe spectrum of responses is incredibly broad — some units have a massive number of returns (in the tens of thousands!) while others have just a handful. This is fairly consistent with the real-world data that I’ve seen (though the units on the high-side are a bit over-represented here).\nNext, let’s assume that there is some true satisfaction rate that is associated with each unit. If each unit had an infinite number of survey returns, the satisfaction rate from the survey returns would approach this true value. In this case, we’ll set the true satisfaction for each unit randomly but have it hover around 66%.\n# set the true satisfaction to be different for each unit, but hover around 66%\rset.seed(234)\rsurvey_data \u0026lt;- survey_data %\u0026gt;%\rrowwise() %\u0026gt;%\rmutate(true_satisfaction = rbeta(1, 66, 34))\rAlthough there is a true satisfaction associated with each unit, we wouldn’t expect that the reported survey scores would match this exactly. This is especially true when there are few responses — if a unit has a true satisfaction rate of 75% but only 3 responses, it’s impossible for the reported score to match the underlying true rate!\nWe can simulate the number of patients who responded positively (in survey terms, the number of “topbox” responses) by generating n responses for each unit using a binomial distribution.\n# simulate the number of patients responding with the topbox value\r# we *know* the true value, but the actual score may vary!\rset.seed(345)\rsurvey_data \u0026lt;-\rsurvey_data %\u0026gt;%\rmutate(n = round(n),\rtopbox = rbinom(1, n, true_satisfaction)) %\u0026gt;%\rungroup() %\u0026gt;%\r# name each unit\rrowid_to_column() %\u0026gt;%\rmutate(unit = paste(\u0026quot;Unit\u0026quot;, rowid)) %\u0026gt;%\rrelocate(unit) %\u0026gt;%\r# remove the true satisfaction so we don\u0026#39;t know what it is!\rselect(-rowid, -true_satisfaction)\r# find patient satisfaction scores\rsurvey_data \u0026lt;- survey_data %\u0026gt;%\rmutate(score = topbox/n)\rAs expected, most of our simulated data hovers around a score of 66%. However, there are a few scores at the extremes of 0% and 100% — given how we simulated the data, it is unlikely that these units are really performing so poorly/so well and it’s likelier that they just have few returns.\n# which units have the highest scores?\rsurvey_data %\u0026gt;%\rarrange(desc(score)) %\u0026gt;%\rslice_head(n = 10) %\u0026gt;%\rknitr::kable()\r\r\runit\rn\rtopbox\rscore\r\r\r\rUnit 26\r12\r12\r1.0000000\r\rUnit 591\r2\r2\r1.0000000\r\rUnit 616\r3\r3\r1.0000000\r\rUnit 811\r3\r3\r1.0000000\r\rUnit 943\r12\r12\r1.0000000\r\rUnit 1217\r6\r6\r1.0000000\r\rUnit 1435\r3\r3\r1.0000000\r\rUnit 1437\r6\r6\r1.0000000\r\rUnit 863\r19\r18\r0.9473684\r\rUnit 372\r13\r12\r0.9230769\r\r\r\r# which units have the lowest scores?\rsurvey_data %\u0026gt;%\rarrange(score) %\u0026gt;%\rslice_head(n = 10) %\u0026gt;%\rknitr::kable()\r\r\runit\rn\rtopbox\rscore\r\r\r\rUnit 1092\r4\r0\r0.0000000\r\rUnit 248\r20\r5\r0.2500000\r\rUnit 1120\r7\r2\r0.2857143\r\rUnit 416\r3\r1\r0.3333333\r\rUnit 456\r3\r1\r0.3333333\r\rUnit 972\r6\r2\r0.3333333\r\rUnit 113\r13\r5\r0.3846154\r\rUnit 260\r15\r6\r0.4000000\r\rUnit 695\r15\r6\r0.4000000\r\rUnit 1352\r17\r7\r0.4117647\r\r\r\rAs expected, the units on either end of the spectrum aren’t necessarily outperforming/underperforming — they simply don’t have a lot of survey responses! We can use Bayesian inference to estimate the true satisfaction rate by specifying and updating a prior!\n\rGenerating a prior distribution\rWhen looking at the entire dataset, the distribution of scores is thrown off a bit by the units with few responses. If we restrict the dataset to only the units that have more than 30 responses (which, as I’ve written about before, isn’t necessarily a data-driven cutoff for analysis) we can get a clearer idea of the distribution of the scores.\nsurvey_data_filtered \u0026lt;-\rsurvey_data %\u0026gt;%\rfilter(n \u0026gt; 30)\rAlternatively, we can represent this distribution with a density plot:\nThis looks suspiciously like a beta distribution! A beta distribution’s shape can be defined by two parameters — alpha and beta. Varying these parameters lets us adjust the center and width to match any possible beta distribution.\nWhat may make sense would be to use this distribution as our prior. I.e., if we have no responses for a unit, we can probably guess that their score would be somewhere around 66% with some healthy room on either side for variability. To do so, we need to estimate an appropriate alpha and beta — rather than guess the values using trial and error we can pass the work off to our computer to find parameters that maximize the likelihood that our estimated distribution matches the true distribution (hence the name, maximum likelihood estimator).\nlibrary(stats4)\r# log-likelihood function\rlog_likelihood \u0026lt;- function(alpha, beta) {\r-sum(dbeta(survey_data_filtered$score, alpha, beta, log = TRUE))\r}\r# pass various alphas \u0026amp; betas to `log_likelihood` # to find combination that maximizes the likelihood!\rparams \u0026lt;- mle(\rlog_likelihood, start = list(alpha = 50, beta = 50),\rlower = c(1, 1)\r)\r# extract alpha \u0026amp; beta\rparams \u0026lt;- coef(params)\ralpha0 \u0026lt;- params[1]\rbeta0 \u0026lt;- params[2]\rprint(paste(\u0026quot;alpha:\u0026quot;, round(alpha0, 1), \u0026quot;beta:\u0026quot;, round(beta0, 1)))\r## [1] \u0026quot;alpha: 39.7 beta: 20.5\u0026quot;\rHow well does a beta distribution defined by these parameters match our actual data?\nThis is a pretty good representation of our initial data! When we have no survey responses, we can use a beta distribution with the initial parameters as specified by the maximum likelihood estimation. As a unit gets more responses, we can update our estimation to rely more heavily on the data rather than the prior:\n# update alpha \u0026amp; beta as new responses come in!\ralpha_new \u0026lt;- alpha0 + n_topbox\rbeta_new \u0026lt;- beta0 + n - n_topbox\r\rUpdating our priors\rWith a prior distribution defined by alpha0 and beta0, we can upgrade our frequentest estimation of each unit’s score to a Bayesian estimation!\n# empirical bayes estimation of satisfaction score\rsurvey_eb \u0026lt;-\rsurvey_data %\u0026gt;%\rmutate(eb_estimate = (topbox + alpha0) / (n + alpha0 + beta0))\rWhat are the top and bottom performing units by this new Bayesian estimation?\n# which units have the highest estimated scores?\rsurvey_eb %\u0026gt;%\rarrange(desc(eb_estimate)) %\u0026gt;%\rslice_head(n = 10) %\u0026gt;%\rknitr::kable()\r\r\runit\rn\rtopbox\rscore\reb_estimate\r\r\r\rUnit 133\r160\r133\r0.8312500\r0.7841640\r\rUnit 1004\r123\r103\r0.8373984\r0.7787827\r\rUnit 172\r165\r133\r0.8060606\r0.7667547\r\rUnit 1042\r372\r291\r0.7822581\r0.7650930\r\rUnit 1294\r1409\r1083\r0.7686302\r0.7641391\r\rUnit 892\r349\r273\r0.7822350\r0.7641085\r\rUnit 306\r247\r195\r0.7894737\r0.7639102\r\rUnit 1249\r1234\r943\r0.7641815\r0.7592901\r\rUnit 427\r5469\r4151\r0.7590053\r0.7579168\r\rUnit 920\r1637\r1243\r0.7593158\r0.7557585\r\r\r\r# which units have the lowest estimated scores?\rsurvey_eb %\u0026gt;%\rarrange(eb_estimate) %\u0026gt;%\rslice_head(n = 10) %\u0026gt;%\rknitr::kable()\r\r\runit\rn\rtopbox\rscore\reb_estimate\r\r\r\rUnit 613\r1886\r932\r0.4941676\r0.4992689\r\rUnit 760\r112\r49\r0.4375000\r0.5149645\r\rUnit 363\r226\r112\r0.4955752\r0.5299674\r\rUnit 316\r431\r224\r0.5197216\r0.5368008\r\rUnit 1032\r235\r119\r0.5063830\r0.5375222\r\rUnit 1093\r354\r183\r0.5169492\r0.5376064\r\rUnit 749\r5286\r2839\r0.5370791\r0.5384528\r\rUnit 291\r865\r460\r0.5317919\r0.5400741\r\rUnit 515\r60\r26\r0.4333333\r0.5463929\r\rUnit 622\r242\r127\r0.5247934\r0.5515432\r\r\r\rThere are a few things that are worth noting with these estimates:\n\rThe estimated score is not the same as the actual reported score! As more responses come in, however, the estimated score converges to the actual.\rThe prior pulls estimated scores towards the prior mean — low scores are pulled up a bit and high scores are pulled down a bit.\rThe top (and bottom) performing units are no longer dominated by units with few returns!\r\rWe can also estimate the uncertainty around the estimated score with a credible interval. Credible intervals are the Bayesian counterpart to a frequentist’s confidence interval — both estimate the region that the true value could fall in given a certain probability — credible intervals, however, are informed by the prior distribution.\nBecause credible intervals are informed in part by the prior, they are tighter than their confidence interval counterparts. Like with the estimated score, however, as n-size increases, the Bayesian and frequentist interval estimations converge. In the absence of larger swathes of data, Bayesian methods can offer additional insight into our data by means of a prior distribution.\n\rSome closing thoughts\rOverall, this has been a fairly glowing review of the methods laid out in the first section of Introduction to Empirical Bayes. That being said, Bayesian methods of inference are not inherently better than frequentist methods — while they can offer additional context via a prior, there are situations where frequentist methods are preferred. From a math perspective, the prior provides diminishing returns as sample size increases, so it may be better forgoe Bayesian analysis when sample sizes are large. From an organizational perspective, Bayesian inference may be difficult to explain. In my own work, it’s highly unlikely that I’ll use Bayesian inference in any critical projects any time soon — I can imagine a lengthy uphill battle trying to explain the difference between the reported score and the estimated score informed by a prior.\nFinally, there are a few things in this toy analysis that I am hoping to improve upon as I progress further through the book:\n\rAs I mentioned above and in previous writings, using n = 30 is a relatively arbitrary cutoff point for analysis. In this case, the prior distribution is fairly sensitive to the cutoff point selected — I am hoping that later sections in the book highilight more robust ways of partitioning data for setting priors.\rIn the above analysis we’re only examining one variable (univariate analysis) — I am looking forward to extending these methods to multivariate analyses and regressions.\rThe beta distribution is appropriate for modeling the probability distribution of binary outcomes. In this example, where the outcome is simply the proportion of patients that responded favorably to the survey, modeling the outcome with a beta distribution is appropriate (responses can either be in the “topbox” or not). When there are more than two possible outcomes — for example, when trying to model Net Promoter Score as the proportion of “promoters,” “passives,” and “detractors” — the more general Dirichlet distribution is more appropriate.\rI’m hoping also that the book covers methods for dealing with time-dependent data. For example, we’d expect that concerted efforts (or lack thereof) by the hospital units could significantly impact the underlying “true satisfaction” that we’re attempting to estimate via surveying. We expect that more recent survey responses should be more impactful in informing our posterior estimation, but I’ve yet to find any robust literature on how to weight the recency of responses. In the past, I’ve used exponentional decay to reduce the weight of old responses, but this feels a bit arbitrary.\r\rOverall, this has been a long way of saying that I’m happy with the book so far and I’m excited to see what comes next as I continue reading!\n\r","date":1654992000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1655069829,"objectID":"c72fc830790de9c20e14c9425f722359","permalink":"https://www.thedatadiary.net/blog/2022-06-12-estimate-your-uncertainty/","publishdate":"2022-06-12T00:00:00Z","relpermalink":"/blog/2022-06-12-estimate-your-uncertainty/","section":"blog","summary":"I recently picked up David Robinson’s book, Introduction to Empirical Bayes. It’s available online for a price of your own choosing (operating under a “pay-what-you-want” model), so you can technically pick it up for free, but it’s well worth the suggested price of $9.","tags":[],"title":"Estimate your uncertainty","type":"blog"},{"authors":[],"categories":["rstats"],"content":"\rI am an avid R user and will always advocate that others use R (or another programming language) for generating reproducible visualizations. In just about every organization, however, Excel plays an important role in an analyst’s toolkit. In this post, I’ll share some visualization design practices that I picked up while learning R but are ubiquitous and transferable to Excel (most of these suggestions are ripped directly from Will Chase’s “Glamour of Graphics” talk from rstudio::conf(2020), which has heavily informed how I think about visualization design).\nA motivating example\rFor the purposes of this exercise, let’s use fake patient satisfaction data from the Sesame Street Health System, which includes several hospitals and campuses. Let’s say that our system-wide patient satisfaction for the current fiscal year looks like this:\nMost of the hospitals have pretty high satisfaction scores — generally greater than 75%! The overall system score, however, sits at 65%. Concerned that there may be an error in the data pipeline or dashboard, your boss asks that you investigate what’s going on and provide an update at the next team meeting.\nAt first glance, it may be pretty obvious what’s going on — Big Bird Emergency has a pretty low satisfaction score and you know from experience that it’s a larger hospital that generates a lot of survey returns, which may be driving the score down. Since you’re presenting, however, it’s best to use a visualization to communicate this.\n\rPutting together a bad plot\rDownloading the hospital data and opening in Excel confirms that Big Bird Emergency has far more survey returns than other hospitals.\nA quick plot that technically includes all the information needed may look something like this:\nWhile this does answer the question originally asked, the answer is not clearly communicated by a quick glance. Viewers who know what was originally asked have to do some extra mental work to decode the plot, and viewers who see this without the original context may not find anything useful. Our goal should be to provide a visualization that:\nClearly communicates the message we want to convey.\rIs able to stand alone in other contexts and still communicate the same message.\rIs visually appealing.\r\rLet’s get started!\n\rPutting together a good plot\rChanging to a bar plot\rThe first order of business is to convert the plot from a pie chart to a bar plot. Pie charts are loved by executives but loathed by visualization practitioners, since information is encoded in each slice’s angle and differences in angle are difficult for the human eye to detect. Bar plots encode the same information with relative position on a scale, which is the most effective method for showing differences. This also has the added benefit in Excel of automatically converting each hospital to the same color, which reduces a lot of the visual noise that was in the original plot.\n\rFlipping axes\rIn order to read the hospital names in the previous plot, viewers need to crane their necks to align with the axis text. The angled text also takes up a lot of whitespace and makes the important part — the actual data — look a bit squished. Changing to a horizontal bar plot alleviates both of these issues (horizontal bar plots are preferred over vertical ones in general for this reason).\n\rOrdering the data\rUnordered categories in a plot can be messy and visually confusing — the viewer’s eye needs to dart around to determine which values are greater than other ones. Ordering the categories reduces this cognitive load and allows the viewer to simply read through the list. In this case (and in most cases), we don’t care about the exact values (just the relative difference between values), so we can also remove the data labels.\nTo order a plot in Excel, we don’t actually need to do anything to the plot itself — simply turn the raw data into a table then arrange the rows by survey_returns:\n\rGiving the plot a narrative\rThe original title, “FYTD Surveys”, while technically informative, is uninspiring. We’re putting together this plot to answer the specific question, why is the system satisfaction score 65% when most hospitals have a higher score? A good visualization will directly answer this without needing additional context from the analyst — the title is a great place to state that Big Bird Emergency is driving the system score down.\nAlso note that there are no axis labels on this plot. Axis labels are often unnecessary — they take up valuable whitespace with information that is either readily apparent (I don’t need a label to know that the y-axis refers to each hospital!) or encoded elsewhere. When possible, remove axis labels and describe the necessary detail elsewhere (i.e., the title or subtitle).\n\rHighlighting the important bits\rColor can be a great way to draw our attention to a particular portion of a plot. In this case, not all of the hospitals are equally important in this plot’s narrative — we’re making a distinct point regarding Big Bird Emergency. Highlighting the text and bar for Big Bird Emergency in yellow (Big Bird is, after all, a big yellow bird) while graying out the other bars visually communicates to the viewer this is the hospital deserving the most attention in this plot.\n\rRealigning the plot\rIn the vast majority of cases, a left-aligned the title/subtitle is strongly preferred over center-aligned one. In western countries, we tend to naturally orient our attention in the top-left corner of plots when we first view them, then migrate our gaze downwards and leftwards (eye-tracking studies confirm this, however I can’t seem to find the source I heard this from, so you’ll just have to take my word for it here). By aligning the title to the left, we reduce how much the viewer needs to dart their eyes around the plot to understand it.\n\rAdding the final touches\rAdding some final formatting touches to polish up the visualization not only improves the quality of the plot but also shows the viewer that you’re serious about your craft and willing to go the extra mile to really make a visualization shine. In this case, applying comma-formatting to the x-axis, changing the font, and updating the background to an off-white are all minor edits, but their effects have a big impact on the visualization’s overall presentation.\nMy buddy is an electrician and told me a few months ago that he always leaves the screws in a vertical position on jobs as a sign of craftsmanship. Been thinking ever since what my “vertical screws” equivalent is for product design. pic.twitter.com/dM9CFEG8MF\n\u0026mdash; Mike Rundle (@flyosity) February 19, 2022  \r\r","date":1653955200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1654026357,"objectID":"83adc8c1f15c388034d84089590a97ac","permalink":"https://www.thedatadiary.net/blog/2022-05-31-practical-data-vizualization-tips-for-excel-users/","publishdate":"2022-05-31T00:00:00Z","relpermalink":"/blog/2022-05-31-practical-data-vizualization-tips-for-excel-users/","section":"blog","summary":"I am an avid R user and will always advocate that others use R (or another programming language) for generating reproducible visualizations. In just about every organization, however, Excel plays an important role in an analyst’s toolkit.","tags":[],"title":"Practical Data Visualization Tips for Excel Users","type":"blog"},{"authors":[],"categories":["rstats"],"content":"\rIn my role as an analyst, my team and I are required to put together reports that summarize each hospital’s patient satisfaction performance in a table. These are reviewed by our system’s executive leadership team and the hospital directors in monthly operational reviews (MORs). The format I inherited, loosely recreated below with fake data, color codes each month’s performance against the hospital’s goal: green when outperforming and red when underperforming.\n“But wait!” you may ask, “what do the gray cells mean?” That, dear reader, has been the source of most of my organizational frustration in this role. When the number of surveys returned is less than 30 for a given month, we simply gray-out that cell under the guise of the phrase, “30 is not statistical.”\nI don’t think this practice (or something similar) is unique to my organization — I’ve seen similar outputs from previous employers and in other companies’ published reports. While this isn’t the best use of the underlying data, I understand why this sort of method gets adapted into so many organizational lexicons: companies want their decisions to be based on data and their understanding, albeit incorrect, is that a sample size less than 30 doesn’t provide meaningful info. For this reason, I think it’s important to explore where this sentiment came from, what the problems with this data-presentation style are, what I think would be a better way of presenting the data, and ultimately why companies may be hesitant to update their methodology.\nWhere does this come from?\rAt first glance, 30 is a pretty arbitrary number to use as a cutoff. In this case, this cutoff can cause downstream issues with interpreting the data because the difference between n = 30 and n = 31 is so visually distinct! In our case, the cutoff of 30 was passed down from one of our previous survey vendors, but I believe that the wider root of why this value appears has to do with the central limit theorem.\nThe central limit theorem states that as a sample size increases, the probability distribution of the sample mean approaches a normal distribution, regardless of the source distribution! As a rule of thumb, this theorem holds true when the sample size is at least 30. In practice, this means that when there are at least 30 samples, we can generally approximate the distribution as normal. The central limit theorem is incredibly useful and an important foundation for a wide array of statistical techniques. Stating that the data doesn’t meet the criteria for the central limit theorem to hold, however, is very different from saying that data is worthless when the sample size is less than 30!\n\rProblems with this approach\rSometimes, the source distribution is known, and whether or not the central limit theorem holds is irrelevant! In my particular case, I am often dealing with patient satisfaction data that lies on a 0-100% scale. This is the perfect use case for modeling the sample with the beta distribution (which is bound by 0 and 1).\rAs mentioned above, graying-out samples where the sample size is less than 30 visually communicates that some months can be ignored. This is a waste of valuable data! While it is true that a larger sample size implies greater confidence in the score, the confidence interval widths for n = 30 and n = 31 are not so different and we can still estimate the uncertainty with the smaller sample.\rTabular data is incredibly difficult to parse at-a-glance! Research shows that spatial encoding (e.g., length, position) is the most interpretable mode of data presentation. Intuitively, it makes sense — there’s a lot less mental overhead involved in looking at a set of points and comparing positions collectively than stringing together several comparisons of individual pairs of numbers in your head.\r\r\rA better approach\rWhen the underlying distribution is known, a better approach would be to display the data in a plot, regardless of n-size, and use a confidence interval to indicate uncertainty. In this case, we can plot each survey’s scores over time with a line and use a shaded area for the confidence interval.\nThis, I believe, has a few benefits.\nThis is simply more visually appealing than the table. I (along with most people, I’d assume) prefer the look of a well formatted plot over a well formatted table (even if well formatted, a table is still a big block of text).\rIt is far easier to discern the overall trend. Instead of reading and trying to compare values, we can simply see which direction the line is moving!\rMost imortantly, we do not throw out valuable data because of sample size. We actually end up encoding more information — n-size, which was missing from the table, is encoded in the width of the confidence interval (a smaller confidence interval indicates a larger sample). In this toy example, surveys B and D included a few months with fewer than 30 returns — can you tell which months they were without looking at the table?\r\rThe tradeoff is that we can no longer explicitly see each month’s score and it is a bit harder to tell if a hospital is meeting the goal when the score is close. In my experience, however, this is not how formatted tables are used — executives that I interact with typically try to determine overall trends from tabular data!\n\rOrganizational resistance\rWhile the changes suggested here have clear benefits over the table, I’ve thus far been unsuccessful in any attempts to change the reporting methodology and I suspect that similar efforts at other companies would encounter similar organizational resistance. Much of what’s stated below is anec-data, but I assume will ring true to anyone who has struggled with getting their proposed operational changes implemented.\nAs companies scale, it becomes more \u0026amp; more difficult to implement change. On top of that, some industries (including Healthcare, the one I work in) are similarly inertial on an industry level. In this particular case, changing a report’s format may seem small in the grand scheme of things, but this is the same format the executive team has been seeing since 2017! The system executives and individual hospital leaders have a rapport and vernacular built around these monthly reports in this format — updating the format similarly requires that the executives and leaders update their long-held understanding and language built around tabular data.\nTabular data in general shows up in reports across industries. My hunch is that the main driver of this is the widespread integration of Microsoft Excel as the workhorse for most analysts’ tasks. Excel get wide use as a calculator, a data storage system (eek!), and a presentation tool. Most analysts are incredibly comfortable working in Excel and while it is possible to create plots that show both the score and confidence interval, it is far simpler to apply a bit of conditional formatting and submit the raw data as the report itself.\nThis is not to say that tabular reports have no use — when individual values are important, tabular reports are preferred! If, however, the goal is to understand trends over time or relationships between values, plots are a far better option!\n\r","date":1651104000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1651159273,"objectID":"af03280b3401daba9176da1fc9c6ae12","permalink":"https://www.thedatadiary.net/blog/2022-04-28-30-is-not-statistical/","publishdate":"2022-04-28T00:00:00Z","relpermalink":"/blog/2022-04-28-30-is-not-statistical/","section":"blog","summary":"In my role as an analyst, my team and I are required to put together reports that summarize each hospital’s patient satisfaction performance in a table. These are reviewed by our system’s executive leadership team and the hospital directors in monthly operational reviews (MORs).","tags":[],"title":"\"30 is not Statistical\"","type":"blog"},{"authors":[],"categories":["politics"],"content":"\rA few months ago, Harrison Lavelle wrote a piece for Split Ticket reviewing the electoral challenges faced by house republicans who voted to impeach Donald Trump for his role in the assault on the capitol. Examining the voting records of these republicans who broke with their colleagues shows, unsurprisingly, that they tend to be more supportive of bills protecting democratic (note — small “d”) norms.\nFiveThirtyEight developed a democracy index to evaluate how members of congress vote to protect democratic basics and create a more inclusive democracy (higher scores indicate that the congressman/woman is more supportive of bills protecting/expanding democracy). The linked article is well worth reading and walks through the caveats and limitations of the metric, but, notably, house republicans who voted to impeach Donald Trump are on average more supportive of pro-democracy bills than their colleagues who voted to acquit (on bills through September 1st of last year, the day the article was published).\nThere are some outliers: Tom Rice (SC-7) voted to impeach Trump but his votes on (small d) democratic bills are in line with the rest of house republicans whereas Brian Fitzpatrick (PA-1) and Tom Reed (NY-23) voted to acquit but have the highest pro-democracy scores by this ranking (there are other republicans who voted to acquit that have democracy scores similar to their colleagues who voted to impeach, but to avoid cluttering the plot, only the mathematical outliers are shown).\nPolling bites\rThere has been very little movement in the generic congressional ballot — republicans are still slightly favored by ~2 points. Biden’s presidential approval rating received a slight bump at the onset of Russia’s invasion of Ukraine, but the marginal gains since then have faded away and he currently sits at a -12.6% net approval.\n\r","date":1649203200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1649278180,"objectID":"64843e7cda1ebbc89688e485dbbd41ae","permalink":"https://www.thedatadiary.net/blog/2022-04-06-impeachment-republicans-and-democracy/","publishdate":"2022-04-06T00:00:00Z","relpermalink":"/blog/2022-04-06-impeachment-republicans-and-democracy/","section":"blog","summary":"A few months ago, Harrison Lavelle wrote a piece for Split Ticket reviewing the electoral challenges faced by house republicans who voted to impeach Donald Trump for his role in the assault on the capitol.","tags":[],"title":"Impeachment Republicans and Democracy","type":"blog"},{"authors":[],"categories":["rstats","workboots"],"content":"\r\rSometimes, we want a model that generates a range of possible outcomes around each prediction and may opt for a model that can generate a prediction interval, like a linear model. Other times, we just care about point predictions and may opt to use a more powerful model like XGBoost. But what if we want the best of both worlds: getting a range of predictions while still using a powerful model? That’s where {workboots} comes to the rescue! {workboots} uses bootstrap resampling to train many models which can be used to generate a range of outcomes — regardless of model type.\nInstallation\rVersion 0.1.0 of {workboots} is available on CRAN. Given that the package is still in early development, however, I’d recommend installing the development version from github:\n# install from CRAN\rinstall.packages(\u0026quot;workboots\u0026quot;)\r# or install the development version\rdevtools::install_github(\u0026quot;markjrieke/workboots\u0026quot;)\r\rUsage\r{workboots} builds on top of the {tidymodels} suite of packages and is intended to be used in conjunction with a tidymodel workflow. Teaching how to use {tidymodels} is beyond the scope of this post, but some helpful resources are linked at the bottom for further exploration.\nWe’ll walk through two examples that show the benefit of the package: estimating a linear model’s prediction interval and generating a prediction interval for a boosted tree model.\n\rEstimating a prediction interval\rLet’s get started with a model we know can generate a prediction interval: a basic linear model. In this example, we’ll use the Ames housing dataset to predict a home’s price based on its square footage.\nlibrary(tidymodels)\r# setup our data\rdata(\u0026quot;ames\u0026quot;)\rames_mod \u0026lt;- ames %\u0026gt;% select(First_Flr_SF, Sale_Price)\r# relationship between square footage and price\rames_mod %\u0026gt;%\rggplot(aes(x = First_Flr_SF, y = Sale_Price)) +\rgeom_point(alpha = 0.25) +\rscale_y_continuous(labels = scales::dollar_format(), trans = \u0026quot;log10\u0026quot;) +\rscale_x_continuous(labels = scales::comma_format(), trans = \u0026quot;log10\u0026quot;) +\rlabs(title = \u0026quot;Relationship between Square Feet and Sale Price\u0026quot;,\rsubtitle = \u0026quot;Linear relationship between the log transforms of square footage and price\u0026quot;,\rx = NULL,\ry = NULL)\rWe can use a linear model to predict the log transform of Sale_Price based on the log transform of First_Flr_SF. In this example, we’ll train a linear model then plot our predictions against a holdout set with a prediction interval.\n# log transform\rames_mod \u0026lt;- ames_mod %\u0026gt;%\rmutate(across(everything(), log10))\r# split into train/test data\rset.seed(918)\rames_split \u0026lt;- initial_split(ames_mod)\rames_train \u0026lt;- training(ames_split)\rames_test \u0026lt;- testing(ames_split)\r# train a linear model\rset.seed(314)\rmod \u0026lt;- lm(Sale_Price ~ First_Flr_SF, data = ames_train)\r# predict on new data with a prediction interval\rames_preds \u0026lt;-\rmod %\u0026gt;%\rpredict(ames_test, interval = \u0026quot;predict\u0026quot;) %\u0026gt;%\ras_tibble()\r# plot!\rames_preds %\u0026gt;%\r# re-scale predictions to match the original dataset\u0026#39;s scale\rbind_cols(ames_test) %\u0026gt;%\rmutate(across(everything(), ~10^.x)) %\u0026gt;%\r# add geoms\rggplot(aes(x = First_Flr_SF)) +\rgeom_point(aes(y = Sale_Price),\ralpha = 0.25) +\rgeom_line(aes(y = fit),\rsize = 1) +\rgeom_ribbon(aes(ymin = lwr,\rymax = upr),\ralpha = 0.25) +\rscale_y_continuous(labels = scales::dollar_format(), trans = \u0026quot;log10\u0026quot;) +\rscale_x_continuous(labels = scales::comma_format(), trans = \u0026quot;log10\u0026quot;) +\rlabs(title = \u0026quot;Linear Model of Sale Price predicted by Square Footage\u0026quot;,\rsubtitle = \u0026quot;Shaded area represents the 95% prediction interval\u0026quot;,\rx = NULL,\ry = NULL) \rWith {workboots}, we can approximate the linear model’s prediction interval by passing a workflow built on a linear model to the function predict_boots().\nlibrary(tidymodels)\rlibrary(workboots)\r# setup a workflow with a linear model\rames_wf \u0026lt;-\rworkflow() %\u0026gt;%\radd_recipe(recipe(Sale_Price ~ First_Flr_SF, data = ames_train)) %\u0026gt;%\radd_model(linear_reg())\r# generate bootstrap predictions on ames_test\rset.seed(713)\rames_preds_boot \u0026lt;-\rames_wf %\u0026gt;%\rpredict_boots(\rn = 2000,\rtraining_data = ames_train,\rnew_data = ames_test\r)\rpredict_boots() works by creating 2000 bootstrap resamples of the training data, fitting a linear model to each resample, then generating 2000 predictions for each home’s price in the holdout set. We can then use summarise_predictions() to generate upper and lower intervals for each prediction.\names_preds_boot %\u0026gt;%\rsummarise_predictions()\r## # A tibble: 733 x 5\r## rowid .preds .pred_lower .pred .pred_upper\r## \u0026lt;int\u0026gt; \u0026lt;list\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 \u0026lt;tibble [2,000 x 2]\u0026gt; 5.17 5.44 5.71\r## 2 2 \u0026lt;tibble [2,000 x 2]\u0026gt; 4.98 5.27 5.55\r## 3 3 \u0026lt;tibble [2,000 x 2]\u0026gt; 4.97 5.25 5.52\r## 4 4 \u0026lt;tibble [2,000 x 2]\u0026gt; 5.12 5.40 5.67\r## 5 5 \u0026lt;tibble [2,000 x 2]\u0026gt; 5.15 5.44 5.71\r## 6 6 \u0026lt;tibble [2,000 x 2]\u0026gt; 4.93 5.21 5.49\r## 7 7 \u0026lt;tibble [2,000 x 2]\u0026gt; 4.67 4.94 5.22\r## 8 8 \u0026lt;tibble [2,000 x 2]\u0026gt; 4.85 5.13 5.40\r## 9 9 \u0026lt;tibble [2,000 x 2]\u0026gt; 4.87 5.14 5.41\r## 10 10 \u0026lt;tibble [2,000 x 2]\u0026gt; 5.14 5.41 5.69\r## # ... with 723 more rows\rBy overlaying the intervals on top of one another, we can see that the prediction interval generated by predict_boots() is a good approximation of the theoretical interval generated by lm().\names_preds_boot %\u0026gt;%\rsummarise_predictions() %\u0026gt;%\rbind_cols(ames_preds) %\u0026gt;%\rbind_cols(ames_test) %\u0026gt;%\rmutate(across(c(.pred_lower:Sale_Price), ~10^.x)) %\u0026gt;%\rggplot(aes(x = First_Flr_SF)) +\rgeom_point(aes(y = Sale_Price),\ralpha = 0.25) +\rgeom_line(aes(y = fit),\rsize = 1) +\rgeom_ribbon(aes(ymin = lwr,\rymax = upr),\ralpha = 0.25) +\rgeom_point(aes(y = .pred),\rcolor = \u0026quot;blue\u0026quot;,\ralpha = 0.25) +\rgeom_errorbar(aes(ymin = .pred_lower,\rymax = .pred_upper),\rcolor = \u0026quot;blue\u0026quot;,\ralpha = 0.25,\rwidth = 0.0125) +\rscale_y_continuous(labels = scales::dollar_format(), trans = \u0026quot;log10\u0026quot;) +\rscale_x_continuous(labels = scales::comma_format(), trans = \u0026quot;log10\u0026quot;) +\rlabs(title = \u0026quot;Linear Model of Sale Price predicted by Square Footage\u0026quot;,\rsubtitle = \u0026quot;Bootstrap prediction interval closely matches theoretical prediction interval\u0026quot;,\rx = NULL,\ry = NULL)\rBoth lm() and summarise_predictions() use a 95% prediction interval by default but we can generate other intervals by passing different values to the parameter conf:\names_preds_boot %\u0026gt;%\r# generate 95% prediction interval\rsummarise_predictions(conf = 0.95) %\u0026gt;%\rrename(.pred_lower_95 = .pred_lower,\r.pred_upper_95 = .pred_upper) %\u0026gt;%\rselect(-.pred) %\u0026gt;%\r# generate 80% prediction interval\rsummarise_predictions(conf = 0.80) %\u0026gt;%\rrename(.pred_lower_80 = .pred_lower,\r.pred_upper_80 = .pred_upper) %\u0026gt;%\rbind_cols(ames_test) %\u0026gt;%\rmutate(across(c(.pred_lower_95:Sale_Price), ~10^.x)) %\u0026gt;%\r# plot!\rggplot(aes(x = First_Flr_SF)) +\rgeom_point(aes(y = Sale_Price),\ralpha = 0.25) +\rgeom_line(aes(y = .pred),\rsize = 1,\rcolor = \u0026quot;blue\u0026quot;) +\rgeom_ribbon(aes(ymin = .pred_lower_95,\rymax = .pred_upper_95),\ralpha = 0.25,\rfill = \u0026quot;blue\u0026quot;) +\rgeom_ribbon(aes(ymin = .pred_lower_80,\rymax = .pred_upper_80),\ralpha = 0.25,\rfill = \u0026quot;blue\u0026quot;) +\rscale_y_continuous(labels = scales::dollar_format(), trans = \u0026quot;log10\u0026quot;) +\rscale_x_continuous(labels = scales::comma_format(), trans = \u0026quot;log10\u0026quot;) +\rlabs(title = \u0026quot;Linear Model of Sale Price predicted by Square Footage\u0026quot;,\rsubtitle = \u0026quot;Predictions alongside 95% and 80% bootstrap prediction interval\u0026quot;,\rx = NULL,\ry = NULL)\rAs this example shows, {workboots} can approximate linear prediction intervals pretty well! But this isn’t very useful, since we can just generate a linear prediction interval from a linear model directly. The real benefit of {workboots} comes from generating prediction intervals from any model!\n\rBootstrap prediction intervals with non-linear models\rXGBoost is one of my favorite models. Up until now, however, in situations that require a prediction interval, I’ve had to opt for a simpler model. With {workboots}, that’s no longer an issue! In this example, we’ll use XGBoost and {workboots} to generate predictions of a penguins weight from the Palmer Penguins dataset.\nTo get started, let’s build a workflow and train an individual model.\n# load and prep data\rdata(\u0026quot;penguins\u0026quot;)\rpenguins \u0026lt;-\rpenguins %\u0026gt;%\rdrop_na()\r# split data into training and testing sets\rset.seed(123)\rpenguins_split \u0026lt;- initial_split(penguins)\rpenguins_test \u0026lt;- testing(penguins_split)\rpenguins_train \u0026lt;- training(penguins_split)\r# create a workflow\rpenguins_wf \u0026lt;-\rworkflow() %\u0026gt;%\r# add preprocessing steps\radd_recipe(\rrecipe(body_mass_g ~ ., data = penguins_train) %\u0026gt;%\rstep_dummy(all_nominal_predictors()) ) %\u0026gt;%\r# add xgboost model spec\radd_model(\rboost_tree(\u0026quot;regression\u0026quot;)\r)\r# fit to training data \u0026amp; predict on test data\rset.seed(234)\rpenguins_preds \u0026lt;-\rpenguins_wf %\u0026gt;%\rfit(penguins_train) %\u0026gt;%\rpredict(penguins_test)\rAs mentioned above, XGBoost models can only generate point predictions.\npenguins_preds %\u0026gt;%\rbind_cols(penguins_test) %\u0026gt;%\rggplot(aes(x = body_mass_g,\ry = .pred)) +\rgeom_point() +\rgeom_abline(linetype = \u0026quot;dashed\u0026quot;,\rcolor = \u0026quot;gray\u0026quot;) +\rlabs(title = \u0026quot;XGBoost Model of Penguin Weight\u0026quot;,\rsubtitle = \u0026quot;Individual model can only output individual predictions\u0026quot;)\rWith {workboots}, however, we can generate a prediction interval from our XGBoost model for each penguin’s weight!\n# create 2000 models from bootstrap resamples and make predictions on the test set\rset.seed(345)\rpenguins_preds_boot \u0026lt;-\rpenguins_wf %\u0026gt;%\rpredict_boots(\rn = 2000,\rtraining_data = penguins_train,\rnew_data = penguins_test\r)\rpenguins_preds_boot %\u0026gt;%\rsummarise_predictions()\r## # A tibble: 84 x 5\r## rowid .preds .pred_lower .pred .pred_upper\r## \u0026lt;int\u0026gt; \u0026lt;list\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 \u0026lt;tibble [2,000 x 2]\u0026gt; 2788. 3470. 4136.\r## 2 2 \u0026lt;tibble [2,000 x 2]\u0026gt; 2838. 3534. 4231.\r## 3 3 \u0026lt;tibble [2,000 x 2]\u0026gt; 2942. 3598. 4301.\r## 4 4 \u0026lt;tibble [2,000 x 2]\u0026gt; 3354. 4158. 4889.\r## 5 5 \u0026lt;tibble [2,000 x 2]\u0026gt; 3186. 3870. 4500.\r## 6 6 \u0026lt;tibble [2,000 x 2]\u0026gt; 2884. 3519. 4208.\r## 7 7 \u0026lt;tibble [2,000 x 2]\u0026gt; 2790. 3434. 4094.\r## 8 8 \u0026lt;tibble [2,000 x 2]\u0026gt; 3394. 4071. 4772.\r## 9 9 \u0026lt;tibble [2,000 x 2]\u0026gt; 2812. 3447. 4096.\r## 10 10 \u0026lt;tibble [2,000 x 2]\u0026gt; 2744. 3404. 4063.\r## # ... with 74 more rows\rHow does our bootstrap model perform?\npenguins_preds_boot %\u0026gt;%\rsummarise_predictions() %\u0026gt;%\rbind_cols(penguins_test) %\u0026gt;%\rggplot(aes(x = body_mass_g,\ry = .pred,\rymin = .pred_lower,\rymax = .pred_upper)) +\rgeom_abline(linetype = \u0026quot;dashed\u0026quot;,\rcolor = \u0026quot;gray\u0026quot;) +\rgeom_errorbar(alpha = 0.5,\rcolor = \u0026quot;blue\u0026quot;) +\rgeom_point(alpha = 0.5,\rcolor = \u0026quot;blue\u0026quot;) +\rlabs(title = \u0026quot;XGBoost Model of Penguin Weight\u0026quot;,\rsubtitle = \u0026quot;Bootstrap models can generate prediction intervals\u0026quot;)\rThis particular model may be in need of some tuning for better performance, but the important takeaway is that we were able to generate a prediction distribution for the model! This method works with other regression models as well — just create a workflow then let {workboots} take care of the rest!\n\rTidymodel Resources\r\rGetting Started with Tidymodels\rTidy Modeling with R\rJulia Silge’s Blog provides use cases of tidymodels with weekly #tidytuesday datasets.\r\r\r","date":1647216000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1647291736,"objectID":"c8cfaa21779e3cdfd09aa38d2dd5b2b2","permalink":"https://www.thedatadiary.net/blog/2022-03-14-introducing-workboots/","publishdate":"2022-03-14T00:00:00Z","relpermalink":"/blog/2022-03-14-introducing-workboots/","section":"blog","summary":"Sometimes, we want a model that generates a range of possible outcomes around each prediction and may opt for a model that can generate a prediction interval, like a linear model.","tags":[],"title":"Introducing {workboots}","type":"blog"},{"authors":[],"categories":["rstats"],"content":"\r\rI’ve never built a house (shocking, I know), but from far too much time spent watching HGTV, I understand the basic gist of it. You lay a foundation, setup framing and walls, route mechanical and electrical, then work on final touches like painting and decorating (to be sure, I’m hand-waiving a lot of detail away here). There’s a bit of wiggle room in the order you go about things — you can paint the living room walls before the ones in the bathroom or vice versa — but some steps definitely need to happen before others — you can’t paint either rooms until the walls themselves are actually up!\nThe same logic applies for data science — there are certain activities that are exceptionally hard to do without the proper infrastructure in place. Sometimes, we’re asked to chase after ~shiny objects~ without the support system to do so, when doing so may actually make our job more difficult in the future!\nI recently stumbled across an article that summarized this really succinctly with the following graphic: The Data Science Hierarchy of Needs.\nCollect\rAt a baseline, to do any sort of data work you need to actually have data on hand to work with! Whether there’s a formal process for collecting data or you need to gather data from disparate public sources, getting raw data out of the wild and into your system is the first step to being able to do any sort of analysis. In my case, as an analyst with a hospital’s patient satisfaction group, we need to actually send patients surveys.\n\rMove/Store\rOnce you know where your data is coming from, setting up a reliable data flow from the source to your environment is needed. This is where a lot of headache can come from. Gathering data can be difficult but if the data is going to be used once for a one-off analysis, you don’t need to worry too much about repeatability, edge cases, or computing speed. Once you need to gather new data, thinking about infrastructure around new data gathering becomes much more important. A good chunk of the last eight months of my job has been working with our new survey vendor on this piece of the puzzle: standardizing data layouts, catching bugs in the pipeline, and setting up standards for access.\n\rExplore/Transform\rWith a reliable flow of new/updated data streaming in, you now need to make sure the data is appropriate for general use. Automated anomaly/fraud/bot detection, light wrangling, and removing errant responses can all be considered a part of this single stage. This is necessary to ensure that any analyses you do or models you build are based on what you expect from the underlying data.\n\rAggregate/Label\rI can’t recall the source, but the following quote about data science has stuck with me: “99% of data science work is counting — sometimes dividing.” A significant portion of my day-to-day work involves the tried-and-trusted group_by() %\u0026gt;% summarise() pipeline. Making counts, percentages, running totals, etc. accessible to stakeholders via a dashboard can likely answer ~80% of the questions an analyst would have to field otherwise. It’s so, so important, however, to have the collection, storage, and preparation stages setup prior to ensure that stakeholders can trust that the data they’re seeing is accurate.\n\rLearn/Optimize\rIf 80% of questions asked can be solved with grouped summaries and 20% require a model, it’s likely that 80% of that remaining 20% can be solved by a simple linear model. For example, “What effect does patient age have on their overall satisfaction?” can be answered with lm(satisfaction_score ~ age). As relationships become more complex, you can add more terms to the model, or switch model architectures, but — in my own experience — the majority of modeling in practice can be represented by linear models (and, by extension, regularized models via {glmnet}).\n\rComplex Models\rFinally, a small subset of problems may require a more complex or powerful model type. But before you spin your wheels building a neural net or some other wacky architecture, you should first check if something simpler gets you what you need.\n\rSome Closing Thoughts\rThis post is partially meant to be able to share some useful info and partially a reminder to me to look for the simple solution! I have a tendency to start off with something complex then realize that I could save a lot of work if I just switch to something simpler. The three baseline layers upstream of my domain are super important and definitely need oversight from someone with an eye for data engineering.\n\rPolling Bites\rThe generic congressional ballot is starting to show some movement away from even split as Republicans have slowly climbed to 51.2% in the polls and Democrats have fallen to 48.8%.\nBiden’s net approval hasn’t shifted significantly since the last post — currently sitting at 10.9% underwater with 41.8% approval and 52.7% disapproval.\n(p.s., I’ve updated the color palettes here with the {MetBrewer} package, which provides colorblind friendly palettes based on artwork in hte Metropolitan Museum of Art in New York).\n\r","date":1645488000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1645584987,"objectID":"ec9ca9ed9342c4de69bd8eae2a83c234","permalink":"https://www.thedatadiary.net/blog/2022-02-22-the-data-science-hierarchy-of-needs/","publishdate":"2022-02-22T00:00:00Z","relpermalink":"/blog/2022-02-22-the-data-science-hierarchy-of-needs/","section":"blog","summary":"I’ve never built a house (shocking, I know), but from far too much time spent watching HGTV, I understand the basic gist of it. You lay a foundation, setup framing and walls, route mechanical and electrical, then work on final touches like painting and decorating (to be sure, I’m hand-waiving a lot of detail away here).","tags":[],"title":"The Data Science Hierarchy of Needs","type":"blog"},{"authors":[],"categories":["rstats","tidymodels"],"content":"\r\rNote (3/14/22): This article was written prior to the release of the {workboots} package. Since the release of that package, I’ve discovered some errors with the methodology described here and would recommend instead referencing the post associated with the release.\nStatistical modeling sometimes presents conflicting goals. Oftentimes, building a model involves a mix of objectives that don’t necessarily mesh well together: super-accurate point predictions, explainability, fast performance, or an expression of confidence in the prediction. In my work as an analyst, I generally am focused on how explainable the model is while being able to express a confidence interval around each prediction. For that, simple linear models do the trick. If, however, I want to regularize via {glmnet} (which — with good reason — doesn’t provide confidence intervals) or use a non-linear model like {xgboost}, I have to drop the confidence interval around predictions. Or so I had previously thought! As it turns out, building a series of models from bootstrap resamples provides an alternative method of generating a confidence interval around a prediction.\nSetting a baseline with penguins\rFirst, let’s build out a baseline linear model with the Palmer Penguins dataset. This dataset contains information on 344 penguins across three species types and three islands. For this example, we’ll use the penguin information to predict body_mass_g.\n# load the data in from the tidytuesdayR package\rpenguins_src \u0026lt;- tidytuesdayR::tt_load(2020, week = 31)\r## ## Downloading file 1 of 2: `penguins.csv`\r## Downloading file 2 of 2: `penguins_raw.csv`\r# extract out the penguins dataset\rpenguins \u0026lt;- penguins_src$penguins\rrm(penguins_src)\rpenguins\r## # A tibble: 344 x 8\r## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Adelie Torgersen 39.1 18.7 181 3750\r## 2 Adelie Torgersen 39.5 17.4 186 3800\r## 3 Adelie Torgersen 40.3 18 195 3250\r## 4 Adelie Torgersen NA NA NA NA\r## 5 Adelie Torgersen 36.7 19.3 193 3450\r## 6 Adelie Torgersen 39.3 20.6 190 3650\r## 7 Adelie Torgersen 38.9 17.8 181 3625\r## 8 Adelie Torgersen 39.2 19.6 195 4675\r## 9 Adelie Torgersen 34.1 18.1 193 3475\r## 10 Adelie Torgersen 42 20.2 190 4250\r## # ... with 334 more rows, and 2 more variables: sex \u0026lt;chr\u0026gt;, year \u0026lt;dbl\u0026gt;\rWe’ll need to do some lite preprocessing before we start modeling — it looks like there are some NAs in body_mass_g and in sex. If I were creating a more serious model, I might keep the rows with NAs for sex, but since there are so few and this is an explainer, I’ll just filter them out.\n# remove NA from body_mass_g and sex\rpenguins \u0026lt;- penguins %\u0026gt;%\rfilter(!is.na(body_mass_g),\r!is.na(sex))\rpenguins\r## # A tibble: 333 x 8\r## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Adelie Torgersen 39.1 18.7 181 3750\r## 2 Adelie Torgersen 39.5 17.4 186 3800\r## 3 Adelie Torgersen 40.3 18 195 3250\r## 4 Adelie Torgersen 36.7 19.3 193 3450\r## 5 Adelie Torgersen 39.3 20.6 190 3650\r## 6 Adelie Torgersen 38.9 17.8 181 3625\r## 7 Adelie Torgersen 39.2 19.6 195 4675\r## 8 Adelie Torgersen 41.1 17.6 182 3200\r## 9 Adelie Torgersen 38.6 21.2 191 3800\r## 10 Adelie Torgersen 34.6 21.1 198 4400\r## # ... with 323 more rows, and 2 more variables: sex \u0026lt;chr\u0026gt;, year \u0026lt;dbl\u0026gt;\rIt’s always good practice to explore the dataset prior to fitting a model, so let’s jump into some good ol’ fashioned EDA.\n# how are species/island related to body mass?\rpenguins %\u0026gt;%\rggplot(aes(x = species,\ry = body_mass_g,\rcolor = species)) +\rgeom_boxplot() +\rgeom_point(alpha = 0.25,\rposition = position_jitter()) +\rfacet_wrap(~island)\rInteresting! It looks like the Gentoo and Chinstrap species are only found on the Biscoe and Dream islands, respectively, whereas the Adelie species can be found on all three islands. At first glance, there’s not a meaningful difference that Island has on the weight of the Adelie penguins, so I think we’re safe to toss out the island feature and just keep species.\n# how does sex relate to body mass?\rpenguins %\u0026gt;%\rggplot(aes(x = sex,\ry = body_mass_g,\rcolor = sex)) +\rgeom_boxplot() +\rgeom_point(alpha = 0.25,\rposition = position_jitter())\rUnsurprisingly, male penguins are typically heavier than female penguins.\n# are penguins getting heavier or lighter as years progress?\rpenguins %\u0026gt;%\rmutate(year = as.character(year)) %\u0026gt;%\rggplot(aes(x = year,\ry = body_mass_g)) +\rgeom_boxplot() +\rgeom_point(alpha = 0.25,\rposition = position_jitter())\rIt doesn’t look like there is significant signal being drawn from year, so we’ll toss that out as well.\n# how do other body measurements compare with the total body mass?\rpenguins %\u0026gt;%\rselect(bill_length_mm:body_mass_g) %\u0026gt;%\rpivot_longer(ends_with(\u0026quot;mm\u0026quot;),\rnames_to = \u0026quot;measurement\u0026quot;,\rvalues_to = \u0026quot;value\u0026quot;) %\u0026gt;%\rggplot(aes(x = value,\ry = body_mass_g,\rcolor = measurement)) +\rgeom_point(alpha = 0.5) + facet_wrap(~measurement, scales = \u0026quot;free_x\u0026quot;) +\rgeom_smooth(method = \u0026quot;lm\u0026quot;,\rse = FALSE)\rFor bill and flipper length, there’s a pretty clear relationship, but it looks like bill depth has a classic case of Simpson’s paradox. Let’s explore that further to find a meaningful interaction to apply.\n# which feature interacts with bill depth to produce simpson\u0026#39;s pardox?\rpenguins %\u0026gt;%\rggplot(aes(x = bill_depth_mm,\ry = body_mass_g,\rcolor = species)) +\rgeom_point(alpha = 0.5) +\rgeom_smooth(method = \u0026quot;lm\u0026quot;,\rse = FALSE)\rSo, very clearly, the Gentoo species has a very different relationship between bill depth and body mass than the Adelie/Chinstrap species. We’ll add this as an interactive feature to the model.\nWith all that completed, let’s (finally) setup and build the baseline linear model with confidence intervals around the prediction!\n# remove features\rpenguins \u0026lt;- penguins %\u0026gt;%\rselect(-island, -year)\r# split into testing and training datasets\rset.seed(123)\rpenguins_split \u0026lt;- initial_split(penguins)\rpenguins_test \u0026lt;- testing(penguins_split)\rpenguins_train \u0026lt;- training(penguins_split)\r# setup a pre-processing recipe\rpenguins_rec \u0026lt;- recipe(body_mass_g ~ ., data = penguins_train) %\u0026gt;%\rstep_dummy(all_nominal()) %\u0026gt;% step_interact(~starts_with(\u0026quot;species\u0026quot;):bill_depth_mm)\r# fit a workflow\rpenguins_lm \u0026lt;- workflow() %\u0026gt;%\radd_recipe(penguins_rec) %\u0026gt;%\radd_model(linear_reg() %\u0026gt;% set_engine(\u0026quot;lm\u0026quot;)) %\u0026gt;%\rfit(penguins_train)\r# predict on training data with confidence intervals\rbind_cols(penguins_lm %\u0026gt;% predict(penguins_train),\rpenguins_lm %\u0026gt;% predict(penguins_train, type = \u0026quot;conf_int\u0026quot;, level = 0.95),\rpenguins_train) %\u0026gt;%\rggplot(aes(x = body_mass_g,\ry = .pred)) +\rgeom_point(alpha = 0.5) +\rgeom_segment(aes(x = body_mass_g,\rxend = body_mass_g,\ry = .pred_lower,\ryend = .pred_upper),\ralpha = 0.25) +\rlabs(title = \u0026quot;Predicting the Palmer Penguins - Training\u0026quot;,\rsubtitle = \u0026quot;Linear model predicting a penguin\u0026#39;s weight in grams\u0026quot;,\rx = \u0026quot;Actual weight (g)\u0026quot;,\ry = \u0026quot;Predicted weight (g)\u0026quot;,\rcaption = \u0026quot;Errorbars represent the a 95% confidence interval\u0026quot;) +\rtheme(plot.title.position = \u0026quot;plot\u0026quot;)\rThis model does generally okay, but the confidence interval around each prediction is pretty clearly too confident! Let’s solve this with bootstrapping.\n\rWhat’s a bootstrap?\rBefore progressing any further, it’s probably important to define what exactly a bootstrap is/what bootstrapping is. Bootstrapping is a resampling method that lets us take one dataset and turn it into many datasets. Bootstrapping accomplishes this by repeatedly pulling a random row from the source dataset and, importantly, bootstrapping allows for rows to be repeated! Let’s look at an example for a bit more clarity.\n\r\rrowid\rx1\rx2\r\r\r\r1\r0.8\r104\r\r2\r0.7\r102\r\r3\r0.9\r88\r\r4\r0.4\r124\r\r5\r0.3\r79\r\r\r\rLet’s say we want to make bootstrap resamples of this dataset. We’ll draw five random rows from the dataset and, sometimes, we’ll have the same row show up in our new bootstrapped dataset multiple times:\n\r\rrowid\rx1\rx2\r\r\r\r1\r0.8\r104\r\r3\r0.9\r88\r\r4\r0.4\r124\r\r4\r0.4\r124\r\r2\r0.7\r102\r\r\r\rAnother bootstrap dataset might look like this:\n\r\rrowid\rx1\rx2\r\r\r\r2\r0.7\r102\r\r3\r0.9\r88\r\r5\r0.3\r79\r\r3\r0.9\r88\r\r5\r0.3\r79\r\r\r\rBootstrap datasets allow us to create many datasets from the original dataset and evaluate models across these bootstraps. Models that are well informed will give similar outputs across each dataset, despite of the randomness within each dataset, whereas less confident models will have a wider variation across the bootstrapped datasets.\n\rGenerating some confident penguins\rLet’s say we want to use {xgboost} to predict penguin weight and we’ll use bootstrapping to generate a confidence interval. Firstly, we’ll create the bootstrap datasets from our training set.\npenguins_boot \u0026lt;- penguins_train %\u0026gt;% bootstraps()\rpenguins_boot\r## # Bootstrap sampling ## # A tibble: 25 x 2\r## splits id ## \u0026lt;list\u0026gt; \u0026lt;chr\u0026gt; ## 1 \u0026lt;split [249/92]\u0026gt; Bootstrap01\r## 2 \u0026lt;split [249/90]\u0026gt; Bootstrap02\r## 3 \u0026lt;split [249/91]\u0026gt; Bootstrap03\r## 4 \u0026lt;split [249/87]\u0026gt; Bootstrap04\r## 5 \u0026lt;split [249/98]\u0026gt; Bootstrap05\r## 6 \u0026lt;split [249/84]\u0026gt; Bootstrap06\r## 7 \u0026lt;split [249/91]\u0026gt; Bootstrap07\r## 8 \u0026lt;split [249/95]\u0026gt; Bootstrap08\r## 9 \u0026lt;split [249/94]\u0026gt; Bootstrap09\r## 10 \u0026lt;split [249/86]\u0026gt; Bootstrap10\r## # ... with 15 more rows\rBy default, the bootstraps() function will create 25 bootstrap datasets, but we could theoretically create as many as we want. Now that we have our bootstraps, let’s create a function that will fit a model to each of the bootstraps and save to disk. We’ll use the default parameters for our {xgboost} model.\n# define a basic xgboost model\rpenguins_xgb \u0026lt;-\rboost_tree() %\u0026gt;%\rset_mode(\u0026quot;regression\u0026quot;) %\u0026gt;%\rset_engine(\u0026quot;xgboost\u0026quot;)\r# function that will fit a model and save to a folder\rfit_bootstrap \u0026lt;- function(index) {\r# pull out individual bootstrap to fit\rxgb_boot \u0026lt;- penguins_boot$splits[[index]] %\u0026gt;% training()\r# fit to a workflow\rworkflow() %\u0026gt;%\radd_recipe(penguins_rec) %\u0026gt;%\radd_model(penguins_xgb) %\u0026gt;%\rfit(xgb_boot) %\u0026gt;%\rwrite_rds(paste0(\u0026quot;models/model_\u0026quot;, index, \u0026quot;.rds\u0026quot;))\r}\rThis function will create a new model for each bootstrap, so we’ll end up with 25 separate models. Let’s fit!\n# fit to 25 bootstrapped datasets\rfor (i in 1:25) {\rfit_bootstrap(i)\r}\rNow let’s define a function that will predict based on these 25 bootstrapped models, then predict on our training data.\npredict_bootstrap \u0026lt;- function(new_data, index){\rread_rds(paste0(\u0026quot;models/model_\u0026quot;, index, \u0026quot;.rds\u0026quot;)) %\u0026gt;%\rpredict(new_data) %\u0026gt;%\rrename(!!sym(paste0(\u0026quot;pred_\u0026quot;, index)) := .pred)\r}\r# predict!\rtraining_preds \u0026lt;- seq(1, 25) %\u0026gt;%\rmap_dfc(~predict_bootstrap(penguins_train, .x))\rtraining_preds\r## # A tibble: 249 x 25\r## pred_1 pred_2 pred_3 pred_4 pred_5 pred_6 pred_7 pred_8 pred_9 pred_10\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 5552. 5638. 5555. 5703. 5726. 5783. 5404. 5566. 5493. 5547.\r## 2 3470. 3340. 3334. 3350. 3311. 3303. 3315. 3421. 3692. 3436.\r## 3 5309. 5274. 5241. 5286. 5206. 5084. 5506. 5531. 5274. 5309.\r## 4 4160. 4013. 3988. 4111. 4075. 4073. 4284. 4050. 4033. 4033.\r## 5 4003. 3931. 4096. 3968. 4008. 3918. 3941. 4093. 3941. 3880.\r## 6 3967. 4039. 4095. 4047. 4021. 4055. 3980. 4115. 4067. 4084.\r## 7 4647. 4551. 4750. 4555. 4690. 4396. 4235. 4686. 4764. 4659.\r## 8 5240. 5288. 5291. 5276. 5308. 5508. 5570. 5375. 5340. 5268.\r## 9 4138. 4111. 4106. 4236. 4135. 4219. 4218. 4211. 4160. 4071.\r## 10 4728. 4723. 4715. 4823. 4765. 4727. 4836. 4777. 4765. 4633.\r## # ... with 239 more rows, and 15 more variables: pred_11 \u0026lt;dbl\u0026gt;, pred_12 \u0026lt;dbl\u0026gt;,\r## # pred_13 \u0026lt;dbl\u0026gt;, pred_14 \u0026lt;dbl\u0026gt;, pred_15 \u0026lt;dbl\u0026gt;, pred_16 \u0026lt;dbl\u0026gt;, pred_17 \u0026lt;dbl\u0026gt;,\r## # pred_18 \u0026lt;dbl\u0026gt;, pred_19 \u0026lt;dbl\u0026gt;, pred_20 \u0026lt;dbl\u0026gt;, pred_21 \u0026lt;dbl\u0026gt;, pred_22 \u0026lt;dbl\u0026gt;,\r## # pred_23 \u0026lt;dbl\u0026gt;, pred_24 \u0026lt;dbl\u0026gt;, pred_25 \u0026lt;dbl\u0026gt;\rNow we have a column of predictions for each model — we can summarise our point prediction for each row with the average across all models and set the confidence interval based on the standard deviation of the predictions.\ntraining_preds %\u0026gt;%\rbind_cols(penguins_train) %\u0026gt;%\rrowid_to_column() %\u0026gt;%\rpivot_longer(starts_with(\u0026quot;pred_\u0026quot;),\rnames_to = \u0026quot;model\u0026quot;,\rvalues_to = \u0026quot;.pred\u0026quot;) %\u0026gt;%\rgroup_by(rowid) %\u0026gt;%\rsummarise(body_mass_g = max(body_mass_g),\r.pred_mean = mean(.pred),\rstd_dev = sd(.pred)) %\u0026gt;%\rriekelib::normal_interval(.pred_mean, std_dev) %\u0026gt;%\rggplot(aes(x = body_mass_g,\ry = .pred_mean)) +\rgeom_point(alpha = 0.5) +\rgeom_segment(aes(x = body_mass_g, xend = body_mass_g,\ry = ci_lower,\ryend = ci_upper),\ralpha = 0.25) +\rlabs(title = \u0026quot;Predicting the Palmer Penguins - Training\u0026quot;,\rsubtitle = \u0026quot;XGBoost model predicting a penguin\u0026#39;s weight in grams\u0026quot;,\rx = \u0026quot;Actual weight (g)\u0026quot;,\ry = \u0026quot;Predicted weight (g)\u0026quot;,\rcaption = \u0026quot;Errorbars represent the a 95% confidence interval\u0026quot;) +\rtheme(plot.title.position = \u0026quot;plot\u0026quot;)\rAnd just like that, we’ve trained a series of models with {xgboost} that let us apply a confidence interval around a point prediction! Now that we’ve done so on the training set, let’s look at performance on the test set.\nseq(1, 25) %\u0026gt;%\rmap_dfc(~predict_bootstrap(penguins_test, .x)) %\u0026gt;%\rbind_cols(penguins_test) %\u0026gt;%\rrowid_to_column() %\u0026gt;%\rpivot_longer(starts_with(\u0026quot;pred_\u0026quot;),\rnames_to = \u0026quot;model\u0026quot;,\rvalues_to = \u0026quot;.pred\u0026quot;) %\u0026gt;%\rgroup_by(rowid) %\u0026gt;%\rsummarise(body_mass_g = max(body_mass_g),\r.pred_mean = mean(.pred),\rstd_dev = sd(.pred)) %\u0026gt;%\rriekelib::normal_interval(.pred_mean, std_dev) %\u0026gt;%\rggplot(aes(x = body_mass_g,\ry = .pred_mean)) +\rgeom_point(alpha = 0.5) +\rgeom_segment(aes(x = body_mass_g, xend = body_mass_g,\ry = ci_lower,\ryend = ci_upper),\ralpha = 0.25) +\rlabs(title = \u0026quot;Predicting the Palmer Penguins - Testing\u0026quot;,\rsubtitle = \u0026quot;XGBoost model predicting a penguin\u0026#39;s weight in grams\u0026quot;,\rx = \u0026quot;Actual weight (g)\u0026quot;,\ry = \u0026quot;Predicted weight (g)\u0026quot;,\rcaption = \u0026quot;Errorbars represent the a 95% confidence interval\u0026quot;) +\rtheme(plot.title.position = \u0026quot;plot\u0026quot;)\rThe performance on the test data is slightly less accurate than on the training data, but that is to be expected. Importantly, we’ve used bootstrap resampling to generate a confidence interval from a model that otherwise normally returns a simple point prediction.\n\rSome noteworthy caveats\rThe prediction interval above is all well and good, but it comes with some hefty caveats. Firstly, the confidence interval in the Testing plot is generated from the mean and standard deviation from each prediction. This assumes that the predictions are distributed normally, which may not necessarily be the case.\ntraining_preds %\u0026gt;%\rslice_head(n = 1) %\u0026gt;%\rpivot_longer(starts_with(\u0026quot;pred\u0026quot;)) %\u0026gt;%\rggplot(aes(x = value)) +\rgeom_density()\rThis density plot for one of the predictions shows that there’s definitely some non-normal behavior! There’s a few ways of addressing this.\nCreate many, many, more bootstraps and models so that the prediction distribution approaches normality (with only 25 points, we really shouldn’t even expect normality from this example).\rReport out the actual values of the percentiles in the distribution (e.g., the 2.5% percentile is below X, 97.5% is above Y, and the mean is at Z).\rReport out the actual distribution as the result.\r\rIdeally, you should do all three.\nThe second major caveat is that this is not one model, but a whole host of models and these take up a large amount of disk space. In this example, our 25 models take up 25 times more space than our original model and it takes some time to read in, fit, and wrangle the results. We can trade disk space for computation time by writing a function that fits and predicts without saving a model, but again, that’s a tradeoff between speed and space. For linear models, it may be a better route to have STAN simulate thousands of results via {rstanarm} or {brms}, but for non-linear models, boostrapping is the best way to go for now!\n\rPolling Bites\rCurrently, the Generic Ballot is holding steady with a slight sliver more Americans wanting Republicans in Congress than Democrats (50.7% to 49.3%, respectively). Joe Biden’s net approval continues to slide, currently sitting at -11.4% (41.8% approve, 53.1% disapprove).\n\r","date":1644278400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1644329727,"objectID":"c4a1aa65168bffdca2163e8a6db9067b","permalink":"https://www.thedatadiary.net/blog/2022-02-08-pull-yourself-up-by-your-bootstraps/","publishdate":"2022-02-08T00:00:00Z","relpermalink":"/blog/2022-02-08-pull-yourself-up-by-your-bootstraps/","section":"blog","summary":"Note (3/14/22): This article was written prior to the release of the {workboots} package. Since the release of that package, I’ve discovered some errors with the methodology described here and would recommend instead referencing the post associated with the release.","tags":[],"title":"Pull Yourself Up by Your Bootstraps","type":"blog"},{"authors":[],"categories":["politics"],"content":"\r\rWhile the sitting president’s party tends to House lose seats in the midterm elections, the president’s approval rating can help inform us of the magnitude of that loss. In general, the more unpopular the president, the more seats his party tends to lose. As a part of my long-term goal of building a midterm election model, I put together a model for estimating Biden’s approval, disapproval, and net approval based on polls collected by FiveThirtyEight.\nThe methodology to build the approval model is very similar to the Generic Congressional Ballot model — both weight polls by recency, sample size, methodology, pollster, and survey population — so I won’t rehash the details again. If you’re so inclined, you can read the methodology from the previous post or explore the script, but we’ll keep this short and sweet and just explore the results!\nAs of today, Joe Biden’s job approval is fairly underwater — and history says it’s unlikely to improve as the midterms approach. Interestingly, the generic congressional ballot still shows that the country is about even-split on who they’d like to see in congress. As with the president’s approval, however, historical precedent implies a continuous slide away from the president’s party.\nDespite this precedent, politics today are far more polarized than previous midterm cycles, and modeling that adjusts for this partisanship may imply a lesser midterm shellacking than history would otherwise suggest. While Biden would certainly prefer for his approval to be higher, it may not necessarily spell doom for democrats in the midterms (though, to be sure, the strong prior still that they will lose ground this cycle — the question now is how much).\n","date":1643155200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1643219482,"objectID":"cbc40838949cfae2e7903b399407e6e4","permalink":"https://www.thedatadiary.net/blog/2022-01-26-how-popular-is-joe-biden/","publishdate":"2022-01-26T00:00:00Z","relpermalink":"/blog/2022-01-26-how-popular-is-joe-biden/","section":"blog","summary":"While the sitting president’s party tends to House lose seats in the midterm elections, the president’s approval rating can help inform us of the magnitude of that loss. In general, the more unpopular the president, the more seats his party tends to lose.","tags":[],"title":"How Popular is Joe Biden?","type":"blog"},{"authors":[],"categories":["personal"],"content":"\r\rIn the year since I started this blog, there’s been a lot that’s happened: I learned to use R, picked up the basics of machine learning, and moved into a new job/industry. I spend a lot of time thinking about what’s coming down the pipeline and how much further I have to go on projects that I have planned, but it’s worthwhile every now and then to take a look back and see just how far I’ve come.\nSome accomplishments I’m proud of\rLearning R\rA year ago, I couldn’t write a lick of R code — I lived and breathed Excel, and was a bit afraid of the transition from a GUI to an IDE. Now, I’d consider myself pretty well-versed in the language and am so glad I made the switch. Having moved to R, I realized how restrictive Excel was — R (or any other analytics-focused programming language) allows for the freedom of expression needed for any sort of serious analysis. This talk by Hadley Wickham was instrumental in pushing me to pick up R and is well worth a watch if you have the time.\n   \rCompleting Stanford’s Machine Learning course\rWhen I started learning R, I was most interested in getting to the point where I’d be able to implement machine learning models (this specifically came from reading the documentation for The Economist’s POTUS model and wanting to understand what was going on under-the-hood). Stanford’s online Machine Learning course was a thorough, technical introduction to the basics of machine learning. It doesn’t cover every model type, but gives a great foundation for how to understand new models by requiring that you write the models yourself (this was very useful and practical, but you won’t catch me using MATLAB anytime soon!).\n\rCommitting to rOpenSci\rrOpenSci is a non-profit initiative committed to creating and maintaining a variety of open-source R packages. For work, I use one of their packages, the qualtRics package, almost daily for extracting survey responses from Qualtrics’ API. I added a small function, fetch_id(), that allows you to pull in survey responses based on the survey’s name, rather than looking up the miscellaneous string of numbers that constitute the survey_id. It’s a small helper function, but working on it taught me a lot about documentation, testing, package development, and contributing to open-source software.\nlibrary(dplyr)\rlibrary(qualtRics)\rall_surveys() %\u0026gt;% fetch_id(\u0026quot;Mark\u0026#39;s Example Survey\u0026quot;) %\u0026gt;%\rfetch_survey() %\u0026gt;%\rknitr::kable()\r## | | | 0%\r| |======================================================================| 100%\r\r\r\rStartDate\rEndDate\rStatus\rIPAddress\rProgress\rDuration (in seconds)\rFinished\rRecordedDate\rResponseId\rRecipientLastName\rRecipientFirstName\rRecipientEmail\rExternalReference\rLocationLatitude\rLocationLongitude\rDistributionChannel\rUserLanguage\rQ1\r\r\r\r2022-01-12 15:20:31\r2022-01-12 15:20:38\rSurvey Preview\rNA\r100\r7\rTRUE\r2022-01-12 15:20:40\rR_XFVjzAh4MalrLmF\rNA\rNA\rNA\rNA\r29.73351\r-95.5564\rpreview\rEN\rStrongly agree\r\r\r\r\rPutting together a developer package\rAt some point this past year, I found myself either re-writing the same chunks of code repeatedly or re-defining functions across every project. After a lengthy period of hesitation, I finally picked up the R Packages book by Hadley Wickham and Jenny Bryan and put together my own personal package, {riekelib}. It’s just a collection of small helper functions that I use regularly for both personal and professional projects, but it’s really helped speed up workflows, since I can just load the library rather than re-write code or functions! Here are a few examples:\nlibrary(riekelib)\r# beta_interval() gives lower \u0026amp; upper bounds of a beta distribution\u0026#39;s confidence interval tibble::tibble(alpha = c(85, 100),\rbeta = c(15, 500)) %\u0026gt;%\rbeta_interval(alpha, beta) %\u0026gt;%\rknitr::kable()\r\r\ralpha\rbeta\rci_lower\rci_upper\r\r\r\r85\r15\r0.7741265\r0.9126452\r\r100\r500\r0.1379480\r0.1974895\r\r\r\r# percent() returns the percentage each value or combination of values appear in a tibble\riris %\u0026gt;%\rtibble::as_tibble() %\u0026gt;%\rpercent(Species) %\u0026gt;%\rknitr::kable()\r\r\rSpecies\rpct\r\r\r\rsetosa\r0.3333333\r\rversicolor\r0.3333333\r\rvirginica\r0.3333333\r\r\r\r\r\rPlots across the year\rPossibly the most visually-engaging way to track growth throughout the past year is to look back on how different plots have evolved. Here’s a walkthrough of some choice plots that I’ve made throughout the year.\nBaby Steps\rThe first plot I ever created in R, made with base R’s plot() function, compares speed \u0026amp; distance from the cars dataset. There’s not really anything visually compelling here, but it gives the starting point.\n\rR, ggplot2, and plotly\rThis next plot shows my first attempt at creating a ggplot. I remember struggling a lot with this when trying to learn the ins and outs of putting together and formatting the plot, but that struggle was well worth it. I learned not only the basics of how to put together a plot with ggplot, but also, more importantly, how to search and troubleshoot issues. I also like that I was able to explore a topic visually with this plot: while the winner of the presidential election overperforms in the electoral college relative to the popular vote, republican candidates consistently have a slightly stronger electoral college overperformance due to small-state bias.\n\r(Kind of) Projecting the 2020 Election\rI started playing around with custom themes, and even setup my own theme elements so that I could reference them easily. This was the first time I broke away from the default theme for ggplot. Additionally, this was the first time I used any sort of statistical methods to make a projection. The projection itself is pretty bad/underconfident, but the methodology was sound.\n\rDoug Collins Saved Raphael Warnock’s Senate Bid\rOf all the posts I wrote in 2021, this may be the one I’m most proud of. Firstly, I learned a lot of new techniques needed to create maps and animations in R, but I also made a data-backed point: Raphael Warnock, one of the current Democratic senators from Georgia, likely won his election because Republican voters split their ticket between Kelly Loeffler and Doug Collins.\n\raRtwork!\rThis next one is just fun, but I used R to make some artwork! I liked it so much, that I ended up making this my site header.\n\rTidymodels and the Titanic\rI spent a lot of time this past year learning how to implement machine learning methods, but eventually got to the point where I feel confident building and troubleshooting models with the tidymodel framework. I had an “aha” moment when working on a classifier for everyone’s favorite dataset, the Titanic survival dataset, and everything finally clicked. The model wasn’t great, but being able to quickly build and iterate was game-changing.\n\rDiamonds are Forever: Feature Engineering with the Diamonds Dataset\rWith some machine learning under my belt, I spent some time practicing feature engineering with the diamonds dataset. From the variable importance plot, I found that some of the engineered features were among the most important for predicting a diamond’s price!\n\rDo Voters Want Democrats or Republicans in Congress?\rMost recently, I created a congressional ballot aggregator that weights polls by pollster, recency, sample size, and methodology. This was a huge effort to create a custom regression methodology, and I’m very happy with how it turned out! As of today, voters are just about even-split between Democrats and Republicans in the upcoming 2022 midterms.\n\r\rPlans for 2022\rI think I’ve come a long way in 2021 and I hope that in 2023, I can look back on 2022 and see a similar level of growth throughout the year. Here are a few things I plan on working on this year:\n\rWriting: I’ve spent a lot of time in 2021 working on technical skills, but haven’t really taken time to work on my writing. This will be an important focus for me in 2022, since technical information is useless if I’m not able to communicate it well.\rBringing ML projects to the office: In my current job, we’ve been spending the majority of the last six months focusing on troubleshooting the errors and getting over the speed-bumps involved with changing our primary survey vendor. We haven’t had the bandwidth to work on higher level/higher value projects, but should be able to do so in the upcoming year. Some projects I’m excited to work on this year include:\r\rVariable importance in predicting positive sentiment in surveys;\rPatient segmentation with k-means clustering;\rShiny App - “How confident am I?” - for educating our non-technical counterparts on confidence intervals vs. point estimates;\rUsing NLP for predicting positive sentiment from patient comments;\rTopic modeling from comments for easier comment segmentation.\r\rNatural Language Processing: As alluded to above, I’d like to work with text data for predictive analysis this year — there’s a lot of valuable insight that can be drawn from text data once I understand how to extract it!\rEnrolling in a Master’s of D.S. program: While I’ve been able to pick up a lot of knowledge from free/low-cost resources online (as well as spending countless hours on StackOverflow), I believe it’s time to further my formal education by pursuing a Master’s of Data Science part-time. Enrolling in a master’s program should help improve both my technical and non-technical skills, as well as formalize my transition from engineering to data science with a degree.\rForecasting the 2022 Midterms: A long-term goal since starting this blog was to learn how to and ultimately deploy a forecast model for the 2022 midterms. I believe I’m well on my way, and hope to be able to publish midterm forecast models for the House, Senate, and Gubernatorial races sometime in the summer this year.\r\rAll-in-all, I’ve got a lot on my plate for 2022, but I’m confident that I’ll be able to tackle the challenges that come my way this year! My schedule is in a good place — full but manageable. As a preview of the next post I have scheduled, here’s a model I built to estimate Biden’s approval:\n\r","date":1641945600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1641996995,"objectID":"c9a4fabd7c5bc89b496647db5ff2a1b3","permalink":"https://www.thedatadiary.net/blog/2022-01-12-the-data-diary-year-in-review/","publishdate":"2022-01-12T00:00:00Z","relpermalink":"/blog/2022-01-12-the-data-diary-year-in-review/","section":"blog","summary":"In the year since I started this blog, there’s been a lot that’s happened: I learned to use R, picked up the basics of machine learning, and moved into a new job/industry.","tags":[],"title":"The Data Diary: Year in Review","type":"blog"},{"authors":[],"categories":["politics"],"content":"\r\rThe 2022 midterms are still quite a ways away, however, in order to have a forecast ready in time, I need to start working on the model well in advance! One of the features I plan on using in the House Forecast is the generic congressional ballot average. Generic ballot polls ask respondents whether they intend to vote for either the Republican or Democratic candidate for the U.S. House of Representatives in their district. FiveThirtyEight provides a daily updating polling average, but in order to project beyond their current day’s average, I needed to build my own poll aggregator! Thankfully, they also are kind enough to provide the underlying polling data as well.\nIn this post, I’ll walk through the steps taken to build the generic ballot aggregator and explore the results.\nThe Gameplan\rFiveThirtyEight’s data only goes back for two election cycles, which doesn’t provide enough data to build a poll aggregator from scratch. However, because they also provide their historical trendline, I can build a poll aggregator that fits the polling results to their historical trend.\nIn addition to the topline result, each poll in FiveThirtyEight’s repository includes quite a bit of additional meta-information about the poll: the pollster, sample size, survey methodology, and recipient population. Some pollsters, methodologies, and populations tend to be more accurate than others, so I’d be remiss to not include these features in the polling model. To incorporate all of this information, each feature will be weighted according to how well it fits FiveThirtyEight’s historical average. I’m sweeping a lot of programmatic detail under the rug here, but in general, features that fit FiveThirtyEight’s trendline well will have a higher weight and features that don’t fit the trendline so well will have a lower weight. Finally, since we know that some pollsters tend to favor one party, we’ll also create a “pollster offset” feature to shift each poll slightly and account for this partisan lean.\nBefore digging any further, it may be beneficial to explore the polling repository a bit. Here’s a sample of the polling data used for the aggregator:\n\r\rcycle\rpollster\rsample_size\rpopulation\rmethodology\rend_date\rdem\rrep\r\r\r\r2018\rHarrisX\r3861\rlv\rOnline\r2011-02-18\r48.0\r42.0\r\r2018\rSurveyMonkey\r9532\ra\rOnline\r2010-07-18\r43.0\r42.0\r\r2020\rYouGov\r1200\rrv\rOnline\r2012-03-19\r47.0\r41.0\r\r2018\rIpsos\r731\rlv\rOnline\r2009-06-18\r49.9\r38.6\r\r2020\rHarrisX\r3000\rrv\rOnline\r2010-07-19\r43.0\r36.0\r\r2018\rIpsos\r2383\ra\rOnline\r2009-01-17\r36.8\r31.3\r\r2018\rIpsos\r663\rlv\rOnline\r2006-05-17\r38.7\r32.6\r\r2018\rMorning Consult\r1992\rrv\rOnline\r2005-05-18\r42.0\r35.0\r\r2018\rIpsos\r1689\rrv\rOnline\r2007-03-18\r41.4\r36.5\r\r2018\rIpsos\r1907\ra\rOnline\r2004-02-18\r38.0\r30.3\r\r\r\rThe following pollsters conducted enough polls to warrant their own category - all other pollsters will be lumped together under the banner of “Other Pollster:”\n\r\rpollster\rn\r\r\r\rIpsos\r1239\r\rHarrisX\r426\r\rMorning Consult\r305\r\rYouGov\r195\r\rUSC Dornsife\r71\r\rThe Winston Group\r44\r\rMcLaughlin \u0026amp; Associates\r34\r\rFirehouse Strategies/Øptimus\r32\r\rRasmussen Reports/Pulse Opinion Research\r30\r\rQuinnipiac University\r28\r\r\r\rHere is a bit of expanded detail on the survey population categories:\n\r\rpopulation\rpopulation_full\rn\r\r\r\rrv\rRegistered Voters\r1510\r\rlv\rLikely Voters\r619\r\ra\rAdults\r602\r\rv\rVoters\r2\r\r\r\rFinally, the top survey methodologies considered are shown below. Similar to pollsters, methodologies that are not used enough are lumped into an “Other Methodology” category:\n\r\rmethodology\rn\r\r\r\rOnline\r2425\r\rLive Phone\r194\r\rUnknown\r62\r\rIVR/Online\r44\r\r\r\rThe general plan of attack was to fit the polls to the trendline, measure the error, update the weights and offsets slightly, and repeat until the error is below an acceptable threshold. As time progresses, we make smaller and smaller updates to the weights and offsets we hone in on optimal values for minimizing error.\n\rExploring the Results\rFirst and foremost, I’m pleased to report that the model fit the historical data fairly well. The model’s trendline (in blue) reasonably matches FiveThirtyEight’s historical trendline (in red):\nAs expected, as the model trains the weights and offsets, the rmse continues to shrink, and levels off just after 150 training rounds:\nSome pollsters are better at fitting the trendline: YouGov polls end up with the highest weight in the model whereas Morning Consult polls are downweighted.\nWhat are the partisan leanings of each pollster? Each pollster offset is shown below - pollsters at the top are generally more conservative leaning pollsters near the bottom are generally more liberal leaning. Or rather, pollsters near the top fit the trend better when we adjust their results to favor democrats, and pollsters near the bottom fit better when adjusted in favor of republicans.\nSome pollsters have fairly significant offsets! It’s reassuring to note, however, that these pollsters are downweighted and don’t make up the majority of polls recorded. The five pollsters with the most number of generic ballot polls conducted tend to fall fairly close to 0-offset.\nAlthough live phone polling has become more and more difficult in recent years, it still ended up being the top-weighted method for the generic ballot poll.\nFinally, surveying a population of registered voters turned out to be best for matching polls to the trendline, whereas the “voters” population was filtered away entirely (though that may be because there were only two polls conducted with this population).\n\rFitting to New 2022 Data\rThis exploration of how the model fits to the training data is useful, but how well does this model fit to new data? As it turns out, fairly well! When fit to data it wasn’t trained on, the model’s trendline (in blue) closely follows the target trendline (in red).\nThis also gives us the ability to project beyond the current average! As we get further and further away from the current day, our confidence interval around the current average widens out.\nThis behavior looks great! One area of concern, however, is the area on the left - on days where we already have data, we’re way too confident in our estimate! On some days, the confidence interval only spans 0.5%, which simply isn’t realistic.\nTo deal with this, we’ll create a new feature, downweight, that we can train to widen our confidence interval to something more credible.\n\rOne More Round of Training\rSimilar to training the generic ballot average, we can train the downweight feature to match the model’s confidence interval to FiveThirtyEight’s confidence interval. The trained result isn’t a perfect fit, but this does give us a mathematically sound, consistent way to construct a more realistic confidence interval. Here’s how the model’s confidence interval compares to the training set:\nOn new data, the model similarly provides an okay-enough fit for our purposes. The model may find it difficult to recreate FiveThirtyEight’s confidence interval due to differences in model construction. According to FiveThirtyEight’s documentation on other polling averages, it looks like they use an ensemble of LOESS models, whereas I generate a single beta distribution. Without getting too far into the weeds, the stack of LOESS models results in a confidence interval that is less prone to quick growth.\n\rWrapping It All Up\rNow that we’ve defined a model, we can finally answer the question in the title: do voters want Democrats or Republicans in congress? According to this model, voters are as even split as you can get!\nEven if there was a leader in the polls, the generic ballot’s predictive power this far out from the house elections is, to a first approximation, effectively useless. As we get closer to the election day, however, the polling model will become more and more useful. Additionally, the methods I used to generate the polling average can be replicated (with slight modifications) for other polling averages that will feed into the model, so stay tuned for more!\n\rSome Programming Notes\rI’ve skipped over quite a bit of programming detail. If you’re so inclined, you can read through the script to build the model and generate plots. There’s a lot going on there, but I’d like to highlight a few packages that were instrumental for putting this together:\n\rdoParallel: I frequently use doParallel, which uses multiple cores running in parallel to speed up processes. Most of the time, loading doParallel is just done for convenience’s sake, but it was absolutely necessary for this project — even with parallel processing, each round of model training was lengthy.\rfurrr: the goal of furrr is to combine purrr’s family of mapping functions with future’s parallel processing capabilities. Replacing my purrr::map() functions with furrr::future_map() functions literally cut training time in half.\rshadowtext: shadowtext is a small, niche package that allows you to add colored borders to geom_text() objects in a ggplot. It’s not visible in today’s chart because there’s 100% overlap between democrats \u0026amp; republicans, but there’s a white border around the text in front of the trendline that just looks nice.\r\r\r","date":1639440000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1639538462,"objectID":"279f09609bd2e6fb7a11853b1bce5c30","permalink":"https://www.thedatadiary.net/blog/2021-12-14-do-voters-want-democrats-or-republicans-in-congress/","publishdate":"2021-12-14T00:00:00Z","relpermalink":"/blog/2021-12-14-do-voters-want-democrats-or-republicans-in-congress/","section":"blog","summary":"The 2022 midterms are still quite a ways away, however, in order to have a forecast ready in time, I need to start working on the model well in advance!","tags":[],"title":"Do Voters Want Democrats or Republicans in Congress?","type":"blog"},{"authors":[],"categories":["rstats"],"content":"\r\rHappy (belated) Thanksgiving! This year, my family drove down to Houston for the holiday \u0026amp; I hosted Thanksgiving for the first time. We played lots of games and ate well - my fridge is still stocked full of leftovers. Knowing we’d be busy with hosting, I planned ahead and scheduled a lighter post - this week, I thought I’d highlight some technical books that I’ve either referenced for modeling work, have been recommended to me, or I’ve heard about and would like to read:\n\rThe Elements of Statistical Learning is referenced as the Bible of Machine Learning by Josh Starmer and provides a robust and deeply technical foundation for a wide array of machine learning models. It’s considered a must-have among both machine learning theorists, who look for new model structures, and practitioners (like myself!).\rAn Introduction to Statistical Learning with Applications in R is a companion to The Elements of Statistical Learning. An Introduction to Statistical Learning arose as a broader and less technical treatment of the key topics discussed in The Elements of Statistical Learning. Each section also includes learning-lab lessons walking through the implementation of the statistical learning method from that chapter (Emil Hvitfeldt is also working on a companion site for completing the labs with tidymodels).\rTidy Modeling with R is a guide to using the tidymodel framework and has been an excellent reference in both personal and professional projects.\rText Mining with R: a Tidy Approach serves as an introduction to text mining and other methods for dealing with unstructured, non-rectangular data. In my current role as a Consumer Experience Analyst, I have to interact with unstructured data (in the form of patient comments) daily - this book, along with the tidytext package, have been incredibly useful for analyzing and visualizing text data.\rSupervised Machine Learning for Text Analysis in R picks up where Text Mining with R left off by exploring (as the title suggests) supervised machine learning methods with text data. While I haven’t done extensive text modeling, this is one area that I’d like to explore further in 2022.\rFeature Engineering and Selection: A Practical Approach for Predictive Models is a guidebook offering methods for feature engineering (transforming and creating new predictor variables to improve predictive model performance). While I’ve utilized some basic feature engineering in some of my work, I’m interested in adding more robust tools to my feature-engineering toolkit!\rIntroduction to Empirical Bayes is David Robinson’s book coalescing a series of blog posts on Bayesian estimation, credible intervals, A/B testing, mixed models, and a host of other methods, all through the example of baseball batting averages.\rBuild a Career in Data Science is, as the name suggests, a book about building a career in data science. I generally feel that most career-help books are too broad to be useful or offer non-novel information for those in the industry the book is written for. Given, however, that I don’t have an academic or professional background in the field and that I’d like to eventually move from analytics to data science, I’d like to add this to the collection to pick up on some best practices.\r\r","date":1638057600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1638117661,"objectID":"dc2e08879b03a324595fb1207c846486","permalink":"https://www.thedatadiary.net/blog/2021-11-28-technical-books/","publishdate":"2021-11-28T00:00:00Z","relpermalink":"/blog/2021-11-28-technical-books/","section":"blog","summary":"Happy (belated) Thanksgiving! This year, my family drove down to Houston for the holiday \u0026amp; I hosted Thanksgiving for the first time. We played lots of games and ate well - my fridge is still stocked full of leftovers.","tags":[],"title":"Technical Books!","type":"blog"},{"authors":[],"categories":["tidymodels"],"content":"\r\rAre y’all ready for some charts?? This week, I did a bit of machine learning practice with the diamonds dataset. This dataset is interesting and good for practice for a few reasons:\n\rthere are lots of observations (50,000+);\rit includes a mix of numeric and categorical variables;\rthere are some data oddities to deal with (log scales, interactions, non-linear relations)\r\rI’ll be doing a bit of feature engineering prior to fitting an tuning a linear model that predicts the each diamond’s price with the glmnet package. This will give a good end-to-end glimpse into the data exploration and model fitting process! Before we get into that, let’s load some packages and get a preview of the dataset.\nlibrary(tidyverse)\rlibrary(tidymodels)\rlibrary(vip)\rtheme_set(theme_minimal())\rdiamonds %\u0026gt;%\rslice_head(n = 10)\r## # A tibble: 10 x 10\r## carat cut color clarity depth table price x y z\r## \u0026lt;dbl\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;ord\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43\r## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31\r## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31\r## 4 0.29 Premium I VS2 62.4 58 334 4.2 4.23 2.63\r## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75\r## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48\r## 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47\r## 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53\r## 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49\r## 10 0.23 Very Good H VS1 59.4 61 338 4 4.05 2.39\rSince we’re predicting price, let’s look at its distribution first.\ndiamonds %\u0026gt;%\rggplot(aes(x = price)) +\rgeom_histogram()\rWe’re definitely gonna want to apply a transformation to the price when modeling - let’s look at the distribution on a log-10 scale.\ndiamonds %\u0026gt;%\rggplot(aes(x = price)) +\rgeom_histogram() +\rscale_x_log10()\rThat’s a lot more evenly distributed, if not perfect. That’s a fine starting point, so now we’ll look through the rest of the data.\ndiamonds %\u0026gt;%\rggplot(aes(x = carat)) +\rgeom_histogram()\rdiamonds %\u0026gt;%\rggplot(aes(x = cut,\ry = price)) +\rgeom_boxplot()\rdiamonds %\u0026gt;%\rcount(cut) %\u0026gt;%\rggplot(aes(x = cut,\ry = n)) +\rgeom_col()\rdiamonds %\u0026gt;%\rggplot(aes(x = color,\ry = price)) +\rgeom_boxplot()\rdiamonds %\u0026gt;%\rcount(color) %\u0026gt;%\rggplot(aes(x = color,\ry = n)) +\rgeom_col()\rdiamonds %\u0026gt;%\rggplot(aes(x = clarity,\ry = price)) +\rgeom_boxplot()\rdiamonds %\u0026gt;%\rcount(clarity) %\u0026gt;%\rggplot(aes(x = clarity,\ry = n)) +\rgeom_col()\rdiamonds %\u0026gt;%\rggplot(aes(x = depth)) +\rgeom_histogram()\rdiamonds %\u0026gt;%\rggplot(aes(x = table)) +\rgeom_histogram() \rdiamonds %\u0026gt;%\rggplot(aes(x = x)) +\rgeom_histogram()\rdiamonds %\u0026gt;%\rggplot(aes(x = y)) +\rgeom_histogram() \rdiamonds %\u0026gt;% ggplot(aes(x = z)) +\rgeom_histogram()\rIt looks like there may be a good opportunity to try out a few normalization and resampling techniques, but before we get into any of that, let’s build a baseline linear model.\n# splits\rdiamonds_split \u0026lt;- initial_split(diamonds)\rdiamonds_train \u0026lt;- training(diamonds_split)\rdiamonds_test \u0026lt;- testing(diamonds_split)\r# resamples (don\u0026#39;t want to use testing data!)\rdiamonds_folds \u0026lt;- vfold_cv(diamonds_train)\r# model spec\rmod01 \u0026lt;-\rlinear_reg() %\u0026gt;%\rset_engine(\u0026quot;lm\u0026quot;)\r# recipe\rrec01 \u0026lt;-\rrecipe(price ~ ., data = diamonds_train) %\u0026gt;%\rstep_dummy(all_nominal_predictors())\r# controls\rctrl_preds \u0026lt;- control_resamples(save_pred = TRUE)\r# create a wf\rwf01 \u0026lt;-\rworkflow() %\u0026gt;%\radd_model(mod01) %\u0026gt;%\radd_recipe(rec01)\r# parallel processing\rdoParallel::registerDoParallel()\r# fit\rrs01 \u0026lt;- fit_resamples(\rwf01,\rdiamonds_folds,\rcontrol = ctrl_preds\r)\r# metrics!\rcollect_metrics(rs01)\r## # A tibble: 2 x 6\r## .metric .estimator mean n std_err .config ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 rmse standard 1129. 10 10.2 Preprocessor1_Model1\r## 2 rsq standard 0.920 10 0.00160 Preprocessor1_Model1\rAnd right off the bat, we can see a fairly high value for rsq! However, rsq doesn’t tell the whole story, so we should check our predictions and residuals plots.\naugment(rs01) %\u0026gt;%\rggplot(aes(x = price,\ry = .pred)) +\rgeom_point(alpha = 0.01) +\rgeom_abline(linetype = \u0026quot;dashed\u0026quot;,\rsize = 0.1,\ralpha = 0.5)\rThis is definitely not what we want to see! It looks like there’s an odd curve/structure to the graph and we’re actually predicting quite a few negative values. The residuals plot doesn’t look too great either.\naugment(rs01) %\u0026gt;%\rggplot(aes(x = price,\ry = .resid)) +\rgeom_point(alpha = 0.01) +\rgeom_hline(yintercept = 0,\rlinetype = \u0026quot;dashed\u0026quot;,\ralpha = 0.5,\rsize = 0.1)\rWhat we’d like to see is a 0-correlation plot with errors normally distributed; what we’re seeing instead, however, is a ton of structure.\nThat being said, that’s okay! we expected this first pass to be pretty rough! And the price is clearly on a log-10 scale. To make apples-apples comparisons with models going forward, I’ll retrain this basic linear model to predict the log10(price). This’ll involve a bit of data re-manipulation!\n# log transform price\rdiamonds_model \u0026lt;-\rdiamonds %\u0026gt;%\rmutate(price = log10(price),\racross(cut:clarity, as.character))\r# bad practice copy + paste lol\r# splits\rset.seed(999)\rdiamonds_split \u0026lt;- initial_split(diamonds_model)\rdiamonds_train \u0026lt;- training(diamonds_split)\rdiamonds_test \u0026lt;- testing(diamonds_split)\r# resamples (don\u0026#39;t want to use testing data!)\rset.seed(888)\rdiamonds_folds \u0026lt;- vfold_cv(diamonds_train)\r# model spec\rmod01 \u0026lt;-\rlinear_reg() %\u0026gt;%\rset_engine(\u0026quot;lm\u0026quot;)\r# recipe\rrec01 \u0026lt;-\rrecipe(price ~ ., data = diamonds_train) %\u0026gt;%\rstep_dummy(all_nominal_predictors())\r# controls\rctrl_preds \u0026lt;- control_resamples(save_pred = TRUE)\r# create a wf\rwf01 \u0026lt;-\rworkflow() %\u0026gt;%\radd_model(mod01) %\u0026gt;%\radd_recipe(rec01)\r# parallel processing\rdoParallel::registerDoParallel()\r# fit\rset.seed(777)\rrs01 \u0026lt;- fit_resamples(\rwf01,\rdiamonds_folds,\rcontrol = ctrl_preds\r)\r# metrics!\rcollect_metrics(rs01)\r## # A tibble: 2 x 6\r## .metric .estimator mean n std_err .config ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 rmse standard 0.0793 10 0.00557 Preprocessor1_Model1\r## 2 rsq standard 0.966 10 0.00494 Preprocessor1_Model1\rAnd wow, that one transformation increased our rsq to 0.96! Again, that’s not the whole story, and we’re going to be evaluating models based on the rmse. Let’s look at how our prediction map has updated:\nrs01 %\u0026gt;%\raugment() %\u0026gt;%\rggplot(aes(x = price,\ry = .pred)) +\rgeom_point(alpha = 0.01) +\rgeom_abline(linetype = \u0026quot;dashed\u0026quot;,\rsize = 0.1,\ralpha = 0.5) \rNow that is a much better starting place to be at! Let’s look at our coefficients\nset.seed(666) # :thedevilisalive:\rwf01 %\u0026gt;%\rfit(diamonds_train) %\u0026gt;%\rpull_workflow_fit() %\u0026gt;%\rvip::vi() %\u0026gt;%\rmutate(Variable = fct_reorder(Variable, Importance)) %\u0026gt;%\rggplot(aes(x = Variable,\ry = Importance,\rfill = Sign)) +\rgeom_col() +\rcoord_flip() + theme(plot.title.position = \u0026quot;plot\u0026quot;) +\rlabs(x = NULL,\ry = NULL,\rtitle = \u0026quot;Diamonds are forever\u0026quot;,\rsubtitle = \u0026quot;Variable importance plot of a basic linear regression predicting diamond price\u0026quot;)\rAnother way of looking at it:\nset.seed(666)\rwf01 %\u0026gt;%\rfit(diamonds_train) %\u0026gt;%\rpull_workflow_fit() %\u0026gt;%\rvip::vi() %\u0026gt;%\rmutate(Importance = if_else(Sign == \u0026quot;NEG\u0026quot;, Importance * -1, Importance),\rVariable = fct_reorder(Variable, Importance)) %\u0026gt;%\rggplot(aes(x = Variable,\ry = Importance,\rfill = Sign)) +\rgeom_col() +\rcoord_flip() +\rlabs(title = \u0026quot;Diamonds are forever\u0026quot;,\rsubtitle = \u0026quot;Variable importance plot of a basic linear regression predicting diamond price\u0026quot;,\rx = NULL,\ry = NULL) +\rtheme(plot.title.position = \u0026quot;plot\u0026quot;)\rThis is a good, but definitely improvable, starting point. We can likely decrease our overall error with a bit of feature engineering and drop unimportant features by tuning a regularized model. There are some oddities in this initial model that will need to be improved upon; for one, we can definitively say that the carat feature ought to be positively associated with price\ndiamonds_train %\u0026gt;%\rggplot(aes(x = carat,\ry = price)) +\rgeom_point(alpha = 0.01) +\rlabs(title = \u0026quot;A clear positive (albeit nonlinear) relationship between `carat` and `price`\u0026quot;) +\rtheme(plot.title.position = \u0026quot;plot\u0026quot;)\rAnother few things that are interesting to note in this plot! It looks like there are clusterings of carat ratings around round-ish numbers. My hypothesis here is that carat ratings tend to get rounded up to the next size. There’s also a clear abscence of diamonds priced at $1,500 (~3.17 on the log10 scale). I suppose there is some industry-specific reason to avoid a diamond price of $,1500?\ndiamonds_train %\u0026gt;%\rggplot(aes(x = carat,\ry = price)) +\rgeom_point(alpha = 0.01) +\rlabs(title = \u0026quot;A clear positive (albeit nonlinear) relationship between `carat` and `price`\u0026quot;) +\rtheme(plot.title.position = \u0026quot;plot\u0026quot;) +\rgeom_hline(yintercept = log10(1500),\rlinetype = \u0026quot;dashed\u0026quot;,\rsize = 0.9,\ralpha = 0.5)\rHow to address all these things? With some feature engineering! Firstly, let’s add some recipe steps to balance classes \u0026amp; normalize continuous variables.\nBut before I get into that, I’ll save the resample metrics so that we can compare models!\nmetrics \u0026lt;- collect_metrics(rs01) %\u0026gt;% mutate(model = \u0026quot;model01\u0026quot;)\rmetrics\r## # A tibble: 2 x 7\r## .metric .estimator mean n std_err .config model ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 rmse standard 0.0793 10 0.00557 Preprocessor1_Model1 model01\r## 2 rsq standard 0.966 10 0.00494 Preprocessor1_Model1 model01\r# spec will be the same as model01\rmod02 \u0026lt;- mod01\r# recipe!\rrec02 \u0026lt;- recipe(price ~ ., data = diamonds_train) %\u0026gt;%\rstep_other(cut, color, clarity) %\u0026gt;% step_dummy(all_nominal_predictors(), -cut) %\u0026gt;%\r# use smote resampling to balance classes\rthemis::step_smote(cut) %\u0026gt;% # normalize continuous vars\rbestNormalize::step_best_normalize(carat, depth, table, x, y, z)\rLet’s bake our recipe to verify that everything looks up-to-snuff in the preprocessed dataset.\nbaked_rec02 \u0026lt;- rec02 %\u0026gt;%\rprep() %\u0026gt;%\rbake(new_data = NULL)\rbaked_rec02\r## # A tibble: 80,495 x 20\r## carat cut depth table x y z price color_E color_F\r## \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 -0.706 Premium 0.138 -0.760 -0.709 -0.738 -0.695 3.01 0 1\r## 2 0.356 Very Good 0.570 0.835 0.342 0.251 0.344 3.63 0 0\r## 3 0.214 Premium -0.308 0.835 0.293 0.263 0.166 3.58 0 0\r## 4 -1.08 other 1.04 -0.310 -1.30 -1.40 -0.995 2.70 0 0\r## 5 -0.641 Ideal -0.602 -0.760 -0.595 -0.560 -0.622 2.97 0 0\r## 6 -0.0759 Premium -0.602 0.494 -0.0349 -0.0460 -0.114 3.38 0 0\r## 7 -0.149 Premium -1.16 0.103 -0.0565 -0.0842 -0.246 3.44 1 0\r## 8 0.170 Very Good -0.371 0.494 0.178 0.313 0.130 3.56 0 1\r## 9 -0.736 Ideal -0.110 -0.760 -0.709 -0.738 -0.723 3.09 0 0\r## 10 0.782 Ideal -0.602 -0.310 0.819 0.846 0.732 4.02 0 0\r## # ... with 80,485 more rows, and 10 more variables: color_G \u0026lt;dbl\u0026gt;,\r## # color_H \u0026lt;dbl\u0026gt;, color_I \u0026lt;dbl\u0026gt;, color_J \u0026lt;dbl\u0026gt;, clarity_SI2 \u0026lt;dbl\u0026gt;,\r## # clarity_VS1 \u0026lt;dbl\u0026gt;, clarity_VS2 \u0026lt;dbl\u0026gt;, clarity_VVS1 \u0026lt;dbl\u0026gt;,\r## # clarity_VVS2 \u0026lt;dbl\u0026gt;, clarity_other \u0026lt;dbl\u0026gt;\rbaked_rec02 %\u0026gt;%\rcount(cut) %\u0026gt;%\rggplot(aes(x = cut,\ry = n)) +\rgeom_col()\rbaked_rec02 %\u0026gt;%\rggplot(aes(x = carat)) +\rgeom_histogram()\rbaked_rec02 %\u0026gt;%\rggplot(aes(x = depth)) +\rgeom_histogram()\rbaked_rec02 %\u0026gt;%\rggplot(aes(x = table)) +\rgeom_histogram()\rbaked_rec02 %\u0026gt;%\rggplot(aes(x = x)) +\rgeom_histogram()\rbaked_rec02 %\u0026gt;%\rggplot(aes(x = y)) +\rgeom_histogram() \rbaked_rec02 %\u0026gt;%\rggplot(aes(x = z)) +\rgeom_histogram()\rEverything looks alright with the exception of the table predictor. I wonder if there are a lot of repeated values in the table variable - that may be why we’re seeing a “chunky” histogram. Let’s check\nbaked_rec02 %\u0026gt;%\rcount(table) %\u0026gt;%\rarrange(desc(n))\r## # A tibble: 10,406 x 2\r## table n\r## \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt;\r## 1 0.103 12167\r## 2 -0.310 11408\r## 3 -0.760 11031\r## 4 0.494 9406\r## 5 -1.28 6726\r## 6 0.835 6165\r## 7 1.15 3810\r## 8 -1.85 2789\r## 9 1.42 2182\r## 10 1.64 972\r## # ... with 10,396 more rows\rOoh - okay yeah that’s definitely the issue! I’m not quite sure how to deal with it, so we’re just going to ignore for now! Let’s add a new model \u0026amp; see how it compares against the baseline transformed model.\nwf02 \u0026lt;-\rworkflow() %\u0026gt;%\radd_model(mod02) %\u0026gt;%\radd_recipe(rec02)\r# stop parallel to avoid error!\r# need to replace with PSOCK clusters\r# see github issue here: https://github.com/tidymodels/recipes/issues/847\rforeach::registerDoSEQ()\rset.seed(666) # spoopy\rrs02 \u0026lt;-\rfit_resamples(\rwf02,\rdiamonds_folds,\rcontrol = ctrl_preds\r)\rcollect_metrics(rs02)\r## # A tibble: 2 x 6\r## .metric .estimator mean n std_err .config ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 rmse standard 0.115 10 0.00143 Preprocessor1_Model1\r## 2 rsq standard 0.932 10 0.00161 Preprocessor1_Model1\rOof - that’s actually slightly worse than our baseline model!\nrs02 %\u0026gt;%\raugment() %\u0026gt;%\rggplot(aes(x = price,\ry = .pred)) +\rgeom_point(alpha = 0.01) +\rgeom_abline(linetype = \u0026quot;dashed\u0026quot;,\rsize = 0.1,\ralpha = 0.5) \rIt looks like we’ve introduced structure into the residual plot!\nrs02 %\u0026gt;%\raugment() %\u0026gt;%\rggplot(aes(x = price,\ry = .resid)) +\rgeom_point(alpha = 0.01) +\rgeom_hline(yintercept = 0,\rlinetype = \u0026quot;dashed\u0026quot;,\rsize = 0.1,\ralpha = 0.5)\rYeah that’s fairly wonky! I’m wondering if it’s due to the SMOTE upsampling method we introduced? To counteract, I’ll build \u0026amp; train new models after each set of recipe steps (e.g., resampling, normalizing, interactions) to buil up a better performing model one step at a time.\nmetrics \u0026lt;- metrics %\u0026gt;%\rbind_rows(collect_metrics(rs02) %\u0026gt;% mutate(model = \u0026quot;model02\u0026quot;))\r# same model spec\rmod03 \u0026lt;- mod02\r# rebuild rec+wf \u0026amp; retrain\rrec03 \u0026lt;- recipe(price ~ ., data = diamonds_train) %\u0026gt;%\rstep_other(cut, color, clarity) %\u0026gt;%\rstep_dummy(all_nominal_predictors(), -cut) %\u0026gt;%\rthemis::step_smote(cut)\rwf03 \u0026lt;- workflow() %\u0026gt;%\radd_model(mod03) %\u0026gt;%\radd_recipe(rec03)\r# do paralllel\rdoParallel::registerDoParallel()\r# refit!\rset.seed(123)\rrs03 \u0026lt;-\rfit_resamples(\rwf03,\rdiamonds_folds,\rcontrol = ctrl_preds\r)\rcollect_metrics(rs03)\r## # A tibble: 2 x 6\r## .metric .estimator mean n std_err .config ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 rmse standard 0.0918 10 0.00502 Preprocessor1_Model1\r## 2 rsq standard 0.956 10 0.00502 Preprocessor1_Model1\rInteresting! Improved relative to rs02, but still not as good as our first model! Let’s try using step_downsample() to balance classes \u0026amp; see how we fare.\n# cleanup some large-ish items eating up memory\rrm(mod01, mod02, rec01, rec02, wf01, wf02, rs01, rs02)\r# save metrics\rmetrics \u0026lt;- metrics %\u0026gt;%\rbind_rows(collect_metrics(rs03) %\u0026gt;% mutate(model = \u0026quot;model03\u0026quot;))\r# new mod\rmod04 \u0026lt;- mod03\r# new rec\rrec04 \u0026lt;-\rrecipe(price ~ ., data = diamonds_train) %\u0026gt;%\rstep_other(cut, color, clarity) %\u0026gt;%\rstep_dummy(all_nominal_predictors(), -cut) %\u0026gt;%\rthemis::step_downsample(cut)\rwf04 \u0026lt;-\rworkflow() %\u0026gt;%\radd_model(mod04) %\u0026gt;%\radd_recipe(rec04) set.seed(456) rs04 \u0026lt;-\rfit_resamples(\rwf04,\rdiamonds_folds,\rcontrol = ctrl_preds\r)\rcollect_metrics(rs04)\r## # A tibble: 2 x 6\r## .metric .estimator mean n std_err .config ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 rmse standard 0.116 10 0.0136 Preprocessor1_Model1\r## 2 rsq standard 0.927 10 0.0175 Preprocessor1_Model1\rWow - still a bit worse! I’ll try upsampling \u0026amp; if there is no improvement, we’ll move on without resampling!\nmetrics \u0026lt;-\rmetrics %\u0026gt;%\rbind_rows(collect_metrics(rs04) %\u0026gt;% mutate(model = \u0026quot;model04\u0026quot;))\rmod05 \u0026lt;- mod04\rrec05 \u0026lt;-\rrecipe(price ~ ., data = diamonds_train) %\u0026gt;%\rstep_other(cut, color, clarity) %\u0026gt;%\rstep_dummy(all_nominal_predictors(), -cut) %\u0026gt;%\rthemis::step_upsample(cut)\rwf05 \u0026lt;- workflow() %\u0026gt;%\radd_model(mod05) %\u0026gt;%\radd_recipe(rec05) set.seed(789)\rrs05 \u0026lt;-\rfit_resamples(\rwf05,\rdiamonds_folds,\rcontrol = ctrl_preds\r)\rcollect_metrics(rs05)\r## # A tibble: 2 x 6\r## .metric .estimator mean n std_err .config ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 rmse standard 0.101 10 0.00499 Preprocessor1_Model1\r## 2 rsq standard 0.947 10 0.00536 Preprocessor1_Model1\rOkay - resampling gets stricken off our list of recipe steps! Let’s look at how the models compare so far\nmetrics \u0026lt;-\rmetrics %\u0026gt;%\rbind_rows(collect_metrics(rs05) %\u0026gt;% mutate(model = \u0026quot;model05\u0026quot;))\rmetrics %\u0026gt;%\rggplot(aes(x = model)) +\rgeom_point(aes(y = mean)) +\rgeom_errorbar(aes(ymin = mean - std_err,\rymax = mean + std_err)) +\rfacet_wrap(~.metric, scales = \u0026quot;free_y\u0026quot;)\rThe first simple linear model was the best as measured by both metrics! Let’s see if we can improve with some normalization of the continuous vars.\nrm(mod03, mod04, rec03, rec04, rs03, rs04, wf03, wf04)\rmod06 \u0026lt;- mod05\rrec06 \u0026lt;-\rrecipe(price ~ ., data = diamonds_train) %\u0026gt;%\rstep_other(cut, color, clarity) %\u0026gt;%\rbestNormalize::step_best_normalize(all_numeric_predictors()) %\u0026gt;%\rstep_dummy(all_nominal_predictors())\rwf06 \u0026lt;-\rworkflow() %\u0026gt;%\radd_model(mod06) %\u0026gt;%\radd_recipe(rec06)\rforeach::registerDoSEQ()\rset.seed(101112)\rrs06 \u0026lt;-\rfit_resamples(\rwf06,\rdiamonds_folds,\rcontrol = ctrl_preds\r)\rcollect_metrics(rs06)\r## # A tibble: 2 x 6\r## .metric .estimator mean n std_err .config ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 rmse standard 0.127 10 0.00115 Preprocessor1_Model1\r## 2 rsq standard 0.916 10 0.00136 Preprocessor1_Model1\rWell - that was quite a bit for no improvement! I guess that normalizing the continuous vars in this case isn’t helping. Moving on to adding some interactions - first let’s explore potential interactions a bit.\nmetrics \u0026lt;-\rmetrics %\u0026gt;% bind_rows(collect_metrics(rs06) %\u0026gt;% mutate(model = \u0026quot;model06\u0026quot;))\rdiamonds_train %\u0026gt;%\rggplot(aes(x = carat,\ry = price,\rcolor = cut)) +\rgeom_point(alpha = 0.05) + geom_smooth(method = \u0026quot;lm\u0026quot;, se = FALSE)\rlibrary(splines)\rdiamonds_train %\u0026gt;%\rggplot(aes(x = carat,\ry = price,\rcolor = cut)) +\rgeom_point(alpha = 0.05) +\rgeom_smooth(method = lm,\rformula = y ~ ns(x, df = 5),\rse = FALSE) +\rfacet_wrap(~cut, scales = \u0026quot;free\u0026quot;)\r5 spline terms might not be sufficient here - capturing the lower bound well but really not doing well with the higher carat diamonds.\ndiamonds_train %\u0026gt;%\rggplot(aes(x = carat,\ry = price,\rcolor = cut)) +\rgeom_point(alpha = 0.05) +\rgeom_smooth(method = lm,\rformula = y ~ ns(x, df = 10),\rse = FALSE) +\rfacet_wrap(~cut, scales = \u0026quot;free\u0026quot;)\rHmmmm, 10 might be too many. It looks lie we’ll just lose a bit of confidence for the Premium \u0026amp; Very Good diamonds at higher carats. Relative to the total number, I’m not too concerned.\ndiamonds_train %\u0026gt;%\rggplot(aes(x = carat,\ry = price,\rcolor = cut)) +\rgeom_point(alpha = 0.05) +\rgeom_smooth(method = lm,\rformula = y ~ ns(x, df = 7),\rse = FALSE) +\rfacet_wrap(~cut, scales = \u0026quot;free\u0026quot;)\r7 terms feels like the best we’re going to do here - I think this is tuneable, but we’ll leave as is (now \u0026amp; in the final model).\nNext, we’ll look at creating interactions between the color and carat variables:\ndiamonds_train %\u0026gt;%\rggplot(aes(x = carat, y = price,\rcolor = color)) +\rgeom_point(alpha = 0.05) +\rgeom_smooth(method = lm, formula = y ~ ns(x, df = 15),\rse = FALSE) +\rfacet_wrap(~color)\rAdding interactive spline terms with df of 15 seems to add some useful information!\nWe have three shape parameters, x, y, and z - I wonder if creating a stand-in for volume by multiplying them all together will provide any useful information?\ndiamonds_train %\u0026gt;%\rmutate(volume_param = x * y * z) %\u0026gt;%\rggplot(aes(x = volume_param,\ry = price)) +\rgeom_point(alpha = 0.05)\rOoh, looks like we’re getting some good info here, but we may want to use log10 to scale this back.\ndiamonds_train %\u0026gt;%\rmutate(volume_param = log10(x * y * z)) %\u0026gt;%\rggplot(aes(x = volume_param, y = price)) +\rgeom_point(alpha = 0.05)\rLet’s see if this ought to interact with any other paramaters:\ndiamonds_train %\u0026gt;%\rmutate(volume_param = log10(x * y * z)) %\u0026gt;%\rggplot(aes(x = volume_param, y = price,\rcolor = cut)) +\rgeom_point(alpha = 0.05) +\rgeom_smooth(method = \u0026quot;lm\u0026quot;, se = FALSE)\rdiamonds_train %\u0026gt;%\rmutate(volume_param = log10(x * y * z)) %\u0026gt;%\rggplot(aes(x = volume_param, y = price,\rcolor = color)) +\rgeom_point(alpha = 0.05) +\rgeom_smooth(method = \u0026quot;lm\u0026quot;, se = FALSE)\rdiamonds_train %\u0026gt;%\rmutate(volume_param = log10(x * y * z)) %\u0026gt;%\rggplot(aes(x = volume_param, y = price,\rcolor = clarity)) +\rgeom_point(alpha = 0.05) +\rgeom_smooth(method = \u0026quot;lm\u0026quot;, se = FALSE)\rHmm, it doesn’t really look like we’re capturing too great of interactions, so I’ll leave out for now. It looks like the size of the rock is more important than anything else! I could continue to dig further, but I’ll stop there. I’m likely getting diminishing returns, \u0026amp; I’d like to get back into modeling!\nmod07 \u0026lt;- mod06\rrec07 \u0026lt;-\rrecipe(price ~ ., data = diamonds_train) %\u0026gt;%\rstep_other(cut, color, clarity) %\u0026gt;%\rstep_dummy(all_nominal_predictors()) %\u0026gt;%\rstep_interact(~carat:starts_with(\u0026quot;cut_\u0026quot;)) %\u0026gt;%\rstep_interact(~carat:starts_with(\u0026quot;color_\u0026quot;)) %\u0026gt;%\rstep_mutate_at(c(x, y, z),\rfn = ~if_else(.x == 0, mean(.x), .x)) %\u0026gt;%\rstep_mutate(volume_param = log10(x * y * z)) %\u0026gt;%\rstep_ns(starts_with(\u0026quot;carat_x_cut\u0026quot;), deg_free = 7) %\u0026gt;%\rstep_ns(starts_with(\u0026quot;carat_x_color\u0026quot;), deg_free = 15) rec07\r## Recipe\r## ## Inputs:\r## ## role #variables\r## outcome 1\r## predictor 9\r## ## Operations:\r## ## Collapsing factor levels for cut, color, clarity\r## Dummy variables from all_nominal_predictors()\r## Interactions with carat:starts_with(\u0026quot;cut_\u0026quot;)\r## Interactions with carat:starts_with(\u0026quot;color_\u0026quot;)\r## Variable mutation for c(x, y, z)\r## Variable mutation for log10(x * y * z)\r## Natural splines on starts_with(\u0026quot;carat_x_cut\u0026quot;)\r## Natural splines on starts_with(\u0026quot;carat_x_color\u0026quot;)\rwf07 \u0026lt;-\rworkflow() %\u0026gt;%\radd_model(mod07) %\u0026gt;%\radd_recipe(rec07)\rdoParallel::registerDoParallel()\rset.seed(9876)\rrs07 \u0026lt;-\rfit_resamples(\rwf07,\rdiamonds_folds,\rcontrol = ctrl_preds\r)\rThis is definitely going to way overfit our data:\nrs07 %\u0026gt;%\rcollect_metrics()\r## # A tibble: 2 x 6\r## .metric .estimator mean n std_err .config ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 rmse standard 0.0750 10 0.00377 Preprocessor1_Model1\r## 2 rsq standard 0.970 10 0.00342 Preprocessor1_Model1\rWell we (finally) made a modes improvement! Let’s see how the predictions/residuals plot:\nrs07 %\u0026gt;%\raugment() %\u0026gt;%\rggplot(aes(x = price,\ry = .pred)) +\rgeom_point(alpha = 0.05) +\rgeom_abline(linetype = \u0026quot;dashed\u0026quot;,\ralpha = 0.5,\rsize = 0.5)\rThat’s pretty good! We do have one value that’s way off, so let’s see if regulization can help. This will require setting a new baseline model, and we’ll tune our way to the best regularizaion parameters.\nmetrics \u0026lt;- rs07 %\u0026gt;%\rcollect_metrics() %\u0026gt;%\rmutate(model = \u0026quot;model07\u0026quot;) %\u0026gt;%\rbind_rows(metrics)\r# add normalization step\rrec08 \u0026lt;- rec07 %\u0026gt;% step_zv(all_numeric_predictors()) %\u0026gt;%\rstep_normalize(all_numeric_predictors(),\r-cut_Ideal, -cut_Premium, -cut_Very.Good, -cut_other,\r-color_E, -color_F, -color_G, -color_H, -color_I, -color_J,\r-clarity_SI2, -clarity_VS1, -clarity_VS2, -clarity_VVS1, -clarity_VVS2, -clarity_other)\rrm(mod05, mod06, mod07, rec05, rec06, rec07, wf05, wf06, wf07, rs05, rs06, rs07)\rmod08 \u0026lt;-\rlinear_reg(penalty = tune(), mixture = tune()) %\u0026gt;%\rset_engine(\u0026quot;glmnet\u0026quot;) %\u0026gt;%\rset_mode(\u0026quot;regression\u0026quot;) wf08 \u0026lt;-\rworkflow() %\u0026gt;%\radd_model(mod08) %\u0026gt;%\radd_recipe(rec08)\rdiamonds_grid \u0026lt;- grid_regular(penalty(), mixture(), levels = 20)\rdoParallel::registerDoParallel()\rset.seed(5831)\rrs08 \u0026lt;-\rtune_grid(\rwf08,\rresamples = diamonds_folds,\rcontrol = ctrl_preds,\rgrid = diamonds_grid\r)\rSome notes but let’s explore our results…\nrs08 %\u0026gt;%\rcollect_metrics() %\u0026gt;%\rggplot(aes(x = penalty,\ry = mean,\rcolor = as.character(mixture))) +\rgeom_point() +\rgeom_line(alpha = 0.75) +\rfacet_wrap(~.metric, scales = \u0026quot;free\u0026quot;) +\rscale_x_log10()\rLooks like we were performing pretty well with the unregularized model, oddly enough! Let’s select the best and finalize our workflow.\nbest_metrics \u0026lt;- rs08 %\u0026gt;%\rselect_best(\u0026quot;rmse\u0026quot;)\rwf_final \u0026lt;- finalize_workflow(wf08, best_metrics)\rrm(mod08, rec07, rec08, rs08, wf08)\rset.seed(333)\rfinal_fit \u0026lt;- wf_final %\u0026gt;%\rfit(diamonds_train)\rfinal_fit %\u0026gt;%\rpredict(diamonds_test) %\u0026gt;%\rbind_cols(diamonds_test) %\u0026gt;%\rselect(price, .pred) %\u0026gt;%\rggplot(aes(x = price, y = .pred)) +\rgeom_point(alpha = 0.05) + geom_abline(alpha = 0.5,\rlinetype = \u0026quot;dashed\u0026quot;,\rsize = 0.5)\rWhat are the most important variables in this regularized model?\nfinal_fit %\u0026gt;%\rpull_workflow_fit() %\u0026gt;%\rvi(lambda = best_metrics$penalty) %\u0026gt;%\rmutate(Variable = fct_reorder(Variable, Importance)) %\u0026gt;%\rggplot(aes(x = Variable,\ry = Importance, fill = Sign)) +\rgeom_col() +\rcoord_flip()\rAs expected, most of our terms get regularized away, which is what we want! Our chart is a little unreadable; let’s plot just the most important variables in a few ways:\nfinal_fit %\u0026gt;%\rpull_workflow_fit() %\u0026gt;%\rvi(lambda = best_metrics$penalty) %\u0026gt;%\rarrange(desc(Importance)) %\u0026gt;%\rslice_head(n = 10) %\u0026gt;%\rmutate(Variable = fct_reorder(Variable, Importance)) %\u0026gt;%\rggplot(aes(x = Variable,\ry = Importance,\rfill = Sign)) +\rgeom_col() +\rcoord_flip()\rfinal_fit %\u0026gt;%\rpull_workflow_fit() %\u0026gt;%\rvi(lambda = best_metrics$penalty) %\u0026gt;%\rarrange(desc(Importance)) %\u0026gt;% slice_head(n = 10) %\u0026gt;%\rmutate(Importance = if_else(Sign == \u0026quot;NEG\u0026quot;, -Importance, Importance),\rVariable = fct_reorder(Variable, Importance)) %\u0026gt;%\rggplot(aes(x = Variable,\ry = Importance,\rfill = Sign)) + geom_col() +\rcoord_flip()\rAnd look at that! Our most important variable was one that came from feature engineering! The size of the rock had the biggest impact on price.\nWe’ve gone through a lot of steps, so it may be good to look back on what was done:\n\rExplored our dataset via some simple exploratory data analysis;\rFit a simple linear model to predict the log-transform of price;\rAttempted (and failed) to improve upon the simple model with fancier normalization and resampling techniques;\rExplored the dataset further to find meaningful interactions and potential new features;\rFit a new model with feature engineering;\rTuned regularization parameters on our model with feature engineering to arrive at the final model.\r\rOur models’ performances, ranked from best to worst, show that the final tuned model did indeed perform the best on the test dataset!\nfinal_preds \u0026lt;-\rfinal_fit %\u0026gt;%\rpredict(diamonds_train) %\u0026gt;%\rbind_cols(diamonds_train) %\u0026gt;%\rselect(price, .pred)\rbind_rows(final_preds %\u0026gt;% rmse(price, .pred),\rfinal_preds %\u0026gt;% rsq(price, .pred)) %\u0026gt;%\rrename(mean = .estimate) %\u0026gt;%\rselect(-.estimator) %\u0026gt;%\rmutate(model = \u0026quot;model_final\u0026quot;) %\u0026gt;%\rbind_rows(metrics %\u0026gt;% select(.metric, mean, model)) %\u0026gt;%\rpivot_wider(names_from = .metric,\rvalues_from = mean) %\u0026gt;%\rmutate(model = fct_reorder(model, desc(rmse))) %\u0026gt;%\rpivot_longer(rmse:rsq,\rnames_to = \u0026quot;metric\u0026quot;,\rvalues_to = \u0026quot;value\u0026quot;) %\u0026gt;%\rggplot(aes(x = model,\ry = value)) +\rgeom_point() +\rfacet_wrap(~metric, scales = \u0026quot;free\u0026quot;) +\rcoord_flip()\r","date":1636848000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1636923006,"objectID":"b1f9f05f798d3e791ea31b6b6598aca5","permalink":"https://www.thedatadiary.net/blog/2021-11-14-diamonds-are-forever-feature-engineering-with-the-diamonds-dataset/","publishdate":"2021-11-14T00:00:00Z","relpermalink":"/blog/2021-11-14-diamonds-are-forever-feature-engineering-with-the-diamonds-dataset/","section":"blog","summary":"Are y’all ready for some charts?? This week, I did a bit of machine learning practice with the diamonds dataset. This dataset is interesting and good for practice for a few reasons:","tags":[],"title":"Diamonds are Forever: Feature Engineering with the Diamonds Dataset","type":"blog"},{"authors":[],"categories":["politics"],"content":"\rA few weeks ago I had written about the VA Governor’s race before going on vacation - in that time it seems as though Terry McAuliffe’s campaign had lost a lot of steam and Youngkin made up a lot of ground in the final weeks of the campaign. At the time of this writing, it seems overwhelmingly likely that Glenn Youngkin will become the next governor of Virginia. To avoid some of the galaxy-brain takes that will inevitabely wind up twitter, I thought I’d distract myself by following up on my previous post.\nFirstly, I should share the updated polling average. A few weeks ago, McAullife appeared to have a sizeable lead in the polls:\nFiveThirtyEight\u0026#39;s poll tracker for the VA governor race (https://t.co/HKVw7RcsJN) shows the moving averages - as a weekend coding project, I revamped with a weighted avg., 95% CI, and win probability based on an election day distribution📈 pic.twitter.com/hM6vzLUZnM\n\u0026mdash; Mark Rieke (@markjrieke) October 3, 2021  However, as of election day, the race had significantly tightened to effectively a coin-toss:\nFinal update - p_win ~ 55% McAuliffe; again, the win probability is just the portion of the polling avg. distribution above 50% for each candidate. For *actual* models, go check out the work by @lxeagle17/@Thorongil16 or @jhkersting, among others pic.twitter.com/W9bDf1OumZ\n\u0026mdash; Mark Rieke (@markjrieke) November 1, 2021  As I mention in the above tweet, the win probability isn’t a true forecast, just the portion of each candidate’s election day distribution above 50%. That being said, actual forecasts similarly had the race down to a near 50-50 split as of this morning:\nSpecial for Twitter: Updated VA polling trends with the new Fox and Post/GMU polls https://t.co/hLNa3pFCpR pic.twitter.com/6cz0JXa0xm\n\u0026mdash; G. Elliott Morris (@gelliottmorris) October 29, 2021  #FINAL Virginia Gov. Projection.@GlennYoungkin is ever so slightly favored in this tossup for the governorship.\nFull Projection\u0026gt;\u0026gt;https://t.co/PcM2qSjUYK pic.twitter.com/NGCirjkkG4\n\u0026mdash; Jack Kersting (@jhkersting) November 2, 2021  Even the model most confident in McAuliffe built by Lakshya Jain and Thorongil had dropped McAuliffe’s win probability from ~85% to 67% over the course of a few weeks:\n🚨FINAL #VAGov FORECAST🚨\nAt the end of a long campaign, here\u0026#39;s where the model made by me and @Thorongil16 stands. The race is rated as Lean Democratic, with a forecasted margin of D+3.6 and a win probability of 67%. An interactive map is over at https://t.co/Kmvj6sRElC. pic.twitter.com/kuaJc82HML\n\u0026mdash; Lakshya Jain (@lxeagle17) November 2, 2021  While I definitely plan on utilizing a more scientific poll-weighting methodology in the future, I do find it interesting that even a simple averaging method can produce relatively accurate results in line with the majority of other forecasters.\nRegarding post-hoc analysis of why McAuliffe lost, I won’t dredge up any of my own (partially because it’d be irresponsible \u0026amp; pundit-y to do so without referencing any data and partially because it’s getting late \u0026amp; I’m a bit tired), but I’ll point out a few tweets from Nate Cohn that show that the results appear to show a near uniform shift across precincts and different voting groups. This would suggest that McAuliffe’s loss is tied more closely to the national environment, rather than shifts amongst specific groups/counties.\nUpdate at nearly 1500 precincts: Youngkin is still on track for victory, running a ahead of what he needs across basically every dimension worth looking at.\nBut it\u0026#39;s worth noting just how close things are to \u0026#39;expectations,\u0026#39; which is simply shifting the 2020 result to the right pic.twitter.com/Mbe3pg7NFB\n\u0026mdash; Nate Cohn (@Nate_Cohn) November 3, 2021  And btw, if you\u0026#39;re doing pundit things I\u0026#39;d look at that red column. McAuliffe fell short of expectations--a more-or-less uniform shift--by basically the same amount, just about everywhere\n\u0026mdash; Nate Cohn (@Nate_Cohn) November 3, 2021  This won’t stop the networks from ascribing the win/loss to very specific campaign issues (I’ve already seen quite a few folks ascribe Youngkin’s win to education, race, suburban-reversion, etc., without any evidence to back up such claims). Until there are deep dives into data regarding the election, I’d treat any comments rom pundits with a hefty grain of salt.\nSome closing thoughts\rThat’s all for me today! I’ll be back in a few weeks with some non-political content, looking at a machine learning model predicting the price of a diamond in the diamonds dataset.\n\r","date":1635811200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635904280,"objectID":"b177f27bb330f30892f6f1f953aaf1cb","permalink":"https://www.thedatadiary.net/blog/2021-11-02-election-night-some-closing-thoughts-on-the-va-governor-race/","publishdate":"2021-11-02T00:00:00Z","relpermalink":"/blog/2021-11-02-election-night-some-closing-thoughts-on-the-va-governor-race/","section":"blog","summary":"A few weeks ago I had written about the VA Governor’s race before going on vacation - in that time it seems as though Terry McAuliffe’s campaign had lost a lot of steam and Youngkin made up a lot of ground in the final weeks of the campaign.","tags":[],"title":"Election Night: Some Closing Thoughts on the VA Governor Race","type":"blog"},{"authors":[],"categories":["politics"],"content":"\r\rRolling poll averages can be misleading in the absence of errorbars or an expected distribution of outcomes. FiveThirtyEight is currently tracking polls of Virginia’s Governor race slated for early November, and has kindly made their polls available to the public. Their current polling average, however, looks to be a simple rolling average and doesn’t include a confidence interval. I’ve attempted to improve upon their tracker here by providing a weighted polling average and a 95% confidence interval.\nHow this works\rSince we’re only considering the top candidates from each party, we’ll look at each candidate’s two-party voteshare of each poll. To get the two-party voteshare, third party or other minor candidates are removed from each poll and each candidate’s percentage is recalculated as if they were the only two options on the ballot (in practice, this only removes a tiny amount of undecideds and third party voters). Then, the daily polling average is calculated by weighting each poll by sample size and recency. Using Bayes’ theorem and a weak uniform prior, we can use the same method recalculate the polling average and confidence interval for each day between today and the election. Because polls are weighted by recency, as we look further and further into the future, our confidence in the polls decreases and the confidence interval around the polling average fans out. Each candidate’s probability of winning is the portion of the portion of the projected election-day polling distribution in their favor, based on that day’s polling average.\n\rSome caveats worth noting\rThis is an inherently flawed method, and it’s worth pointing out a few of the flaws and shortcuts I used:\nThe functions used to weight polls are nowhere near perfect.\rThe original weighting functions (which I haven’t changed) were chosen somewhat arbitrarily. In hindsight, they’re probably placing too much emphasis on recency and the error bars ought to be larger. While I have received some advice on tuning arbitrary functions as a part of a larger model, I haven’t implemented here. It’s more prudent to think of this as an over-confident polling aggregate, rather than any sort of model. For a true projection model, I’d recommend looking at Jack Kersting’s website.\n\rThe weighting method ignores important weighting factors\rThis weighting method is super simple and ignores common weighting factors, like pollster and survey methodology. Other less-common poll weighting methods, like accounting for partisan non-response bias and and how the pollster weights their results (notably, whether or not the pollster weights by education) were similarly ignored. There is definitely a strong argument for including these weighting factors, but for me, this exercise was more about learning to use purrr::map() and other related functions when writing the script for this plot.\n\rSome pollsters are filtered out by design\rI debated this for quite some time, but decided to add a filter to remove polls conducted by Rasmussen and Trafalgar. Trafalgar is excluded from any of the Economist’s polling databases for opaque yet clearly shoddy methodology and Rasmussen is clearly partisan. Removing these from the average follows the general consensus on ET (though, to be transparent, ET does tend to slant far to the left). In future polling projects, I’d hope to develop some more robust methodology to programatically downweight problematic pollsters (how’s that for a tongue twister?), but for now I’m just going to exclude.\n\r\rFinal thoughts on polling\rThis methodology certainly has its flaws, but it is transparent. I’ll continuously update this plot up until election day on my github.\n\rSome programming notes\rI’ve finished migrating my site to Netlify! I had originally planned to make the switch from Squarespace sometime early in 2022, but motivation struck me during a relatively light work week and I was able to rebuild the site using blogdown. This allows for a lot more customization and control than was available with Squarespace, but the biggest upside is definitely the ease of sharing in-line code, here’s a quick example:\nlibrary(tidyverse)\r# let\u0026#39;s put together a plot from the diamonds dataset\rdiamonds %\u0026gt;%\rggplot(aes(x = carat,\ry = price,\rcolor = cut)) +\rgeom_point(alpha = 0.1) +\rtheme_minimal() +\rviridis::scale_color_viridis(discrete = TRUE)\rThis ease of use and visibility will make things more seamless for me and allow me to dig into more technical content in more detail in the future!\nI’ll be taking a (much needed) vacation next week, spending some time off the grid in the Grand Canyon and surrounding area with my family. I’ve got a short post lined up for early November when I return - see you then!\nAs always, you can find the source files for the script to generate the polling average and for this site on my github.\n\r","date":1634601600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1634668390,"objectID":"5531e2a66af37a942d79300622105cc3","permalink":"https://www.thedatadiary.net/blog/2021-10-19-polling-average-of-the-va-governor-s-race-using-purrr-map-functions/","publishdate":"2021-10-19T00:00:00Z","relpermalink":"/blog/2021-10-19-polling-average-of-the-va-governor-s-race-using-purrr-map-functions/","section":"blog","summary":"Rolling poll averages can be misleading in the absence of errorbars or an expected distribution of outcomes. FiveThirtyEight is currently tracking polls of Virginia’s Governor race slated for early November, and has kindly made their polls available to the public.","tags":[],"title":"Polling Average of the VA Governor's Race using purrr::map functions","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rIn my job, I spend a good amount of time working in the platform setup by our survey vendor, Qualtrics. There are some pre-formatted reports that we can send on a recurring basis through Qualtrics, but for one-off or custom reports, I can work with the raw data in R. A few weeks ago, however, I was asked to setup a recurring email to send a customized report to a group of hospital directors each week. While R makes generating the report simple, sending out each week was tedious, as each one needed to be sent separately. Since the reports contain patient information, I couldn’t automate via a third party server like GitHub Actions. I needed a way to localize the automation to my computer.\nLuckily enough, I was able to work out a solution! I wrote about it in a submission to RStudio’s 2021 Call for Documentation. You can read my article on Automated Email Reports with R, VBA, and the Task Scheduler for more detail.\nSome programming notes\r\rI’ve been named one of RStudio Community’s New Users of the Month!\rI’ve started working in Rmarkdown for these posts (you can actually view the native file for this post here). This allows me to mix in code and prose in one document \u0026amp; should make the process a bit easier on my end.\rI’ve scheduled out posts every two weeks for the rest of the year. I wanted to give myself enough time to work on some longer term projects, so be on the lookout for more in store!\r\r\r","date":1633392000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633491586,"objectID":"b9bed1e7d9dba7c860204ab19d4af34b","permalink":"https://www.thedatadiary.net/blog/2021-10-05-rstudio-s-call-for-documentation/","publishdate":"2021-10-05T00:00:00Z","relpermalink":"/blog/2021-10-05-rstudio-s-call-for-documentation/","section":"blog","summary":"In my job, I spend a good amount of time working in the platform setup by our survey vendor, Qualtrics. There are some pre-formatted reports that we can send on a recurring basis through Qualtrics, but for one-off or custom reports, I can work with the raw data in R.","tags":[],"title":"RStudio's Call for Documentation","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rWow, it’s been quite a while! Once again, I’m catching up from a long hiatus (this time, there was about a month’s gap between posts). Although I haven’t been writing here, I have been keeping myself incredibly busy - for that reason, I think I’m going to switch up the format of this site. Here’s a few changes I’m planning on making, \u0026amp; also why I plan on making them.\nOpening up topic options\rUp until now, I’ve pretty much exclusively been looking at politically-related things from a data-centric point of view, partially because most news outlets are sensationalist and it annoys me, and partially because the 2020 election \u0026amp; aftermath was on my mind for most of early 2021 (also, wanting to understand the Economist’s Election Forecast methodology was the spark that led to taking stats classes, learning R, and [eventually] landing a new job). While I still want to/expect that I will touch on political-esque topics, I want to expand into things I’m more generally interested in. I’ve spent a lot of time this year working on projects that don’t touch politics and it was difficult to spur the enthusiasm to work on a political project just to fill the site after having spent hours coding something unrelated. I’ve imposed this political filter on myself, \u0026amp; expanding the horizon to include any/all topics that interest me will allow me to more consistently write without overextending myself.\n\rMoving away from Squarespace\rCurrently, this site is hosted by Squarespace. This was great for getting setup \u0026amp; used to working online, but after a year of working with it, I’ve realized that it isn’t the ideal platform for my use case. Early next year, hopefully, I’ll switch over to using rmarkdown, Hugo, and Netifly to build \u0026amp; deploy a site directly from R. This will make my life a lot easier, for a couple of reasons:\n\rI will have a lot more control over layouts and themes\rI’ll be able to more easily share code, images, and interactives(!)\rThe code \u0026amp; the website will be housed under one directory (rather than existing as two separate entities)\r\rAdditionally, the platform I’m planning on moving to is more blog/personal-professional focused, rather than retail focused, like Squarespace. I may also be able to move towards having posts appear in emails, rather than having to link to the post itself.\n\rTimeline\rI haven’t yet settled on this yet, but I may move from a weekly schedule to a bi-weekly schedule (not that I ever really stuck to the weekly schedule). The projects I’ve been working on typically take quite a bit of time, so trying to churn one out each week means that I may have to suffer quality for a schedule, which I don’t want to do. I’d rather have enough time to fully devote to completing something.\nAnyways, that’s a lot of updates - I’ll hopefully check in within a few weeks time!\n\r","date":1632355200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1632454528,"objectID":"86a3dca907acea562371f4cdc0ed1305","permalink":"https://www.thedatadiary.net/blog/2021-09-23-catching-up-again/","publishdate":"2021-09-23T00:00:00Z","relpermalink":"/blog/2021-09-23-catching-up-again/","section":"blog","summary":"Wow, it’s been quite a while! Once again, I’m catching up from a long hiatus (this time, there was about a month’s gap between posts). Although I haven’t been writing here, I have been keeping myself incredibly busy - for that reason, I think I’m going to switch up the format of this site.","tags":[],"title":"Catching Up (again)","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rThis week, I thought I’d do something a bit different. I’ve been working with \u0026amp; getting used to tidymodels, a suite of R packages for building machine learning models with tidyverse principles (you can thank Julia Silge’s blog for providing a whole host of examples and walkthroughs). Using tidymodels and Kaggle’s Titanic dataset, I created a few simple models to predict whether or not each passenger survived.\nExploratory Data Analysis\rFirst off, it’s important to get to know the dataset in a bit of detail before diving into model building. The Titanic dataset is relatively small, containing 12 columns of data on 891 passengers.\n\rPassengerId : ordered number assigned to each passenger (1, 2, 3… etc.).\rSurvived : indicates whether the passenger survived or not (imported as numeric, where a 1 means that the passenger survived and a 0 means that the passenger died.\rPClass : passenger class (1st, 2nd, or 3rd).\rName : passenger’s name.\rSex : passenger’s sex.\rAge : passenger’s age.\rSibSp : number of the passenger’s siblings and/or spouses aboard the ship.\rParch : number of the passenger’s parents and/or children aboard the ship.\rTicket : passenger’s ticket number.\rFare : price of the passenger’s ticket.\rCabin : passenger’s cabin number.\rEmbarked : port from which the passenger embarked.\r\rThe passenger’s name and ticket number are unique, and don’t offer any much predictive power (at least, not for the type we’ll be deploying), so I’ve removed those columns from the selection. The majority of passengers are missing Cabin information, so I’ve similarly removed that column. Let’s take a look at the age distribution by gender. Density plots are good for this sort of objective, but a quick note - density plots don’t show the counts (like a histogram), just the relative distribution of each group.\nBoth men and women have similar age distributions, with the majority being adults roughly in their twenties. It’d be interesting to look at which age groups survived.\nThere’s a spike survivorship at a young age (as expected, due to the prioritization of children). Young adults make up the majority of both survivors and those who died, simply because young adults made up the majority of passengers. It may be more interesting to see which male/female age groups survived.\nInterestingly, there’s a large portion of the women who died were children. To gain some more insight, however, it may be beneficial to bin the results. As mentioned above, density plots don’t show a count of each age, but the relative amounts instead. We can use a histogram to get a better idea of the actual amount in each group.\nFrom the histogram, we can see that there were far more male passengers than female passengers. Let’s setup age brackets and see how many of each age group survived.\nDespite there being more male passengers, there were more female survivors in just about every age bracket. I had expected that women would have a greater percentage of survivorship, but was mildly surprised that the absolute number of female survivors was greater than the number of male survivors.\nLets look at how survivorship is related to the number of family members each passenger was traveling with.\nWhile there’s not huge variation between survivorship percentages across each class, we can see that the majority of passengers were traveling alone.\nFinally, I looked at the distribution of the fare price by survivorship. As expected, passengers who didn’t survive skewed towards low cost fares while survivors were more evenly distributed across fare prices.\n\rModel Fitting and Evaluation\rNow that we’ve explored the data a bit, we can get started on some actual model fitting and evaluation. I split the dataset into a training set and test set, and built two simple models - a logistic regression and a random forest model. In very light detail, a logistic regression is the most basic classification model based on the generalized linear model and a random forest model is a decision tree-based algorithm. With no tuning applied, neither model performed particularly well - the logistic regression and random forest models had accuracies of 85.5% and 83.8% on the test set, respectively. While the logistic regression had a slightly higher accuracy on the test set, the random forest performed better on the metric of area under the ROC (receiver-operator characteristic) curve - 0.899 compared to 0.888 (generally, binary classification systems with ROC AUC values close to 1 perform better). A comparison between the two ROC curves is shown below.\nIt’s not perfect, but the purpose was to explore the tidymodels framework, and I’m pretty happy with the outcome/practice along the way.\n\rSome Things to Read/Watch/Listen to\r\rThere’s been a concerted effort by prominent conservatives to promote vaccination and shift the blame for vaccine hesitancy to the Biden administration, pointing in particular to one of Kamala Harris’ comments during the Vice Presidential debate. This criticism falls fairly short, given that commentators like Tucker Carlson and legislators like Marjorie Taylor Green continue to spread vaccine conspiracy theories. Further, a statistical model by the Economist found that the strongest predictor of whether or not someone has been vaccinated is who they voted for in the 2020 presidential election.\rJulia Silge was recently featured as a guest on an excellent episode of the Not So Standard Podcast. Well worth a listen for R dorks like myself.\rPerry Bacon Jr wrote an informative piece on the misplaced importance on swing voters in election cycles.\r\r\r","date":1628380800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1628479382,"objectID":"56a5143a9a40d27f16deca6d2ba0c3ff","permalink":"https://www.thedatadiary.net/blog/2021-08-08-tidymodels-and-the-titanic/","publishdate":"2021-08-08T00:00:00Z","relpermalink":"/blog/2021-08-08-tidymodels-and-the-titanic/","section":"blog","summary":"This week, I thought I’d do something a bit different. I’ve been working with \u0026amp; getting used to tidymodels, a suite of R packages for building machine learning models with tidyverse principles (you can thank Julia Silge’s blog for providing a whole host of examples and walkthroughs).","tags":[],"title":"Tidymodels and the Titanic","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rAs America has vaccinated its population, life has seemingly begun to return to the pre-pandemic normal. Businesses have been opening to higher levels of capacity, schools are planning for higher levels of in-person learning in the fall, and, notably, Americans have returned to pre-pandemic levels of transit.\nConservative commentators and representatives have pointed out that prices of commodity goods - in particular, gasoline - have skyrocketed over the past year and attribute this increase to Biden’s presidency. Looking at retail gasoline prices, we can see a steady increase since Biden took office.\nWhat they fail to point out, however, is that the price of gasoline (and other commodities) significantly dropped during the pandemic, and that the increases are largely a return to pre-pandemic prices.\nWhile there are certainly opportunities to critique the current administration’s energy policy (banning new drilling leases on federal land/water and canceling the Keystone XL pipeline’s border-crossing permit, for example), attributing the recent return to pre-pandemic gasoline prices is a particularly weak and intentionally misleading avenue of attack.\nAs always, you can find my work on github.\nSome Reading/Viewing Material\r\rThe Economist wrote an interesting article finding a significant link between a county’s in-person voting rate and new COVID cases in November.\rElliot Morris summarized the work of several political scientists in a recent article describing why the GOP slid so far towards authoritarianism in the past decade. The article is behind a subscriber paywall, but is well worth the read. In short, however, “ethnically antagonistic” voters are much more likely to agree with statements traditionally viewed as authoritarian. This group hadn’t coalesced under a single party until Trump brought these anti-racial voters into the party (recall his role in the birther conspiracy and the racial antagonism surrounding his 2016 campaign), at which point democratic (note, small “d”) norms became a partisan issue.\rIn my machine learning class, I’ve started learning about the implementation of neural networks. The course’s instruction style is highly technical, but Grant Sanderson’s series on neural networks has helped me align a technical and intuitive understanding of the topic.\r\r\r","date":1626664612,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1626664612,"objectID":"38cd85b1191b40c4221e823b9be2d87a","permalink":"https://www.thedatadiary.net/blog/2021-07-18-the-gas-price-fallacy/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/2021-07-18-the-gas-price-fallacy/","section":"blog","summary":"As America has vaccinated its population, life has seemingly begun to return to the pre-pandemic normal. Businesses have been opening to higher levels of capacity, schools are planning for higher levels of in-person learning in the fall, and, notably, Americans have returned to pre-pandemic levels of transit.","tags":[],"title":"The Gas Price Fallacy","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rLast year, Donald Trump won Texas’ 38 electoral votes handily, earning 52% of the vote compared to Biden’s 46% (R+6). Taken on its own, this is hardly surprising - Texas has gone to the Republican presidential candidate in every election since 1980. Looking at the relative gains made in Texas over recent election cycles, however, paints a much more hopeful picture for Democrats hoping to flip the state \u0026amp; garner the nickname, “blexas.”\nOn election day, FiveThirtyEight and the Economist gave Biden a 38% and 30% chance of winning in Texas, respectively. While still bearish on Biden, this is far more bullish than 2016, when FiveThirtyEight’s model gave Clinton a mere 5% chance of winning in Texas (in fact, both FiveThirtyEight and the Economist were more confident in Biden’s chance of winning Texas in 2020 than FiveThirtyEight was that Trump would win the presidency in 2016 (28%)). Part of this shift can be attributed to Democratic gains nationally, but Texas Democrats have been steadily gaining more ground than can be explained by national swing.\nThe Cook Political Report publishes its Partisan Voter Index (PVI) following each presidential election. PVI is a measure of how a state, district, or county votes relative to the national environment. For example, say a Democratic candidate wins 53% of the two-party voteshare nationally, but 51% in a given state. Despite the state going to the Democratic candidate, the state PVI would be R+2%, since the candidate performed 2% under the national vote (the actual PVI calculated in the Cook report is slightly more involved, but this basic understanding is sufficient for our purposes). Looking at Texas’ PVI over past elections, we see that Democrats have been making relative gains in every election since 2004, despite Texas still voting more Republican than the nation.\nMuch of this can likely be attributed to demographic shifts drive by major Texas cities - Dallas, Houston, Austin, and San Antonio have seen massive population increases, largely due to domestic and international migration (as opposed to natural changes - e.g., births). As Texas grows, it also continues to diversify. The non-hispanic white population in Texas dropped from 45% in 2010 to 41% in 2019, and non-white population groups have driven growth over the past 10 years.\nAll that being said, while I expect that Texas will continue to experience demographic shifts that are favorable in the eyes of Democratic politicians, in the absence of any real modeling work, I’m hesitant to say that Texas will turn blue in the near term. Despite gains in the presidential results, Texas Democrats didn’t outperform expectations in the house, nor did they even advance a candidate in the special election for TX-06 (two Republican candidates advanced to a runoff). Governor Abbott is also introducing a special legislative session with one goal (of many) of making Texas a state with some of the most restrictive voting laws with targeted partisan effects. Looking to other states as a reference, North Carolina had also seen similar PVI shifts in the past without resulting in Democratic victories (though, to be fair, North Carolina hasn’t experienced the same level of demographic shift that Texas is undergoing).\nPerhaps there is some modeling work I can do to produce a more definitive stance, but until then, I’ll hold on making any bold predictions.\nAs always, you can find my work on github.\nGeneral Updates\rIt’s been quite a while, but it’s good to get back into writing again. I wrote the scripts/made the charts for this post about two weeks ago, but haven’t had the time (or rather, haven’t made the time) to write the post itself. While I feel like I’ve been saying this for three months now, I do hope to get back to a more regular schedule soon - perhaps biweekly, to avoid rushing projects. We’ll see - in any regard, here are some updates that I’m excited about:\n\rI started my new job a few weeks ago! It’s both very rewarding (I get to use R \u0026amp; work with large polling datasets daily!) and very demanding. I enjoy the challenge \u0026amp; am excited for upcoming projects that I’ve been tasked with.\rI’ve been steadily making headway against the Machine Learning course I’ve been taking - at this point, I’m about halfway finished.\rI’ve begun to poke around in the tidymodels framework. I’m interested in the standardization the packages supply for generating models in R.\r\rSome reading/viewing material:\r\rI linked to it above, but it’s worth reading through this NYT article on the special legislative session in Texas. I only touched on voting rights, but session is primed as another hot-button issue session following spring’s ultra-conservative agenda.\rChecks and Balance, the Economist’s weekly podcast, focused on Critical Race Theory \u0026amp; the troubled history of race in American education in their most recent podcast, “History Test.” It’s well worth a listen, especially if you’re like me, and had never heard of CRT until recently.\rJust over 6 months ago on January 6th, violent Trump supporters stormed the U.S. capitol. With time and overt lies being propagated by Fox News, OANN, and Newsmaxx, it’s easy to forget exactly what happened and how it felt on that day. This NYT Visual Investigation does an excellent job of reconstructing the timeline of the events that day.\r\r\r\r","date":1625961600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1626059214,"objectID":"81ddc37ae53ed94b98a296e94ac2b118","permalink":"https://www.thedatadiary.net/blog/2021-07-11-blexas/","publishdate":"2021-07-11T00:00:00Z","relpermalink":"/blog/2021-07-11-blexas/","section":"blog","summary":"Last year, Donald Trump won Texas’ 38 electoral votes handily, earning 52% of the vote compared to Biden’s 46% (R+6). Taken on its own, this is hardly surprising - Texas has gone to the Republican presidential candidate in every election since 1980.","tags":[],"title":"Blexas?","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rAs vaccines have become widely available in the US, new COVID cases and deaths have dropped significantly from winter peak, with the 7-day average for both cases and deaths nearing the averages reported during the initial lockdown in the summer of last year (note that, in the chart for the 7-day average of deaths below, the scale is restricted to 15 deaths per million; this cuts off some of the state surges, but shows the US average better than a chart with an unedited scale).\nAccording to the US Vaccine Tracker, 41% of Americans are fully vaccinated as of today. Even more heartening is the fact that the partisan divide regarding vaccine hesitancy, while still existent, is shrinking.\nWhile this is certainly good news about the country as a whole, individual states, counties, and cities may have varying levels of success in curbing the spread of the virus in the local community. The New York Times created a helpful dashboard that lets you look at the spread of the virus on a state, county, or metro area scale.\nAll this is to say that, while the pandemic is still not (and possibly will never be) a thing of the past, the introduction of vaccines certainly has appeared to help curb the spread.\nCatching Up\rIt’s been a while since I’ve written, due to a flurry of weddings and trips. While I had originally hoped to get back onto a regular weekly writing schedule, I will again have to push out the next post until late June, due to some exciting personal news: June 21st, I’ll be starting a new job! I’ll be transitioning from engineering in the oil \u0026amp; gas industry to healthcare analytics, which I’m really excited about! In the meantime, however, there’s a flurry of work to do in my current job to ensure that the person backfilling me is prepared to pick up the projects I’m working on. Hopefully after that, I can get back to a regular schedule.\nAs always, you can find my work on github.\n\r","date":1622678400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1622775681,"objectID":"6e4124bf5bd3c5b09a27830a61cf418d","permalink":"https://www.thedatadiary.net/blog/2021-06-03-covid-cases-improve-with-introduction-of-vaccines/","publishdate":"2021-06-03T00:00:00Z","relpermalink":"/blog/2021-06-03-covid-cases-improve-with-introduction-of-vaccines/","section":"blog","summary":"As vaccines have become widely available in the US, new COVID cases and deaths have dropped significantly from winter peak, with the 7-day average for both cases and deaths nearing the averages reported during the initial lockdown in the summer of last year (note that, in the chart for the 7-day average of deaths below, the scale is restricted to 15 deaths per million; this cuts off some of the state surges, but shows the US average better than a chart with an unedited scale).","tags":[],"title":"COVID Cases Improve with Introduction of Vaccines","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rElliot Morris wrote in his newsletter last week about the increase in the public’s opinion that the government ought to be doing more. A summary of the last twenty years of polling by NBC shows that, while there seems to be a reactive effect based on the party of the president, support for increased government activity has generally been on the rise.\nThe combination of Biden’s approval across several categories, public support of his proposals (with the exception of his original cap on refugees, which he then raised after public outcry), and the public support of increased government activity gives Biden a strong argument in pressing congress to get his progressive policies pushed through to his desk. Despite the popularity, his $4 trillion infrastructure and families plan largely depends on what the senate parliamentarian will allow into a reconciliation bill (which only needs majority approval, rather than a filibuster-proof 60 votes) and the votes of a few moderate Democratic senators, since the bills will receive no Republican support in the senate.\nOutlook for the Coming Weeks\rI’ll be taking a break for the next few weeks, due to a flurry of weekend trips/weddings now that I/most of my friends are fully vaccinated. I’ll continue to work on the database in the background (notably, I need to dive deep into the census bureau demographic data, which needs a lot of fixing). I’ll likely write a short update in either late May or early June.\nAs always, you can find my work on Github.\n\r","date":1620172800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1620269794,"objectID":"e1a09e19435c95f4daff59a1d3c8dd13","permalink":"https://www.thedatadiary.net/blog/2021-05-05-president-of-the-polls/","publishdate":"2021-05-05T00:00:00Z","relpermalink":"/blog/2021-05-05-president-of-the-polls/","section":"blog","summary":"Elliot Morris wrote in his newsletter last week about the increase in the public’s opinion that the government ought to be doing more. A summary of the last twenty years of polling by NBC shows that, while there seems to be a reactive effect based on the party of the president, support for increased government activity has generally been on the rise.","tags":[],"title":"President of the Polls","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rOnce again, I’ll be keeping this very short, as I’ve continued to primarily focus on building out the demographic/economic database. I, did, however, sneak in some time to explore the 2020 Census Apportionment Results that were released yesterday. Some surprises came out of the release: Texas and Florida underperformed expectations, only gaining two and one seat, respectively; Arizona didn’t gain a seat; and New York lost a seat but was apparently 89 people short of retaining its seats. Given that Texas and Florida each gained one less seat than was generally expected, there’s been some speculation online that Donald Trump’s attempt to undercount Hispanics was successful, but backfired. I’ll hold my judgments on this theory until I can read some more in-depth opinions (if they get written).\nWith the new apportionment and population data, each individual’s representative power in congress has shifted. Including both Senators and House Representatives, states with smaller populations continue to have outsized representation in congress: Wyoming and Vermont have significantly more representatives per million residents than California or Texas, for example. Residents of Washington D.C., however, receive no representation in congress.\nAs a side note, the reps-per-million will be greater than the total number of congressional representatives in states with less than one million residents. This chart is really meant to compare the uneven representative power of each state.\nIf D.C. were to become a state, it would have outsized representative power, similar to Wyoming and Vermont, due to its size. That, however, isn’t really a justification to deny ~700,000 Americans national representation, and the arguments against D.C. statehood have been weak at best and implicitly racist at worst, given D.C.’s majority-minority population.\nStill, it’s virtually impossible that D.C. statehood receive the filibuster-proof 60 votes in the Senate (I’d doubt that even a compromise of retrocession into Maryland would pass). For the time being, residents of D.C. will have to wait for representation until polarized ideological walls come down and Republicans vote for D.C. statehood, Democrats gain enough seats for a supermajority, or the filibuster is abolished.\nAs always, you can find my work on Github.\n","date":1619481600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1619578221,"objectID":"c7ea4a98eb88d06855f5ddd80b63e10c","permalink":"https://www.thedatadiary.net/blog/2021-04-27-a-lukewarm-case-for-dc-statehood/","publishdate":"2021-04-27T00:00:00Z","relpermalink":"/blog/2021-04-27-a-lukewarm-case-for-dc-statehood/","section":"blog","summary":"Once again, I’ll be keeping this very short, as I’ve continued to primarily focus on building out the demographic/economic database. I, did, however, sneak in some time to explore the 2020 Census Apportionment Results that were released yesterday.","tags":[],"title":"A Lukewarm Case for DC Statehood","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rThe past few weeks have been a bit lite (read::absent) in terms of posting updates. When not taking the machine learning course, I’ve been spending quite a bit of time working on building out a database of demographic data (from 1980 to 2019). The goal is to be able to build this database out once, then reference it repeatedly for future projects. If you’re so inclined, you can read my unedited ad-hoc thoughts while working on the database here. There’s lots of code interspersed with prose, so it’s a bit of a slog to read through, but gives a really detailed account of how I worked through the different problems that arose.\nThat being said, I did have a bit of time to squeeze in a quick chart. YouGov recently conducted a poll on each state’s favorability rating according to Democrats and Republicans. Not surprisingly, state favorability is closely aligned with Biden’s voteshare in November.\nI’ll keep this short and sweet. I may continue to write sparsely over the next month or so, due to a few trips (now that I have the COVID vaccine), but will continue to work on the database in the background.\nAs always, you can find my work on Github.\n","date":1618876800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1618973123,"objectID":"d358bbfd226617d4aa52c9bc8e790f0a","permalink":"https://www.thedatadiary.net/blog/2021-04-20-catching-up/","publishdate":"2021-04-20T00:00:00Z","relpermalink":"/blog/2021-04-20-catching-up/","section":"blog","summary":"The past few weeks have been a bit lite (read::absent) in terms of posting updates. When not taking the machine learning course, I’ve been spending quite a bit of time working on building out a database of demographic data (from 1980 to 2019).","tags":[],"title":"Catching Up","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rLast week, the Washington Post published an article postulating that the recent increase in crossings at the border cannot be attributed to Biden administration policies, but rather is a function of seasonal patterns and pent up demand due to restricted travel in 2020. While the article is well intentioned, a simple linear model that predicts crossings based on month shows seasonality is a poor predictor (or, at least is a poor predictor on its own).\nExamining the Data\rThe US Border Patrol (USBP) publishes monthly data summarizing the number of encounters/crossings at the Southern border. Since November of 2020, border crossings have increased monthly, from about 70,000 in November to a little over 100,000 in February.\nLooking at the long term monthly data, however, reveals two key aspects:\n2019 was an exceptionally high year for crossings, and 2021 is on track to have a similar number of crossings;\rThere seems to be a cyclical set of peaks and troughs in annual border crossing numbers.\r\rLooking at the chart above, it’s difficult to determine which months correspond to peaks and troughs. Aligning by month offers a clearer picture of how monthly border crossings in each year compare to other years.\nFrom this chart, it does appear that there is some semblance of a monthly pattern, albeit with extreme outliers of 2019, 2020, and 2021. Appearances, however, can be deceiving, and a mathematical model can help distinguish signal from noise. Using month as a predictive input, we can create a model that estimates the expected number of crossings in said month. If we look at the residual error (the actual number of crossings minus the predicted number of crossings) over time, we can get an idea of how well the model is performing. If seasonality is a good predictor of the number of border crossings, the model will accurately account for seasonal shifts, and the residual error plot would be expected to remove or reduce the “waviness” that appears in the crossing plot and only show the long term trends.\nPlotting the residual error, however, doesn’t filter out seasonal noise. In fact, apart from the y-axis shifting down, the residual plot is strikingly similar to the crossings plot. This means that the month offers little power on its own in predicting the number of border crossings.\n\rClosing Remarks\rThe Washington Post article makes good points that aren’t discussed fully here, but are worth mentioning:\n\rThose who planned on crossing the border in 2020 but couldn’t due to travel restrictions may have simply waited until now to travel.\rUnaccompanied migrants are arriving at the border in rates that exclude the possibility of seasonal patterns.\r\rAlso notable is that seasonal patterns - while not a good predictor of the number of border crossings on its own - may be more impactful in a more robust model. As a professor from the University of San Diego explains, conditions in the migrant’s country of origin and the countries they pass through are among a host of variables that play a significant role in determining if migrants make the trip to the US border. While a more robust model may be able to accurately incorporate season into its predictions, simply using month as a predictor, as the Washington Post does in their article, does not explain the surge at the border (evidenced by the fact that this equally simple model refutes their finding).\nFinally, it should be noted that, above all else, there is a humanitarian crisis at the border. If you’d like to find a way to help or donate, Global Giving is an excellent resource.\n\rSome Other Updates\rHere’s what I’ve been working on recently:\n\rTidyTuesday: I’ve made my first contribution to #tidytuesday! For those who are unaware, TidyTuesday is a weekly data project in R for the R4DS (R for data science) community. Each week, a public dataset is released on Monday, allowing users to explore and create interesting visualizations and analyses based on the dataset. This week, a dataset based on global deforestation was released, but it came along with interesting information on the production of vegetable oil. I plotted the global annual vegetable oil production by crop type in the steamgraph below.\r\r\rCourses: I’ve continued with the machine learning and Bayesian courses, though I’ve descoped to roughly two days each week, as my personal schedule has gotten quite hectic. The ML course is excellent for understanding the theory that goes into each algorithm, but in practice, I expect that I will likely make use of the tidymodels R package’s relatively simple interface.\rRmd: I’ve started writing my code in a R markdown document, which allows me to mix both code and prose. I mix in some off-the-rails/stream of consciousness commentary as I step through the process to get to a functional code. For regularly updated/critical code/projects, I’ll still stick to concise scripts.\r\rThat’s all for this week - as always, you can read through the code for this piece or for the tidytuesday piece on github. See you next week.\n\r","date":1617580800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1617676470,"objectID":"3653d8224c6ead4e3cfe52d6340a854b","permalink":"https://www.thedatadiary.net/blog/2021-04-05-seasonality-is-a-weak-predictor-of-border-crossings/","publishdate":"2021-04-05T00:00:00Z","relpermalink":"/blog/2021-04-05-seasonality-is-a-weak-predictor-of-border-crossings/","section":"blog","summary":"Last week, the Washington Post published an article postulating that the recent increase in crossings at the border cannot be attributed to Biden administration policies, but rather is a function of seasonal patterns and pent up demand due to restricted travel in 2020.","tags":[],"title":"Seasonality is a Weak Predictor of Border Crossings","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rOne of the history teachers at my highschool was known for his prolific catchphrase, “give me the stuff, not the fluff,” often uttered to students attempting to submit history papers padded with superfluous words and sentences in order to meet a minimum word threshold. While I never took a class with this teacher, the phrase has stuck with me. With that in mind, I’ve reprioritized some of the things I’ve been working on. Here’s what I’ve been up to over the past week:\n\rTX COVID Tracker: Over the weekend, I put together and published my first Shiny application, a county-level interactive Texas COVID tracker. Using data from the New York Times, the tracker lets the user view county-level historical data. The goal is to fill in the gaps of the Times’ Texas tracker, which shows historical state data and live county data, but doesn’t offer historical county data.\n\rClasses: I had previously spent evenings working on projects in R and had pushed off some of the statistics classes to focus on these projects. This past week, I’ve scheduled an hour each day for dedicated class time, alternating daily between a Bayesian inference course and a machine learning course.\r\rMy plans for the upcoming week:\r\rTX COVID Tracker: While the interactive tracker is functional, it still leaves a lot to be desired. Being the first Shiny app I developed, I ran into a lot of learning curve issues but should be able to make updates more quickly. This upcoming week, I plan on converting to a bootstrap layout, adding in an interactive state map with leaflet, adding in statewide hospitalization and vaccination information, adding a state and county level log-log plot, making some formatting changes to help with mobile viewing, and updating themes/appearances. Eventually, I’d like to write a scheduleR script to automatically update the data, but that may need to be put off to focus on the laundry list above.\rClasses: I’ll still continue with the daily schedule for coursework and may be able to finish the Bayesian inference course this week.\r\rBetween the COVID tracker and classes, I don’t think I’ll have too much time to work on anything else. That being said, I’ve got some projects/articles in the backlog that I’m looking forward to working on:\n\rPolarization - top down or bottom up? It’s no secret that we are living in the most polarized political landscape since the Civil War, but I’m interested in exploring where this polarization originates. Do elected politicians split the public by pushing increasingly divisive policies? Or do voters lead the polarization effort by increasingly self-segregating into isolated camps?\rTwo Party PVI (Partisan Voter Index): The partisan voter index (PVI) is a measure of a state’s (or county’s) partisan preference relative to the national environment. There’s a story here about how the national environment is progressing - are our country voting preferences converging or diverging? What states are trending towards Democrats? What states are trending towards Republicans?\rThe Gas Price Fallacy: I’ve seen quite a few bad faith attempts to blame increasing gas prices on Joe Biden recently. Additionally, it’s particularly frustrating that I’ve seen a number of my colleagues in the oil \u0026amp; gas industry repeat this nonsense. As a working member of the oil \u0026amp; gas industry, I think I’m qualified and have a duty to explain why the administration change isn’t the cause of the rising gas prices (the TL;DR version is that we’re recovering from a global pandemic \u0026amp; oil oversupply, you can see that gas prices are just returning to pre-COVID Trump administration levelshere.)\r\r\r","date":1615766400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1615766400,"objectID":"d3d7e8381135f3e394e2db59849aa79a","permalink":"https://www.thedatadiary.net/blog/2021-03-15-recent-works/","publishdate":"2021-03-15T00:00:00Z","relpermalink":"/blog/2021-03-15-recent-works/","section":"blog","summary":"One of the history teachers at my highschool was known for his prolific catchphrase, “give me the stuff, not the fluff,” often uttered to students attempting to submit history papers padded with superfluous words and sentences in order to meet a minimum word threshold.","tags":[],"title":"Recent Works","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rThis week, I did something a bit different - the artwork above was made in R! The code to create the graph is actually pretty short, only taking up 28 lines. The bulk of the work was spent writing the csv containing all the polygon points and colors. I spent most of the past week doing some back end work that will pay off in the future. Namely, I set up a local clone of my repository on github and figured out how to embed Shiny applications on Squarespace.\nI’d like to address something that has been nagging me for a bit. Last week, I wrote about Georgia’s special senate race. I spent a lot of time learning new packages and methods, and am happy with how the plots and majority of the post turned out. Near the end of the post, however, I made the conjecture that Doug Collins may have seen an opportunity to run against Kelly Loeffler because she was a polarizing candidate with a string of controversies surrounding her campaign. While I shared sources that generally support this position, I didn’t back it up with any sort of data or in-depth analysis. I’m not a political scientist nor am I an expert in election strategy, so in hindsight I think it was pretty irresponsible to add my uninformed opinion to the post. I’ll leave the post up unedited, since it’s important to keep a true record of what I’ve written, but moving forward, I’ll be better about writing the story the data reveals, rather than one I’d like to believe.\n","date":1615075200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1615170292,"objectID":"e079f6d3805b85949b6b207547bc0997","permalink":"https://www.thedatadiary.net/blog/2021-03-07-artwork/","publishdate":"2021-03-07T00:00:00Z","relpermalink":"/blog/2021-03-07-artwork/","section":"blog","summary":"This week, I did something a bit different - the artwork above was made in R! The code to create the graph is actually pretty short, only taking up 28 lines.","tags":[],"title":"aRtwork!","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rI’ll be honest - prior to writing this post, I had never heard of Doug Collins (R), the third major candidate in the race for Georgia’s special senate election after Raphael Warnock (D) and Kelly Loeffler (R). I wasn’t particularly tuned in to the Georgia senate elections prior to the runoff (by which time, the special election race had narrowed to just Warnock and Loeffler) and most of the coverage I had seen prior to Nov. 3rd pitted Warnock against Leoffler, without considering Collins. Even Google search trends show that people were more interested in Loeffler than Collins leading up to the election.\nDespite my ignorance, Collins was a major candidate in the special election, and ended up with a significant portion of the republican vote. It may be a bit obvious, but republicans splitting votes between Loeffler and Collins made Warnock a significantly more competitive candidate. However, the role of voter dropoff relative to the regular senate election is worth exploring in detail.\nComparing Results\rGeorgia’s regular senate election was a much more typical election than the special election - a tightly contested election between two candidates, Jon Ossoff (D) and David Perdue (R). The county result map comparing the voteshare of the two major candidates shows democratic strongholds in urban areas and a republican lean in rural areas. The county result map of the special election, if comparing Warnock to both Loeffler and Collins, is noticeably redder.\nIf we remove Collins, however, and just look at the county map comparing the top two candidates, the map shifts drastically in Warnock’s favor.\nAt face value, this explains how Warnock was able to advance to the runoff - split ticket votes aren’t usually good for the party with multiple major candidates. Voter dropoff between the regular and special election, however, shows just how much this pushed Warnock over the edge.\n\rVoter Retention: a Tale of Two Elections\rAbout 5 million Georgians voted in each of the senate elections in November. In the regular election, the major candidates, Ossoff and Perdue, accounted for about 98% of the votes, the rest going to Libertarian Shane Hazel or other write-in candidates. In the special election, on the other hand, a huge portion of Georgia voters didn’t vote for the major candidates - Warnock, Loeffler, and Collins only account for 79% of the votes! That’s about a 1 million voters who didn’t vote for their party’s major candidate (i.e., “dropped-off”).\nTo get a clear grasp of what voter retention means in this context, let’s consider a hypothetical county with 100 voters, of which 60 voted for Perdue and 40 voted for Ossoff in the regular election. Let’s also say these 100 voters split their special election votes in the following way: 35 votes for Loeffler, 15 votes for Collins, 30 votes for Warnock, and 20 write-in votes. In this scenario, Warnock retained 75% of regular election votes (30 / 40 = 75%), republicans, collectively, retained 83% ([35 + 15] / 60 = 83%), and Loeffler retained 58% (35 / 60 = 58%). In this hypothetical county, republicans collectively improved relative to the regular election, since they had a greater vote retention, but Loeffler on her own worsened, despite winning more votes than Warnock.\nIf we compare retentions for the entire state of Georgia, we can see that Loeffler and Collins were collectively better at retaining regular election votes than Warnock, retaining about 90% of Perdue votes compared to Warnock’s retention of about 68% of Ossoff votes. On her own, however, Loeffler was worse at retaining votes than Warnock, retaining a little over 50% of Perdue votes. This means that Warnock improved democratic performance relative to the regular election when compared against Loeffler directly.\nRepeating this comparison across every county in Georgia shows that Loeffler and Collins, collectively, improved republican performance relative to the regular senate election across every single county. When, however, Collins is omitted, and Warnock and Loeffler are compared directly, democratic performance improves across the majority of counties.\n\rIn Summary\rWhile it was obvious from the beginning that the split ticket hurt republicans in Georgia’s special senate election, it’s interesting to see just how much this split ticket helped Warnock. Collectively, republicans handily won the special election, but splitting votes between Loeffler and Collins meant that Warnock ended up winning a plurality of the votes.\nPolitical analysists are probably better than me at examining why multiple republicans ran as major contenders for the special senate election, but a quick take is that Kelly Loeffler wasn’t a particularly strong candidate. Although she was an incumbent, she wasn’t a senator any Georgian had ever voted for - she gained her senate seat through appointment. Loeffler came to office as a moderate, but quickly pivoted to a more Trumpy ideology, eventually defining herself as “more conservative than Atilla the Hun” in a campaign ad (I would normally just add a hyperlink, but this ad is just too weird not to link directly - I originally thought this was a bad parody).\n   Her campaign was also plagued by a few scandals, like darkening Warnock’s skin in a campaign ad, taking photos with known KKK members, and potentially making stock trades based on COVID-19 information not-yet released to the public. It’s a bit of a conjecture, so take this with a grain of salt, but all of the above factors may have provided Collins an opportunity to run as a stronger \u0026amp; less divisive alternative to Loeffler.\n\rSome Final Notes\rChoropleth charts (maps) can be misleading in the wrong context - it’s easy to subconsciously associate area with population. It wasn’t particularly relevant to the post above, but in spirit of the animation “Land doesn’t vote, people do”, I added dot-plot maps where bubble size corresponds to total number of votes.\nAs always, source data and code can be found on github. I’m particularly happy with how this post turned out. I learned a lot of new things worth highlighting (some of this gets into technical mumbo jumbo):\n\rLearned how to use the maps, gganimate, and gifski packages;\rPicked up new method of piping objects into a ggplot object;\rWorked with geom_col and geom_poly for the first time;\rUsed forcats for the first time (just to reorder a factor, but I’ll still count it as a win);\rAdded new colors to the dd color palette;\rCreated a reusable theme var to reduce code;\rStarted using tibbles.\r\rFor this post, I had originally wanted to compare presidential vote to senate, governor, and house vote, but I had to pivot a bit to just the Georgia senate elections, for a few reasons. Firstly, the senate county dataset from Kaggle, for whatever reason, doesn’t include the winner of each county. Adding this by hand, just for Georgia’s 159 counties and two senate elections took hours. There’s probably a more efficient way to do this by scraping the data from online, but then I’d have to have learned a scraping package in addition to all of the other packages. I may have to hold on the original post idea for a bit while I pick up these skills.\nThat being said, I’ve already started working on next week’s post. It’s a bit of a departure from what I’ve been doing, so I’m excited to see how it’ll turn out.\n\r","date":1614470400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1614564255,"objectID":"dc5efebc4072f04d4aaeb650fb4243de","permalink":"https://www.thedatadiary.net/blog/2021-02-28-doug-collins-saved-raphael-warnock-s-senate-bid/","publishdate":"2021-02-28T00:00:00Z","relpermalink":"/blog/2021-02-28-doug-collins-saved-raphael-warnock-s-senate-bid/","section":"blog","summary":"I’ll be honest - prior to writing this post, I had never heard of Doug Collins (R), the third major candidate in the race for Georgia’s special senate election after Raphael Warnock (D) and Kelly Loeffler (R).","tags":[],"title":"Doug Collins Saved Raphael Warnock's Senate Bid","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rI’m about 4 months too late, but to practice forecasting, I made a modest projection for the 2020 national popular vote using polling data from the two weeks leading up to election day. In the weeks leading up to the election, aggregated polling was fairly stable, and the model projection was within 1.5% of the actual outcome (both the model and actual outcome are adjusted to exclude third parties and instead show the two-party vote share).\nThe projected outcome of Biden’s vote share, 53.6%, is only the most likely outcome in a distribution of possible outcomes predicted by the model. Of the possible outcomes, Biden wins the popular vote about 70% of the time, according to the November 2nd projection.\nLike the projected vote share, the probability of Biden winning the popular vote remained fairly constant in the two weeks leading up to the election.\nIf you were like me, obsessing over the prominent forecast models prior to election day, you may notice that this projection is substantially less confident in the outcome than the leading forecasters. FiveThirtyEight and the Economist, for example, both projected similar popular vote outcomes (within a percentage point of this forecast), but gave Biden at least a 97% of winning the popular vote! There are a couple reasons for this difference:\n\rThis model is one-dimensional : this is a pretty simple model built just to get practice with forecasting and some of the tools in R, so it only uses polls (and, at that, only a small subset of polls), whereas other forecast models used a wide variety of variables to inform the model (economic indicators, demographics, partisanship, etc.).\rThis model doesn’t weight polls : aside from the sample size of the poll, this model doesn’t apply any weights or corrections to the polling data. The polling method, date the poll was taken, and pollster house effect (i.e., how partisan the pollster tends to be relative to the average) can be used to inflate or deflate the weight of each poll in the model. This simple model ignores all of that and treats every poll as equal.\rThis model forces an uncertainty range : unlike other models, which are a set of linear regressions, this model is a relatively simple beta distribution of the vote, with the sum of parameters manually set to 50. This is a bit of technical mumbo-jumbo, but the gist is that a beta distribution allows you to control its “peaky-ness,” and I did this manually, whereas other forecasters had the model do it for them. Increasing the sum of parameters increases how peaky the distribution looks, and a sum of 50 was used based on Florian Muellerklein’s Georgia runoff model, which also used a sum of 50.\r\rSome Notes\rAs always, you can find source data and code on github. I’m pretty happy with how this turned out - I’ve been getting a bit more comfortable with R, and the tools used for this post were pretty intuitive to implement. I’m also happy with the color palette I selected (HTML Color Picker is a godsend). The only improvement is that I could/should have saved quite a bit of code by writing over one of the plot themes, rather than re-writing the theme for each plot. Something to remember going forward.\nNext week, I’ll dig into some of the county-level data from the election to see if there was any ticket splitting between the presidential election and the down-ballot races.\n\r","date":1613865600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1613958877,"objectID":"d7c4612a321f149a7aec1f159cfc8d5c","permalink":"https://www.thedatadiary.net/blog/2021-02-21-kind-of-projecting-the-2020-election/","publishdate":"2021-02-21T00:00:00Z","relpermalink":"/blog/2021-02-21-kind-of-projecting-the-2020-election/","section":"blog","summary":"I’m about 4 months too late, but to practice forecasting, I made a modest projection for the 2020 national popular vote using polling data from the two weeks leading up to election day.","tags":[],"title":"(Kind of) Projecting the 2020 Election","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rA baseball forecast that correctly predicts the winner of the 15 opening day games could be a truly accurate model, or could just be getting lucky. Over the course of 6 months and 2,430 regular season games, however, a great forecast will continue to shine whereas an initially lucky one will falter. In data rich environments like sports, there are lots of events (games) over the course of a season to judge how well a model is performing.\nWhen there aren’t a lot of events to forecast, like presidential elections that occur once every four years (quadrennially?), it’s more difficult to tell how well a forecast performs (a handful of correct/incorrect predictions could just be good/bad luck!), but forecasters still have tools available to evaluate their model. This week, I took a look at a few different methods of comparing different models.\nScoring the Forecasters\rThe most common scoring method, the Brier score, is a measurement of a probabilistic forecast’s accuracy based on the confidence of the prediction. Each event has its own score, and the average of all predicted events is the model’s Brier score. Highly confident predictions are highly rewarded/punished for their accuracy/inaccuracy, whereas timid predictions don’t move the needle too much, regardless of the outcome. Scores can range from 0.00 to 1.00, with 0.00 being a perfect score (you can read more about Brier scores here, but the gist is that the lower the score, the better). In presidential forecasts, each state can be considered an event.\nOftentimes, presidential forecasters report Brier scores as weighted by each state’s number of electors. Correctly predicting Texas’ winner in this scoring system is far more important than correctly predicting Wyoming’s winner, given that Texas’ 38 electoral votes far overshadow Wyoming’s 3. I’m not quite convinced that this is the most meaningful way to evaluate models (California is pretty easy to predict and heavily weighted by its 55 electoral votes, but most of us were more concerned with Georgia’s outcome, despite being undervalued by this scoring method), but forecasters do use this scoring method.\nFinally, I came up with my own scoring method that makes a “bet” between $0 and $100 based on prediction confidence. 100% confidence would turn into a $100 bet, and 50% confidence (aka, a coin toss) would be a $0 bet. Each model’s average winnings (including losses) is reported as the score.\nI scored a few prominent presidential forecasts based on the above methodologies (you can read more about the JHK, Economist, FiveThirtyEight, and Bitecofer forecasts at the links here). While all the scoring methods are similar - rewarding confidence in correct predictions and penalizing meek or incorrect predictions - each model’s performance is all over the map (with perhaps the exception of Bitecofer, which scores in the lower half of all methods). But does that mean these methods are useless? No! If anything, it highlights the importance that each forecast method’s performance should be scored across a wide variety of scoring methodologies. While it might not make a huge difference at the margins, it may separate some models as clearly ahead or behind the curve.\nSo, how does each forecast model measure up? It depends on which yardstick you use!\nHere are some other things to consider with regards to each model:\n\rUnlike the Economist, FiveThirtyEight, and Bitecofer models, which simulate each state’s outcome thousands of times and reports the confidence as the percentage of simulations won, the JHK forecast reports the percentage of winning results that fall within the 80% confidence interval around the expected vote. Lower confidence intervals result in tighter bands, so this relatively low confidence interval means that the model is allowed to make quite a few 100% confident predictions (which, luckily for the model, all came true in this case).\rThe Bitecofer forecast is the only model that doesn’t utilize polls and instead uses an in-house developed negative-partisanship model.\rBased on conversations between Nate Silver of FiveThirtyEight and Elliott Morris of the Economist, it appears that FiveThirtyEight added a bit of uncertainty ad-hoc to account for COVID, whereas the Economist did not.\r\rAs always, source files and code can be found on github. Next week, I plan on making a relatively modest prediction of the election’s popular vote outcome based on polls from the final week.\n\r","date":1613260800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1613353654,"objectID":"05bdc3783344d04ef854139107cbb69b","permalink":"https://www.thedatadiary.net/blog/2021-02-14-scorecasting/","publishdate":"2021-02-14T00:00:00Z","relpermalink":"/blog/2021-02-14-scorecasting/","section":"blog","summary":"A baseball forecast that correctly predicts the winner of the 15 opening day games could be a truly accurate model, or could just be getting lucky. Over the course of 6 months and 2,430 regular season games, however, a great forecast will continue to shine whereas an initially lucky one will falter.","tags":[],"title":"Scorecasting","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rRather than diving deep into a topic this week, I took a bit of a break to focus on playing catchup with the stats course I’m taking. Instead, I’ve listed out below a number of creators that I follow on various platforms. If you’re interested in data or critical thinking, each is well worth your time and attention.\nNewsletters\r\rFiveThirtyEight : While it’s not technically a newsletter, the FiveThirtyEight site, created by statistician Nate Silver prior to the 2008 presidential election, is the original source for data-driven news (or, at least, one of the first sites to popularize data as a news resource). Nate created the site specifically because the narrative created by pundits, that the 2008 election was super close, was pretty easily refutable when you looked at the polling data, which showed that Obama was going to win handily. Now, FiveThirtyEight is a powerhouse of data analysis for politics, sports, and science, and often serves as a good reality check against the narratives espoused by talking heads on the major news networks.\n\rG. Elliott Morris’ Newsletter : G. Elliott Morris is a data journalist for the Economist and created their forecast for the 2020 presidential election. In addition to regularly writing for the Economist, Elliott also writes a weekly newsletter in which he comments on polls that caught his eye (he also has a subscriber newsletter, for those who want to get his thoughts on even more topics). Elliott is also writing a book on the history of public polls, their limitations, and their future in American politics, which I am looking forward to reading when it releases later this year.\rAs an aside, Elliott and I are the same age, and he was a large part of the inspiration for me to start diving into statistics again (i.e., if he can do it, so can I). Elliot is pretty bearish on the future of American democracy, especially following Donald Trump’s repeated attempts to overturn the overwhelmingly clear and overwhelmingly fair results of the election and the attempted (but, thankfully, woefully unorganized) coup by insurrectionists on Jan. 6th. Despite all this, I’m a bit more hopeful for the future of democracy, and hope to be able to provide a more positive opinion alongside Elliott’s (provided it’s supported by the data!).\rInfinite Monkeys : Started by a collection of college students who met via #ElectionTwitter, the Infinite Monkeys newsletter (named such from the theory that, an infinite collection of monkeys hitting keys on typewriters will eventually write the entirety of Shakespeare’s work by random chance) take a look at geographical trends and their relation to current political headlines. It’s a relatively recent startup, and I’m looking forward to the development of the newsletter \u0026amp; its coalition of authors over the coming years.\rVisual in the Noise : The Visual in the Noise is a weekly newsletter focused on data visualization. Most often looking at sports (particularly, NBA) data, the Visual in the Noise is a great touch-point for the importance of visualization and how it can help make data more insightful.\r\r\rPodcasts\r\rThe Daily : The Daily is, appropriately, a daily (Mon. - Fri.) podcast hosted by the New York Times, covering important topics in the American landscape. The podcast generally focuses in on individuals, and how national stories can affect people personally (for example, touching base with a bar throughout the pandemic as they wade through the difficulties of diminished business, PPP applications, and unclear direction from the government). On Sundays, a guest reads an older, long form New York Times piece.\rThe Intelligence : The Intelligence, similarly to the Daily, is a daily weekday podcast covering important topics in the news, though typically has a more global focus than the Daily. Rather than following individuals, the Intelligence often brings in subject matter experts and local correspondents.\rChecks and Balance : This weekly podcast by the Economist takes a deep dive into one big topic shaping American politics each week. Approximately 45 minutes per podcast, the Checks and Balance hosts take care to thoroughly explore each topic.\rFiveThirtyEight’s Politics Podcast : Every week, the FiveThirtyEight team covers the latest news in politics, utilizing polling data to guide their discussion. During election years, they also host intermittent “Model Talks,” where Nate Silver talks about into some of the intricacies of the site’s forecast models based on questions from listeners.\n\rThe Rational Reminder : A non-politics podcast, the Rational Reminder is a weekly podcast discussing index investing and rational decision making. Although the podcast is made by and for Canadians, most of the content is widely applicable, and the podcast has garnered an international audience.\r\r\rYouTube\r\r3blue1brown : Many concepts in math can feel daunting and teaching methods are often unintuitive. Grant Sanderson’s channel attempts to introduce viewers to the beauty of math through intuitive visualizations and animations. As a fun fact, the animations are run via a python package, manim, developed on-the-fly by Grant himself!\rPhilip DeFranco : One of the original members of the YouTube community, Phil has grown from a weekly commentary on popular videos via a webcam in his bedroom to a daily rundown of the news backed by a full production staff. Phil does an excellent job of presenting the news whilst making it clear where the official reporting stops and his opinion starts.\rLegal Eagle : Dubbed “YouTube’s Lawyer,” Devin (DJ) Stone provides a perspective on the role the law plays in current events and controversies (as well as more fun videos, like reviewing a Spongebob episode for legal accuracy). I’m not sure how he manages to balance the two full time jobs of running channel with near-daily longform content and being a lawyer with active litigation, but I appreciate that he is able to find time for thoughtful (and often comedic) insight.\n\rCommon Sense Investing : Ben Felix’s Common Sense Investing investigates the academic research supporting passive, rather than active, portfolio management (in summary: the data shows that passive index investing is overwhelmingly a more effective long term investment strategy than trusting an active portfolio manager with your money).\rStandup Maths : Mathematician, comedian, and Excel-enthusiast Matt Parker shares the joy that can be found in math by exploring topics in a comedic setting. Matt’s book, Humble Pi, explores some of history’s most famous mathematical blunders, and is coming up soon on my reading list.\rNumberphile : The Numberphile channel is a collection of interviews of prominent mathematicians explaining interesting historical math problems on trademark brown parchment paper. Grant Sanderson and Matt Parker make appearances on the channel a number of times (the infamous Parker square first made its appearance on Numberphile).\rMinutePhysics : As Henry Reich, the channel owner, puts it, the channel is simply about “cool physics and other sweet science.” Henry’s videos explain concepts in physics via a whiteboard, expo markers, and a backdrop of jazzy standup bass.\r\r\rElection Twitter\rThere are quite a few, so I’ll just highlight a few \u0026amp; link ot the rest\n\rLakshya Jain : Lakshya is a software engineer and self-described amateur elections mapper/analyst. He’s a very vocal (and self-labeled) partisan democrat, so I take his non-analytical posts with a grain of salt, but his analytical posts are very insightful.\rJack Kersting : A relative rarity on Election Twitter, Jack is a conservative forecaster. He’s not an ardent twitter user, but developed one of the most complete and thorough election forecasts I’ve seen outside of professional work.\rMax : A self described mapmaker, shitposter, and ardent supporter of Long Nebraska, Max is known for his oddball posts and lukewarm political takes.\rSome other folks I follow for election maps/data: Nate Silver, G. Elliott Morris, U Mich Voter, and Sam\r\r\r","date":1612742400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1612834633,"objectID":"e720b186b65ecca0eaf1984dcd4d2398","permalink":"https://www.thedatadiary.net/blog/2021-02-08-some-worthwhile-links/","publishdate":"2021-02-08T00:00:00Z","relpermalink":"/blog/2021-02-08-some-worthwhile-links/","section":"blog","summary":"Rather than diving deep into a topic this week, I took a bit of a break to focus on playing catchup with the stats course I’m taking. Instead, I’ve listed out below a number of creators that I follow on various platforms.","tags":[],"title":"Some Worthwhile Links","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rOn January 26, House Democrats introduced a bill to raise the federal minimum wage from $7.25 per hour to $15 per hour by 2025. In the weeks leading up to the introduction, there’s been an influx on twitter of bad faith attacks, outright factually incorrect statements, and the type of fact-free arguments that pundits love (to be fair, my twitter timeline is biased towards my left-leaning friends, so the majority of what I see are poorly formulated left-leaning takes, but it’s pretty easy to find similarly bad right-leaning takes). The slew of emotion-driven arguments muddies the water around the minimum wage discussion by avoiding references to data. In an effort to find the signal in all this noise, I dug into publicly available databases to hopefully provide at least one opinion grounded in empiricism, rather than emotion.\nMy Priors\rFor transparency’s sake, prior to taking a look into the data behind the minimum wage debate, I was of the belief that the minimum wage should increase and that the proposed $15 per hour seemed reasonable. I didn’t have an empirically driven reason for this belief, just a vague sense that the minimum wage hadn’t risen in a while and had therefore effectively been deflating. Anecdotally, I also hadn’t seen a good defense of keeping the minimum wage static (in fact, most of the arguments against raising the minimum wage that I’d seen were laughably bad). My prior was built on little data, so the analysis I set out to do would either strongly confirm or refute it.\n\rThe History of the Minimum Wage\rIn 1947, the federal government introduced a minimum wage for hourly-compensated labor as part of an amendment to the Fair Labor Standards Act (FLSA). First set at $0.40 per hour, the minimum wage has risen periodically throughout its 80 year history - most recently rising to $7.25 per hour in 2009. Currently, 29 states and D.C. have state minimum wages greater than the minimum wage, and several state minimum wages are increasing in 2021 (either due to ballot initiatives or automatic increases based on cost of living).\nI’ve seen a theory float around that, had the minimum wage risen with inflation, it would be $22 per hour today, rather than $7.25 per hour. This is pretty overtly false.* Using the consumer price index (CPI) as the standard measure of inflation, the nominal minimum wage throughout the years can be adjusted to real (aka, inflation-adjusted) dollars:\nIn inflation-adjusted terms, the minimum wage peaked around 1968 at $12.20 per hour ($1.60 per hour, unadjusted). The current minimum wage of $7.25 per hour, while on the lower end of inflation-adjusted historical values, is not the lowest it’s ever been, and a $15 per hour minimum wage would set a new record for both adjusted and unadjusted minimum wage. Critics of the proposed increase may point to this as reason to keep the minimum wage at its current value - why increase the minimum wage beyond its historical high if it hasn’t even reached its historical low? Supporters, on the other hand, may argue that the minimum wage has never been enough.\n\rThe Minimum Wage’s Dance Between Two Thresholds\rIn 1978, the Census Bureau and Department of Health and Human Services set a baseline administrative threshold to determine eligibility for financial assistance from the federal government. Dubbed the “poverty threshold,” this value was created based on an approximation of the annual budget various family units require to meet basic food \u0026amp; shelter needs (for example, a single adult with no children would need to earn less per hour to meet his needs than, say, a nuclear family of two working adults and two children). The Census Bureau updates the threshold annually by simply adjusting for inflation.\nMany groups, however, argue that the poverty threshold doesn’t meet basic needs and instead advocate for a living wage. The living wage is similar in concept to the poverty threshold, but generally much higher, as it includes an expanded food budget (the poverty threshold is based on USDA’s “thrifty” food plan), a budget cap on rent (generally set at ~30% of a monthly budget), healthcare, and childcare, amongst other additions.\nBased on MIT Lab’s Living Wage Calculator, we can see that, for a family of four with two working adults, the minimum wage has historically been marginally greater than the poverty threshold, but never reaches (or approaches) the living wage:\nFigure 2, above, shows the national minimum and living wages, but these values vary by location. Figure 3 below shows the minimum and living wages for each state. Even states with minimum wages greater than the federal minimum do not meet the local living wage:\n\rThe Proposed Increase\rSo how does the proposed increase to the minimum wage fare against the living wage and poverty threshold in the future? If inflation continues to hold at about 1.6%, the increased minimum wage will get significantly closer to, but not greater than, the living wage in 2025.\nIs this enough? Arguably, no, as the proposed increase is less than the estimated living wage. But it is certainly a step in the right direction, and if passed, would likely keep the minimum wage above the poverty threshold for quite some (the poverty threshold rises roughly at a rate of $1 per hour every 10 years).\n\rMy Posterior\rIn general, my prior was confirmed by the analysis - my belief that the minimum wage should be increased has strengthened, and there’s a believable argument that the $15 per hour increase could be raised even higher. There are some additional points that I didn’t discuss above, however, that are still worth noting:\n\rThere are many different groups that have estimated living wages, and results can vary (I used MIT Lab’s data because it was the most readily available \u0026amp; also provided state, county, and metropolitan level data). In general, however, living wage estimates agree that the poverty threshold is far too low, and typically show living wages in excess of $15 per hour.\rThe percentage of hourly workers earning the federal minimum wage (or less) has decreased over the years and currently rests at about 1.9%. This is in part due to many states having minimum wages greater than the federal minimum. If the minimum wage increases to $15 per hour, the total number of workers earning the federal minimum wage will likely increase (the linked chart shows spikes that correspond to minimum wage increases in the ‘90s and 2009).\rSome critics of the increased minimum wage argue that the minimum wage is only meant for teenagers working summer jobs. The data doesn’t support this argument - over 80% of federal minimum wage workers are 20+ years old.\rIn 2019, the Congressional Budget Office released a report that estimated that job losses due to an increased minimum wage could range between 4.7 million and 0, with a median of 1.3 million lost jobs. The report also notes, however, that about 17 million workers would benefit from the wage increase.\r\rThe linked NYT opinion article does give itself the caveat that the $22 per hour figure is based on “inflation and productivity,” though others have repeated this $20+ per hour wage argument without this caveat. The opinion article doesn’t mention any sources or databases, though I expect that the author is using GDP as a proxy for inflation - several articles point out that if the minimum wage had kept pace with GDP growth since 1968, it’d be significantly greater than even the proposed $15 per hour minimum wage. Correlating this to inflation, however, is at best a significant oversight by the author/editor, and at worst intentionally deceptive.\n\rSome Other Notes\rAs always, source data for this post can be found on github. I made an overt attempt to keep the code a bit cleaner this time around (having a “test area” in the code helped out). It’s still not perfect, and I suspect I’ll just naturally get better at writing neatly formatted scripts as the language becomes more intuitive.\nI think I’m going to take a break for a couple weeks from some of these longer posts - I’m currently finishing this a bit after midnight (which is very late for me!) - and between writing this \u0026amp; the Bayes’ Theorem post, I’ve had little time to dedicate to stats. Next week, I’ll put together a less intensive piece to give myself time to push forward with the stats class. Maybe after that I can write a quick post about the accuracy of prediction models, then get into another deep dive. We’ll see how I feel about it in the next couple weeks.\n\r","date":1612051200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1612142350,"objectID":"d15ab6af99788899a9f47dec45d4f210","permalink":"https://www.thedatadiary.net/blog/2021-01-31-the-min-wage-debate/","publishdate":"2021-01-31T00:00:00Z","relpermalink":"/blog/2021-01-31-the-min-wage-debate/","section":"blog","summary":"On January 26, House Democrats introduced a bill to raise the federal minimum wage from $7.25 per hour to $15 per hour by 2025. In the weeks leading up to the introduction, there’s been an influx on twitter of bad faith attacks, outright factually incorrect statements, and the type of fact-free arguments that pundits love (to be fair, my twitter timeline is biased towards my left-leaning friends, so the majority of what I see are poorly formulated left-leaning takes, but it’s pretty easy to find similarly bad right-leaning takes).","tags":[],"title":"The Min-Wage Debate","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rThere’s a great standup routine about doctors (which I spent about an hour trying to find online with no luck!) with a punchline to the effect of, “getting a positive cancer test then requesting a second opinion is basically the medical equivalent of telling your doctor you think they’re an idiot to their face.” The joke makes sense in context (and is a lot funnier to hear, rather than read), and is logical at a general level (why would a patient, who probably isn’t a medical expert, be able to say that a doctor’s assessment is wrong?), but there’s a hidden nugget of nuance about cancer screenings missed by the joke that make them such an interesting introduction to one of the foundational equations in statistics, Bayes’ Theorem.\nWhat is Bayes’ Theorem?\rTo understand Bayes’ Theorem, it’s probably best to get a grasp on frequency-based probability, which is often considered the contrast of bayesian/uncertainty-based probability. Consider a perfectly ideal coin flip. I know that, for any given coin flip, the probabilities of landing either heads-up or tails-up are exactly the same: 50%. Moreover, this is true no matter how many times I flip the coin. If the coin lands heads-up on the first flip, I still have a 50% chance of the coin landing heads-up on the next flip (and the next flip, and the next flip, etc.).\nBut what if I’m told the coin has a manufacturing defect, and is slightly heavier on one side (lets say, to favor tails-up)? I might assume, starting out, that the defect is small, and has a negligible effect on my odds of the coin landing heads-up. But every flip that lands tails-up changes my certainty about the true odds. That’s the heart of Bayes’ Theorem, and the biggest difference between bayesian statistics and frequentist statistics. With frequentist statistics, when the data updates, the uncertainty stays the same, whereas with bayesian statistics, when the data updates, the uncertainty updates as well.\nSo why is this important? Well, at a base level, just about every forecasting model needs to make use of Bayes’ Theorem. So with the long term goal of building a predictive election model, it’s pretty dang important to have a firm understanding of the foundation the model will rest on. But in a more general sense, I think it’s important to understand how views can (and should) update in the light of new data. From what I can tell, the majority of opinions (especially political opinions…) are either based on assumptions or cherry-picked data points, and typically don’t update - even when presented with new evidence. In contrast, to think like a bayesian is to weigh the severity of new information against the history of data and update your views accordingly.\n\rUgly vs. Pretty Bayes\rEquation 1 above shows Bayes’ Theory. As expressed in statistical language, it reads, “the probability of A, given event B, is equal to the probability of B, given event A, and the probability of A divided by the probability of B.” As written, Bayes’ Theorem is… unintuitive… Even reading the description back to myself stirs up memories of fumbling through my high school stats class. The way the equation is written doesn’t lend itself towards being accessible, but, as Grant Sanderson points out in this video, reframing the equation into a geometry problem makes Bayes’ Theorem much easier to understand (much of the rest of this post is applying Bayes’ Theorem via Grant’s geometrical framing).\nTo understand how a geometrical framing can help make sense of Bayes’ Theorem, it’s best to run through an example. So let’s get back to the doctor’s office \u0026amp; cancer screening.\nLet’s first consider a population group of 10,000, arranged on a grid of 100 x 100. If we know that 1% of the population has cancer, we can divide the group into two segments, cancer-free and cancerous, as shown below:\nIf we avoid any compounding risk factors (like age, sex, diet, etc.) \u0026amp; assume that the likelihood of having cancer is the same for everyone, any person in the population can say that they are 99% certain that they do not have cancer. But how might this certainty update for someone who gets a positive result from a cancer screening test?\nThe reliability of cancer screening tests are measured by their sensitivity \u0026amp; specificity. A test’s sensitivity is the the proportion of cancer-positive patients it correctly identifies (i.e., “true positives”). For example, if a screening test has a sensitivity of 90% and is used to test 100 cancerous patients, we’d expect 90 of these patients to receive a correct positive result and the remaining 10 patients to receive an incorrect negative result. The specificity, on the other hand, is the proportion of cancer-free patients the test correctly identifies. If the screening test’s specificity is 92% and is used to test 100 cancer-free patients, we’d expect 92 patients to correctly receive a negative result and 8 patients to incorrectly receive a positive result (a “false positive”). I tend to find it easier just to think about the positive cases, so from now on, I’ll refer to a test’s true positive rate and false positive rate, rather than the sensitivity \u0026amp; specificity.\nLet’s assume that a cancer screening test has the true positive \u0026amp; false positive rates above, 90% \u0026amp; 8%, respectively. How certain should someone who tests positive be that they truly have cancer? A test that gives a true positive 90% of the time seems pretty damning, but the 8% false positive rate isn’t insignificant. An important step is to realize that this person is no longer looking for the probability of having cancer, but instead looking for the probability of having cancer given that they have a positive test result.\nFor someone who receives a positive test result, it may be helpful to think about the hypothetical question: “What if everyone took this test?” This reframing can help us think in terms of people, rather than probabilities.\nGiven that 1% of the 10,000 person population has cancer, we can divide the group into two segments: 100 people with cancer, and 9,900 people without cancer.\nIf everyone takes the screening test, we’d expect 90 true positives (90% x 100 = 90) and a whopping 792 false positives (8% x 9,900 = 792)!\nAlthough the test is fairly accurate in terms of sensitivity \u0026amp; specificity (90% and 92% are both considered A’s, by most grading standards) the sheer number of non-cancerous people in the population results in a large number of false positives. Of all the 882 positive cases (792 + 90 = 882), only 90 are true positives, meaning that the probability of having cancer given a positive test result is about 10% (90 / 882 = 10.2%). While this is a significant increase from the prior assumption, 1%, it’s still far likelier that someone with one positive test result doesn’t have cancer. This is why it’s important to get a second opinion. It’s not that your first doctor is an idiot, just that your uncertainty has changed!\nNow what would happen if all the people who received a positive result took another test? Well, of this subset of 882 patients, we expect that 792 are cancer free and 90 are cancerous:\nWhen these 882 patients take the second test, we still expect the test to hold the same true positive \u0026amp; false positive rates - meaning we can expect 81 true positives (90% x 90 = 81) and about 63 false positives (8% x 792 = 63). This means that, of the 144 positive cases (81 + 63 = 144), 81 are true positives, and the probability of having cancer given two positive results is about 56% (81 / 144 = 56%).\nWith this new round of data from test results, those who receive a second positive result once again update their prior assumption from 10% to 56%. In fact, every test result, positive or negative, should either support or refute the prior. Each positive test result, appropriately, increases your likelihood of actually having cancer. Similarly, each negative result decreases your likelihood.\nThat’s the beauty of Bayes’ Theorem in a nutshell. Gathering new information allows you to update your prior belief!\n\rIn Summary…\rI may have gotten too in the weeds with this post, though, to be fair, walking through Bayes’ Theorem in detail also helps my understanding. I likely wont dive as deep into stats topics in the future. In part, they’re a bit of a slog to read through if you’re not as excited as I am by this kind of stuff. But it also took me a good chunk of time to write this post. Going forward, I’d like to better balance my time between the three goals of coding, writing, and learning stats.\nAs always, I’ve posted my work to github, though this file just includes an excel workbook \u0026amp; a few pictures. Next week, I’ll dig more into plotting with ggplot - likely with a much shorter post!\n\r","date":1611446400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1611536691,"objectID":"9fbe18bdedc46397a2c4f3fc14bde0ba","permalink":"https://www.thedatadiary.net/blog/2021-01-24-your-doctor-probably-isn-t-an-idiot/","publishdate":"2021-01-24T00:00:00Z","relpermalink":"/blog/2021-01-24-your-doctor-probably-isn-t-an-idiot/","section":"blog","summary":"There’s a great standup routine about doctors (which I spent about an hour trying to find online with no luck!) with a punchline to the effect of, “getting a positive cancer test then requesting a second opinion is basically the medical equivalent of telling your doctor you think they’re an idiot to their face.","tags":[],"title":"Your Doctor Probably Isn't an Idiot","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rEditor’s note: I’ve gone back \u0026amp; read my previous post, \u0026amp; have one general thought - yeeeesh… Everything is so… “matter of fact” in tone \u0026amp; doesn’t really sound like me. I’ll give myself a pass, since it was the first post, was written around midnight (which is very late for me!), and probably won’t ever be read by anyone besides me/my mom (hi mom!). That being said, I’m going to try to make a more conscious effort going forward of having my voice be expressed in my writing. This is my blog, after all, so it should sound like my voice when read back.\nPlotting in R\rI’ve started getting more familiar with R \u0026amp; wrangling my way through a few plotting examples (Youtube university is, once again, my best friend), but I thought it would be worthwhile to work towards plotting my own dataset. Luckily enough, plotting with R is pretty intuitive, once you get ahold of the basic syntax. I had put together a dataset on past US presidential elections for a separate personal project, and was able to convert to a .csv to use for some basic plotting practice.\nIt’s generally well understood that the Republican party has a structural advantage in presidential elections due to the winner-take-all nature of the electoral college, but I wanted to see if I could quantify this advantage in an understandable format using R. I used the ggplot2, dplyr, and plotly packages to put this together.\n\rPutting Together the Plot\rI imported the entire dataset and assigned it to a dataframe (R’s version of, say, an excel table). Using the base R plot() function, I plotted the entire dataframe:\nWithout specifying which variables I want to look at, plot() will output a set of summary plots, with every variable plotted against every other variable. This isn’t great for gathering any meaningful insight, but helps get a “lay of the land” view of the dataframe. In this case, I’m interested in how the percentage of the popular vote a candidate wins is related to the percentage of the electoral vote they win. Using plot(), I can graph popular_vote_pct and electoral_vote_pct variables from the dataframe:\nFigure 2 shows the basic data I want to represent, but there’s a lot of noise. The dataset includes every major candidate in every election since Washington’s run for re-election in 1788. I’m really only interested in the modern two-party system, so I filtered out the elections prior to 1952, as well as any candidate that won 0 electoral votes (i.e., third parties). The new, filtered plot is shown in Figure 3, below:\nNow, with all the data manipulation squared away, I can start with the fun part: making it look good! ggplot’s base plot is, right off the bat, just a bit nicer looking than base R’s plot() function:\nggplot color maps very easily, and with a little googling (aka - jumping through multiple color converters online to convert colors from hexadecimal to rgb to hcl), I was able to make some formatting changes that give the below static chart:\nDespite some frustrations (more on that, below), I was able to add a simple linear regression to the plot, with the shaded bands representing the 95% confidence interval for each regression. Since the Republican regression is above the Democratic regression, the chart implies that, for a given share of popular vote, Republican candidates on average win a larger share of the electoral college than their Democratic counterparts.\nThis finding matches the general consensus and my prior expectations, but I also found something mildly surprising. Ideally, I would imagine, we’d want a candidate’s share of the electoral vote to match their share of the popular vote. However, if I add a reference line of y = x, we can see that both parties tend to underperform in the electoral college when they lose the popular vote, but overperform in the electoral college when they win the popular vote!\nI plotted the absolute vote share from published election results, rather than the two-party vote share (2PV) (i.e., the percentage of vote won if only the top two candidates are considered). Converting to the 2PV would shift the plot to the right, but keep the same overall trend, as Democrats and Republicans have won 100% of the electoral college since 1952. This exercise was more about exploring R’s ggplot() function, so going back into the dataset to account for this marginal change doesn’t seem like an efficient use of time, but I did want to make a note of it, for transparency’s sake.\nFinally, I used the ggplotly() to convert from a static ggplot to an interactive plotly, and exported as an html file. For reasons I’ve yet to figure out, the custom textbox formatting did not want to play nice with the linear regression lines, so I had to take those out. I plan on figuring this wrinkle out eventually, but for now I’m happy with the final plot. You can hover over individual datapoints below to see more details!\nThis is an archive of a post previously hosted on Squarespace. You can view the original interactive content here.\n\rSome Notes\rI’ve published all of my work to github, and I’ll continue to do so in the future. The files I uploaded are, to say the least, in pretty rough shape. That being said, I don’t really plan on tweaking them for this post - I’ve used them as training tools, and it might be interesting in the future to look at the progress I’ve made.\nAlso, I just realized that the interactive plotly chart looks like junk when viewed via mobile (the data points and labels don’t resize automatically). I’ll have to figure out a way to fix this in the future… Maybe I can set the point size as a ratio of the plot width? It’s something to think about, but again, I’m happy with my first run using ggplot \u0026amp; plotly.\n\r","date":1610841600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1610930999,"objectID":"c764a59b339cadbd0f0e6af9abe33efc","permalink":"https://www.thedatadiary.net/blog/2021-01-17-r-ggplot2-plotly/","publishdate":"2021-01-17T00:00:00Z","relpermalink":"/blog/2021-01-17-r-ggplot2-plotly/","section":"blog","summary":"Editor’s note: I’ve gone back \u0026amp; read my previous post, \u0026amp; have one general thought - yeeeesh… Everything is so… “matter of fact” in tone \u0026amp; doesn’t really sound like me.","tags":[],"title":"R, ggplot2, \u0026 plotly","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rAn Uphill Battle\rToday marks the beginning of what I imagine will be a long journey, with a significant number of hiccups \u0026amp; frustrations along the way. The end goal I have is to build out an election forecast model (in the spirit of FiveThirtyEight \u0026amp; The Economist), but along the way, I plan on getting better at a few things:\n\rWriting : while I’ve never been a poor writer, I’ve always gravitated more toward math \u0026amp; science, \u0026amp; in my career as an engineer, a good amount of my communication has been visual. If possible, I’ve always preferred to leave words off the page \u0026amp; have a chart speak for me. While I still think that, in general, its better the explain a concept visually (a picture vs. a thousand words, and all), I also believe supplementing a visual with my a well written analysis \u0026amp; opinion can improve its reception.\rStats : in my current job, almost everything I model is deterministic, rather than probabilistic (physical systems tend to behave the way that natural laws expect them to). It has been a long time since I’ve done any sort of stats work (\u0026amp; it was all basic introductory analyses), so I expect an uphill battle with getting my head wrapped around Bayes’ Theorem, Monte Carlo simulations, Brier’s Tests, etc.\rCoding : most of my experience in coding is with VBA - typically just for manipulating data in Excel. I’ve built out a good number of forms using VBA, but don’t typically tend to dig into anything far beyond simple manipulation. The front end of Excel is effectively setup as a visual programming tool, so there’s not a great incentive to do much array manipulation outside of the spreadsheet. Excel is a wonderful tool, \u0026amp; is sufficient for my current job, but I’ve definitely found where its limits lie. I’m excited to dig into R, the stats based program that seems almost to be designed specifically for what I’d like to do.\r\r\rThe First Plot\rR has a few sample datasets, and r:base includes a pretty basic plot function. With the sample set, cars, I made a quick plot of the stopping distance vs. the speed.\nplot(cars)\r\r","date":1610236800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1610325814,"objectID":"b0102d49dafb9affa54974fef13cf93c","permalink":"https://www.thedatadiary.net/blog/2021-01-10-baby-steps/","publishdate":"2021-01-10T00:00:00Z","relpermalink":"/blog/2021-01-10-baby-steps/","section":"blog","summary":"An Uphill Battle\rToday marks the beginning of what I imagine will be a long journey, with a significant number of hiccups \u0026amp; frustrations along the way. The end goal I have is to build out an election forecast model (in the spirit of FiveThirtyEight \u0026amp; The Economist), but along the way, I plan on getting better at a few things:","tags":[],"title":"Baby Steps","type":"blog"},{"authors":[],"categories":["archive"],"content":"\r\rI’m currently setting up the website \u0026amp; will have an official post soon(ish).\n","date":1610150400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1610239193,"objectID":"67358b168eae89029f996cc40c3a61ab","permalink":"https://www.thedatadiary.net/blog/2021-01-09-hello-world/","publishdate":"2021-01-09T00:00:00Z","relpermalink":"/blog/2021-01-09-hello-world/","section":"blog","summary":"I’m currently setting up the website \u0026amp; will have an official post soon(ish).","tags":[],"title":"Hello World!","type":"blog"},{"authors":null,"categories":null,"content":"","date":1577836800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577836800,"objectID":"8576ec274c98b3831668a172fa632d80","permalink":"https://www.thedatadiary.net/about/","publishdate":"2020-01-01T00:00:00Z","relpermalink":"/about/","section":"","summary":"About","tags":null,"title":"About","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":1577836800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577836800,"objectID":"936dab1a601b52ff11705e6950a1da2b","permalink":"https://www.thedatadiary.net/governor/","publishdate":"2020-01-01T00:00:00Z","relpermalink":"/governor/","section":"","summary":"Midterms","tags":null,"title":"Midterms","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":1577836800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577836800,"objectID":"8baae4882adaaa3a9db779745d97b8ea","permalink":"https://www.thedatadiary.net/house/","publishdate":"2020-01-01T00:00:00Z","relpermalink":"/house/","section":"","summary":"Midterms","tags":null,"title":"Midterms","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":1577836800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577836800,"objectID":"8addddcb2fbe4e27a8b941439dbbe02b","permalink":"https://www.thedatadiary.net/senate/","publishdate":"2020-01-01T00:00:00Z","relpermalink":"/senate/","section":"","summary":"Midterms","tags":null,"title":"Midterms","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":1577836800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577836800,"objectID":"3960dd3bdc6f629fb800d1d2aaa7224f","permalink":"https://www.thedatadiary.net/resume/","publishdate":"2020-01-01T00:00:00Z","relpermalink":"/resume/","section":"","summary":"Resume","tags":null,"title":"Resume","type":"widget_page"}]