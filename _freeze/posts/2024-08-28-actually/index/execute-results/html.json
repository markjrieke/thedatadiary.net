{
  "hash": "c26fcda1db1a7ed3ca0ed98732bfa2bc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Um, Factually\"\ndate: '2024-09-15'\ncategories: [stan, dropout]\ndescription: \"A power ranking for the title of most pedantic nerd on Dropout's *Um, Actually*\"\nimage: header.png\nfilters:\n  - add-code-files\n---\n\n::: {.cell}\n\n```{.r .cell-code}\n# libraries\nlibrary(tidyverse)\nlibrary(riekelib)\nlibrary(cmdstanr)\n\n# import um actually episode-level data\nactually <- \n  jsonlite::fromJSON(\"https://raw.githubusercontent.com/tekkamanendless/umactually/master/data.json\") %>%\n  map_if(is.data.frame, list) %>%\n  as_tibble()\n\n# individual contestants\npeople <- \n  actually %>%\n  unnest(people) %>%\n  select(id, name) %>%\n  rowid_to_column(\"pid\")\n\n# pre-season 9 episodes\nepisodes <-\n  actually %>%\n  select(episodes) %>%\n  unnest(episodes) %>%\n  select(eid = dropouttv_productid,\n         season = season_number,\n         episode = number,\n         players,\n         questions) %>%\n  filter(season <= 8)\n```\n:::\n\n\n\n\n> Um, Actually: A game show of fandom minutiae one-upmanship, where nerds do what nerds do best: flaunt encyclopedic nerd knowledge at Millennium Falcon nerd-speed.\n\n## Introduction\n\n*Um, Actually* is a trivia game show found on [Dropout](https://signup.dropout.tv/), wherein contestants are read false statements about their favorite pieces of nerdy pop culture and earn points by figuring out what's wrong.^[But they only get the point if they precede their correction with the phrase \"um, actually...\"] After 8 seasons, longtime host [Mike Trapp](https://x.com/MikeWTrapp) and his omnipresent fact-checker [Michael Salzman](https://x.com/justaddsaltz) have relinquished their hosting and fact-checking duties. [Ify Nwadiwe](https://x.com/IfyNwadiwe) and [Brian David Gilbert](https://x.com/briamgilbert) take up the mantle as host and voluntary-live-in-fact-checker in season 9.\n\nIfy's ascendancy to host comes in the wake of an impressive run as a contestant. Ify currently holds the title of *winningest contestant*, with a whopping 9 total wins over the course of the first 8 seasons.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nepisodes %>% \n  unnest(players) %>%\n  group_by(season, episode) %>%\n  filter(score == max(score)) %>%\n  ungroup() %>%\n  count(id) %>%\n  arrange(desc(n)) %>%\n  left_join(people) %>%\n  slice_head(n = 10) %>%\n  mutate(name = fct_reorder(name, n)) %>%\n  ggplot(aes(x = name,\n             y = n)) + \n  geom_col(fill = \"royalblue\",\n           alpha = 0.85) + \n  geom_text(aes(label = n),\n            nudge_y = -0.3,\n            family = \"IBM Plex Sans\",\n            fontface = \"bold\",\n            color = \"white\",\n            size = 5) + \n  scale_y_continuous(breaks = c(0, 5, 10),\n                     minor_breaks = 0:10) + \n  coord_flip() +\n  theme_rieke() + \n  labs(title = \"**Um, Actually leaderboard**\",\n       subtitle = \"Total wins per contestant in seasons 1-8\",\n       x = NULL,\n       y = NULL,\n       caption = \"Excludes team games. First place ties<br>count as a win for both contestants\") + \n  expand_limits(y = c(0, 10))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/win-tally-1.png){width=2700}\n:::\n:::\n\n\n\nBut does *winningnest contestant* automatically confer the title of *most skilled player?* As Ify is oft lauded as the best Um, Actually player, there's an implicit assumption that win count is the best metric for measuring player skill. But by other metrics, you might conclude that other players are better. [Jared Logan](https://x.com/LoganJared), for example, has a perfect win record across three appearances on the show; [Brennan Lee Mulligan](https://x.com/BrennanLM) has the highest proportion of points-earned to questions-asked; and Jeremy Puckett^[A fan contestant on Season 1 Episode 32] holds the record for most points in a single game (9).^[Ify was a contestant on this episode and received only one point.]\n\nOverall, using win count to measure the best Um, Actually player brushes away a few important factors:\n\n* contestants who appear on the show more often have more opportunities to rack up wins;\n* winning by many points is more impressive than eeking out a 1-point win;\n* a contestant's point total is not independent of other contestants' skill.\n\nA better method for measuring player skill would instead consider the points won by each contestant while taking into account the relative skill of the other players in each game. In the pedantic spirit of the game, I propose one such alternative method. By estimating latent player skill with a hierarchical Bayesian model, I uncover who, statistically, is the best Um, Actually player.\n\n::: {.callout-note}\n\nIf you're just here to see the results and power ranking of each contestant, you can [skip to the end] LINK HERE DAWG. Otherwise, strap in for the cacophony of math and code used to develop the rankings.\n\n:::\n\n## The rules of the game\n\nBefore diving headfirst into the results or the code to generate them, it's probably helpful to explain in detail how the game works. In each episode, three contestants vie to earn points by identifying the incorrect piece of information in a statement read by the host. Contestants buzz in to propose their corrections, and must begin their statement with the phrase \"um, actually...\". If their correction is, paradoxically, incorrect, or if they forget to say \"um, actually,\" the other contestants can buzz in to try to scoop the point. If no one is able to correct the host's statement, the host reveals what was wrong and the point is lost to the ether.\n\n![(Left to right) Brennan Lee Mulligan, Kirk Damato, and Marisha Ray as contestants --- Season 2, Episode 1](actually_set.jpg)\n\nPlayers can also scoop points by being *more correct* than other contestants. For example, say a player identifies the incorrect portion of the host's statement but their correction is wrong. The host may give the other contestants a chance to scoop by correcting the correction. If the other players aren't able to correct the correction, the first player keeps the point.\n\nFinally, peppered throughout each episode are *Shiny Questions*. Shiny Questions, just like Shiny Pok√©mon, are worth the same amount of points, they're just slightly different and a little rarer. Shiny Questions vary in format --- sometimes contestants are tasked with identifying books based on cover alone, other times contestants must find the \"fake\" alien out of a group of \"real\" fictional aliens, and sometimes contestants try to draw [cryptids](https://en.wikipedia.org/wiki/List_of_cryptids) accurately based on name only.\n\nUltimately, skilled players are those who are good at all aspects of the game. The best players not only have a deep well of niche nerd trivia knowledge, but are also quick on the buzzer, able to scoop points from other players, proficient in a wide array of mini-games in the form of Shiny Questions, and, most importantly, remember to say \"um, actually.\"\n\n## Breaking the rules\n\nIn most episodes, most questions follow the format described above: one of the three contestants earns a point or the point goes to no one. There are, however, a few edge cases that will need to be accounted for to accurately measure individual skill.\n\n#### Multiple points awarded per question\n\nAbout ~4% of the time in three-player games, multiple points are awarded on a single question. Most of these cases involve Shiny Questions in which players can potentially tie. The model should therefore estimate how likely it is that points are awarded to multiple contestants as well as derive the probability of each contestant being awarded a point when multiple points are awarded.\n\n#### Team games\n\nThree episodes^[Season 3, episode 2, season 5, episodes 1 and 21.] break from the three-player format and instead pitch two teams of two players against one another. Like three-player games, multiple points per question can be awarded in team games. The model will need to estimate team skill as a combination of individual skill while also estimating the proportion of questions that award points to both teams.\n\n#### The four-player game\n\nAt New York's Comic Con in 2019, Mike Trapp hosted a live episode^[Season 2, episode 11] of Um, Actually with a fan, Jamel Wood, as a fourth contestant. Although players *could* potentially be awarded multiple points per question, this didn't happen. Thankfully, the model doesn't need to account for the possibility of multiple players being awarded points on a single question in a four-player game.^[The math to estimate this is a clunky mess of algebra: ![](four_person_math.jpg)] It does, however, need to accommodate the four-person structure.\n\n![Mike Trapp as host for a live episode of Um, Actually at New York Comic Con in 2019 --- Season 2, Episode 11](live.jpg)\n\n## Um, Actually: The Model\n\nThis is, to say the least, a fairly complex model. To throw some fancy terminology at the wall, I might refer to this as a hierarchical Bayesian model of latent player skill with a finite mixture of possible point awards. But complexity is the cost we pay to jointly model all the possible edge cases brought up by varying show formats. To quote Andrew Gelman, [\"big data needs big model.\"](https://statmodeling.stat.columbia.edu/2014/05/22/big-data-needs-big-model/)\n\nThat being said, it's easier to think of this a set of models with a shared base rather than one big model. The different show formats and point awards are handled separately within the model but are all built on the same foundation: estimated player skill.\n\n#### Player skill\n\nFor each player, $p$, I model their latent skill, $\\beta_p$, as hierarchically distributed around the latent skill of the average player, $\\alpha$. The hierarchical formulation allows the model to partially pool player skill estimates. Players who appear on the show many times will have relatively precise estimates of skill. Conversely, players with few appearances will tend to have skill estimates close to the average. To restrict the range of plausible values, I place standard normal priors over the parameters.\n\n$$\n\\begin{align*}\n\\beta_p &= \\alpha + \\eta_p \\sigma \\\\\n\\alpha &\\sim \\text{Normal}(0, 1) \\\\\n\\eta &\\sim \\text{Normal}(0, 1) \\\\\n\\sigma &\\sim \\text{Half-Normal}(0, 1)\n\\end{align*}\n$$\n\n::: {add-from=actually.stan start-line=71 end-line=72 code-line-numbers=\"true\"}\n```{.stan}\n```\n:::\n\n#### Multiple awards in team games\n\nIn each team game, $g$, I estimate the number of questions with points awarded to both teams, $S_g$ as a draw from a binomial distribution where $K_g$ is the number of questions in each game and $\\delta$ is the probability that points are awarded to both teams. This is a relatively rare occurrence, so I place an informative prior over $\\text{logit}(\\delta)$. \n\n$$\n\\begin{align*}\nS_g &\\sim \\text{Binomial}(K_g, \\delta) \\\\\n\\text{logit}(\\delta) &\\sim \\text{Normal}(-2,0.5)\n\\end{align*}\n$$\n\n#### Multiple awards in three-player games\n\nIn a three-player game, estimating how often points are awarded to multiple contestants is a bit more complex. Here, $S_g$ is a vector with three elements that counts the number of questions in each game, $g$, in which the point was awarded to one player (or no one), two players, or all three players. $K_g$ is the number of questions in each game and $\\phi$ is a vector of probabilities corresponding to each category in $S$. \n\n$$\n\\begin{align*}\nS_g &\\sim \\text{Multinomial}(K_g, \\phi) \\\\\n\\phi &= \\begin{bmatrix} p_1 \\\\ p_2 \\\\ p_3 \\end{bmatrix} \\\\\n\\end{align*}\n$$\n\nSince the categories are ordered, $p$ is generated by dividing the range $[0,1]$ into three $p$ sized regions with two cutpoints, $q$.^[For a detailed introduction to modeling ordinal outcomes, see Chapter 12 Section 3 of Statistical Rethinking by Richard McElreath. I also cover in more detail [here](https://www.thedatadiary.net/posts/2022-12-30-my-2022-magnum-opus/).] Applying the logit transform to $q$ yields $\\kappa$, over which I place a $\\text{Normal}(0,1.5)$ prior. I enforce that $\\kappa_2 > \\kappa_1$ with Stan's `ordered` data type.\n\n$$\n\\begin{align*}\np_1 &= q_1 \\\\\np_2 &= q_2 - q_1 \\\\\np_3 &= 1 - q_2 \\\\\n\\text{logit}(q_k) &= \\kappa_k \\\\\n\\kappa &\\sim \\text{Normal}(0, 1.5)\n\\end{align*}\n$$\n\n::: {add-from=functions.stan start-line=27 end-line=38 code-line-numbers=\"true\"}\n```{.stan}\n```\n:::\n\n#### Single point awarded in a three-player game\n\nIn a three-player game, $g$, the number of individually awarded points each player, $p$, wins is modeled as a draw from a poisson distribution given the expected number of points for player $p$, $\\lambda_{g,p}$. $\\lambda_{g,p}$ is simply the product of the total number of individually awarded points, $K_g$, and player $p$'s probability of winning each point in game $g$, $\\theta_{g,p}$.^[This is an example of the poisson trick --- using a series of poisson likelihoods to [vectorize a multinomial model](https://www.thedatadiary.net/posts/2023-04-25-zoom-zoom/).]\n\n$$\n\\begin{align*}\nR_{g,p} &\\sim \\text{Poisson}(\\lambda_{g,p}) \\\\\n\\lambda_{g,p} &= K_g \\times \\theta_{g,p}\n\\end{align*}\n$$\n\nEach element of $\\theta_g$ falls between $[0,1]$ and must satisfy the condition that $\\sum \\theta_g = 1$. Applying the [softmax tranformation](https://en.wikipedia.org/wiki/Softmax_function)^[$\\text{softmax}(z)_i = \\frac{e^{z_i}}{\\sum_j^K e^{z_j}}$] to a vector of latent player skill in game $g$, $\\gamma_g$, satisfies $\\theta_g$'s constraints.\n\n$$\n\\begin{align*}\n\\theta_g &= \\text{softmax}(\\gamma_g) \\\\\n\\gamma_g &= \\begin{bmatrix} \\beta_{\\text{pid}[g,1]} \\\\ \\beta_{\\text{pid}[g,2]} \\\\ \\beta_{\\text{pid[g,3]}} \\\\ 0 \\end{bmatrix}\n\\end{align*}\n$$\n\nIt's worth spending more time interrogating these few lines in more detail. Firstly, sometimes no player is awarded a point. This is represented mathematically by \"awarding\" these points to the host at position 4 in $\\gamma$. To ensure [identifiability](https://mc-stan.org/docs/stan-users-guide/regression.html#identifiability) of the players' skill parameters, $\\beta$, I use the \"host points\" as the reference condition and fix the value value to $0$.^[Note that this does *not* mean that there is a 0% chance of awarding \"host points.\"]\n\nSecondly, the player in each position in $\\gamma$ can change from game to game. For example, [Siobhan Thompson](https://x.com/vornietom) can appear at position 1 in one game, position 3 in another, but most often doesn't appear at all! The model undertakes a bit of array-indexing insanity to ensure that the length of $\\gamma$ stays the same, but the player-level elements change from game to game.\n\nFinally, although the parameter measuring player skill is static, the probability of being awarded a point can change based on the other players in the game. For example, consider a game with three equally-matched players. Unsurprisingly, they each have an equal probability of being awarded a point.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nbeta <- c(0.5, 0.5, 0.5, 0)\n\nbeta %>%\n  softmax() %>%\n  round(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.28 0.28 0.28 0.17\n```\n\n\n:::\n:::\n\n\n\nIf, however, a more skilled contestant swaps in, the probability of the other players being awarded a point drops, despite their latent skill remaining the same.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nbeta[1] <- 1.5\n\nbeta %>%\n  softmax() %>%\n  round(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.51 0.19 0.19 0.11\n```\n\n\n:::\n:::\n\n\n\n::: {add-from=functions.stan start-line=40 end-line=59 code-line-numbers=\"true\"}\n```{.stan}\n```\n:::\n\n#### Multiple points awarded in a three-player game\n\n* Consider each individual player and each individual question\n* There's a chance they do or don't get a point --- model it as a bernoulli\n* The probability of each individual receiving a point is $\\theta_{\\text{split},g,p}$\n* Named differently because it's calculated differently\n\n$$\n\\begin{align*}\nR_{\\text{3-player},g,p,q} &\\sim \\text{Bernoulli}(\\theta_{\\text{split},g,p})\n\\end{align*}\n$$\n\n* invoke garden of forking paths analogy\n* Let's pretend we're player 1\n* what are the chances that we receive one of the two points\n* well, it has to follow one of the sequences below\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndagitty::dagitty(\"dag {\n  Start -> Po1\n  Start -> Po2\n  Start -> Po3\n  Po2 -> P21\n  Po2 -> P23\n  Po3 -> P31\n  Po3 -> P32\n}\") %>%\n  ggdag::tidy_dagitty(layout = \"partition\") %>%\n  mutate(name = case_match(name,\n                           \"Po1\" ~ \"Pr(1)\",\n                           \"Po2\" ~ \"Pr(2)\",\n                           \"Po3\" ~ \"Pr(3)\",\n                           \"P21\" ~ \"Pr(2-1)\",\n                           \"P23\" ~ \"Pr(2-3)\",\n                           \"P31\" ~ \"Pr(3-1)\",\n                           \"P32\" ~ \"Pr(3-2)\",\n                           .default = name)) %>%\n  ggdag::ggdag(parse = TRUE) +\n  scale_color_identity() + \n  coord_flip() +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=2700}\n:::\n:::\n\n\n\n* 1st point can go to player 1, 2, or 3\n* If it goes to player 1, we don't care where the second point goes --- so the diagram below ends at that node\n* Probability that the first point goes to each player is simply $\\theta_p$\n\n$$\n\\begin{align*}\n\\Pr(1) &= \\theta_1 \\\\\n\\Pr(2) &= \\theta_2 \\\\\n\\Pr(3) &= \\theta_3 \\\\\n\\end{align*}\n$$\n\n* If the first point goes to us (player 1), we don't care where the 2nd point goes\n* If it goes to players 2 or 3, however, the 2nd point can go to either us or player 3\n* The probability of us winning the point *conditional* on the first point going to player 2 is our chances of winning *relative* to player 3\n\n$$\n\\begin{align*}\n\\Pr(1 | 2) &= \\frac{\\theta_1}{\\theta_1 + \\theta_3}\n\\end{align*}\n$$\n\n* to get the probability of the sequence occurring, we just need to multiply by the probability of player 2 being awarded the first point\n\n$$\n\\begin{align*}\n\\Pr(\\text{2-1}) &= \\theta_2\\frac{\\theta_1}{\\theta_1 + \\theta_3}\n\\end{align*}\n$$\n\n* $\\theta_{\\text{split},1}$ is the sum of all possible paths that lead to player 1 being awarded a point\n* So, repeating the process for the path where player 3 is awarded the first point, we get the following:\n\n$$\n\\begin{align*}\n\\theta_{\\text{split},1} &= \\theta_1 + \\theta_2\\frac{\\theta_1}{\\theta_1 + \\theta_3} + \\theta_3\\frac{\\theta_1}{\\theta_1 + \\theta_2}\n\\end{align*}\n$$\n\n* We can reduce with a bit of algebra and generalize with a bit of notation\n* Notice that $\\theta_1$, $\\theta_2$, and $\\theta_3$ appear in both fractions. \n* The sum in the denominator always excludes the value in the numerator, so we can write the denominator as $\\sum \\theta_{-j}$, where $\\theta_j$ is the value that appears in the numerator\n* Notice also that $\\theta_1$ never appears in the numerator and always appears in the denominator. We can enforce this notationally by indicating that $j \\neq p$ in the summation.\n\n$$\n\\begin{align*}\n\\theta_{\\text{split},1} &= \\theta_1 \\left(1 + \\frac{\\theta_2}{\\theta_1 + \\theta_3} + \\frac{\\theta_3}{\\theta_1 + \\theta_2} \\right) \\\\\n&= \\theta_1 \\left(1 + \\sum_{j=2}^{J=3} \\frac{\\theta_j}{\\sum \\theta_{-j}} \\right )\n\\end{align*}\n$$\n\n::: {add-from=functions.stan start-line=1 end-line=25 code-line-numbers=\"true\"}\n```{.stan}\n```\n:::\n\n$$\n\\begin{align*}\n\\theta_{\\text{split},g} &= \\theta_{g,p} \\left(1 + \\sum_{j=1 \\\\ j \\neq p}^{J=P} \\frac{\\theta_{g,p[j]}}{\\sum \\theta_{g,p[-j]}} \\right) \\\\\n\\theta_g &= \\text{softmax}(\\gamma_g) \\\\\n\\gamma_g &= \\begin{bmatrix} \\beta_{\\text{pid}[g,1]} \\\\ \\beta_{\\text{pid}[g,2]} \\\\ \\beta_{\\text{pid}[g,3]} \\end{bmatrix}\n\\end{align*}\n$$\n\n::: {add-from=functions.stan start-line=61 end-line=80 code-line-numbers=\"true\"}\n```{.stan}\n```\n:::\n\n* all three players awarded a point\n* doesn't contribute any information ($\\theta_p = 1$ for all players)\n\n#### Team games\n\n* Number of points each team receives is modeled as a poisson\n* lambda is the team's expected number of points\n* product of each team's probability of earning a point and the total number of points to be awarded\n* probability per question is softmax of the skill vector\n* only difference is that team skill is the sum of individual player skill\n\n$$\n\\begin{align*}\nR_{\\text{team},g,t} &\\sim \\text{Poisson}(\\lambda_{g,p}) \\\\\n\\lambda_{g,p} &= K_{\\text{team},g} \\times \\theta_{g,p} \\\\\n\\theta_g &= \\text{softmax}(\\gamma_g) \\\\\n\\gamma_g &= \\begin{bmatrix} \\beta_{\\text{pid}[g,1]} + \\beta_{\\text{pid}[g,2]} \\\\ \\beta_{\\text{pid}[g,3]} + \\beta_{\\text{pid}[g,4]} \\\\ 0 \\end{bmatrix}\n\\end{align*}\n$$\n\n::: {add-from=functions.stan start-line=82 end-line=99 code-line-numbers=\"true\"}\n```{.stan}\n```\n:::\n\n\n#### The four-player game\n\n* super similar to the 3 player game\n* only need to add in another index in the skill vector\n\n$$\n\\begin{align*}\n\\gamma_g &= \\begin{bmatrix} \\beta_{\\text{pid}[g,1]} \\\\ \\beta_{\\text{pid}[g,2]} \\\\ \\beta_{\\text{pid}[g,3]} \\\\ \\beta_{\\text{pid}[g,4]} \\\\ 0 \\end{bmatrix}\n\\end{align*}\n$$\n\n#### \n\n* callout - if you wanna just see who the best is, you can skip to the table at the end of the article\n* Introduction\n  * soft intro to um actually\n  * ify as the winningest through 8 seasons\n  * hmmm but should we question this?\n* The (general) rules of the game\n  * 3 players\n  * make statements - something in each statement is wrong\n  * must precede the correction with \"um, actually\"\n* The weird edge cases\n* Statistical model\n* Data wrangling & fitting\n* Results\n  * Brennan, Ify, Ally\n* Conclusions\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}