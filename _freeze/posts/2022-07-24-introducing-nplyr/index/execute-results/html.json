{
  "hash": "ca0209a274a72f06304dc0a7a86177da",
  "result": {
    "markdown": "---\ntitle: Introducing {nplyr}\ndate: '2022-07-24'\ncategories: [rstats, nplyr]\nsubtitle: A grammar of (nested) data manipulation\nimage: logo.png\ncode-fold: show\n---\n\n\nData manipulation and transformation is a fundamental part of any analysis. There are excellent tools in the R ecosystem for manipulating data frames ([dplyr](https://dplyr.tidyverse.org/), [data.table](https://rdatatable.gitlab.io/data.table/), and [arrow](https://arrow.apache.org/docs/r/), to name a few). Sometimes, however, it is desirable to work with *nested* data frames, for which few tools are readily available.\n\nThis is where [nplyr](https://markjrieke.github.io/nplyr/) comes into play! nplyr is a grammar of nested data manipulation that allows users to perform dplyr-like manipulations on data frames nested within a list-col of another data frame. Most dplyr verbs have nested equivalents in nplyr. For example:\n\n* `nest_mutate()` is the nested equivalent of `mutate()`\n* `nest_select()` is the nested equivalent of `select()`\n* `nest_filter()` is the nested equivalent of `filter()`\n* `nest_summarise()` is the nested equivalent of `summarise()`\n* `nest_group_by()` is the nested equivalent of `group_by()`\n\n### Installation\n\nnplyr 0.1.0 is available on [CRAN](https://cran.r-project.org/web/packages/nplyr/index.html). Alternatively, you can install the development version from github with the [devtools](https://cran.r-project.org/package=devtools) or [remotes](https://cran.r-project.org/package=remotes) package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install from CRAN\ninstall.packages(\"nplyr\")\n\n# install from github\ndevtools::install_github(\"markjrieke/nplyr\")\n```\n:::\n\n\n### Usage\n\nTo get started, we'll create a nested column for the country data within each continent from the [gapminder](https://cran.r-project.org/package=gapminder) dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nplyr)\n\ngm_nest <-\n  gapminder::gapminder_unfiltered %>%\n  tidyr::nest(country_data = -continent)\n\ngm_nest\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 6 × 2\n#>   continent country_data        \n#>   <fct>     <list>              \n#> 1 Asia      <tibble [578 × 5]>  \n#> 2 Europe    <tibble [1,302 × 5]>\n#> 3 Africa    <tibble [637 × 5]>  \n#> 4 Americas  <tibble [470 × 5]>  \n#> 5 FSU       <tibble [139 × 5]>  \n#> 6 Oceania   <tibble [187 × 5]>\n```\n:::\n:::\n\n\ndplyr can perform operations on the top-level data frame, but with nplyr, we can perform operations on the nested data frames:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngm_nest_example <-\n  gm_nest %>%\n  nest_filter(country_data, year == max(year)) %>%\n  nest_mutate(country_data, pop_millions = pop/1000000)\n\n# each nested tibble is now filtered to the most recent year\ngm_nest_example\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 6 × 2\n#>   continent country_data     \n#>   <fct>     <list>           \n#> 1 Asia      <tibble [43 × 6]>\n#> 2 Europe    <tibble [34 × 6]>\n#> 3 Africa    <tibble [53 × 6]>\n#> 4 Americas  <tibble [33 × 6]>\n#> 5 FSU       <tibble [9 × 6]> \n#> 6 Oceania   <tibble [11 × 6]>\n```\n:::\n\n```{.r .cell-code}\n# if we unnest, we can see that a new column for pop_millions has been created\ngm_nest_example %>%\n  slice_head(n = 1) %>%\n  tidyr::unnest(country_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 43 × 7\n#>    continent country           year lifeExp        pop gdpPercap pop_millions\n#>    <fct>     <fct>            <int>   <dbl>      <int>     <dbl>        <dbl>\n#>  1 Asia      Afghanistan       2007    43.8   31889923      975.       31.9  \n#>  2 Asia      Azerbaijan        2007    67.5    8017309     7709.        8.02 \n#>  3 Asia      Bahrain           2007    75.6     708573    29796.        0.709\n#>  4 Asia      Bangladesh        2007    64.1  150448339     1391.      150.   \n#>  5 Asia      Bhutan            2007    65.6    2327849     4745.        2.33 \n#>  6 Asia      Brunei            2007    77.1     386511    48015.        0.387\n#>  7 Asia      Cambodia          2007    59.7   14131858     1714.       14.1  \n#>  8 Asia      China             2007    73.0 1318683096     4959.     1319.   \n#>  9 Asia      Hong Kong, China  2007    82.2    6980412    39725.        6.98 \n#> 10 Asia      India             2007    64.7 1110396331     2452.     1110.   \n#> # … with 33 more rows\n```\n:::\n:::\n\n\nnplyr also supports grouped operations with `nest_group_by()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngm_nest_example <-\n  gm_nest %>%\n  nest_group_by(country_data, year) %>%\n  nest_summarise(\n    country_data,\n    n = n(),\n    lifeExp = median(lifeExp),\n    pop = median(pop),\n    gdpPercap = median(gdpPercap)\n  )\n\ngm_nest_example\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 6 × 2\n#>   continent country_data     \n#>   <fct>     <list>           \n#> 1 Asia      <tibble [58 × 5]>\n#> 2 Europe    <tibble [58 × 5]>\n#> 3 Africa    <tibble [13 × 5]>\n#> 4 Americas  <tibble [57 × 5]>\n#> 5 FSU       <tibble [44 × 5]>\n#> 6 Oceania   <tibble [56 × 5]>\n```\n:::\n\n```{.r .cell-code}\n# unnesting shows summarised tibbles for each continent\ngm_nest_example %>%\n  slice(2) %>%\n  tidyr::unnest(country_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 58 × 6\n#>    continent  year     n lifeExp      pop gdpPercap\n#>    <fct>     <int> <int>   <dbl>    <dbl>     <dbl>\n#>  1 Europe     1950    22    65.8 7408264      6343.\n#>  2 Europe     1951    18    65.7 7165515      6509.\n#>  3 Europe     1952    31    65.9 7124673      5210.\n#>  4 Europe     1953    17    67.3 7346100      6774.\n#>  5 Europe     1954    17    68.0 7423300      7046.\n#>  6 Europe     1955    17    68.5 7499400      7817.\n#>  7 Europe     1956    17    68.5 7575800      8224.\n#>  8 Europe     1957    31    67.5 7363802      6093.\n#>  9 Europe     1958    18    69.6 8308052.     8833.\n#> 10 Europe     1959    18    69.6 8379664.     9088.\n#> # … with 48 more rows\n```\n:::\n:::\n\n\n### Other use cases\n\nIn the previous set of examples, the output from nplyr's nested operations could be obtained by unnesting and performing grouped dplyr operations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# we can use nplyr to perform operations on the nested data\ngm_nest %>%\n  nest_filter(country_data, year == max(year)) %>%\n  nest_mutate(country_data, pop_millions = pop/1000000) %>%\n  slice_head(n = 1) %>%\n  tidyr::unnest(country_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 43 × 7\n#>    continent country           year lifeExp        pop gdpPercap pop_millions\n#>    <fct>     <fct>            <int>   <dbl>      <int>     <dbl>        <dbl>\n#>  1 Asia      Afghanistan       2007    43.8   31889923      975.       31.9  \n#>  2 Asia      Azerbaijan        2007    67.5    8017309     7709.        8.02 \n#>  3 Asia      Bahrain           2007    75.6     708573    29796.        0.709\n#>  4 Asia      Bangladesh        2007    64.1  150448339     1391.      150.   \n#>  5 Asia      Bhutan            2007    65.6    2327849     4745.        2.33 \n#>  6 Asia      Brunei            2007    77.1     386511    48015.        0.387\n#>  7 Asia      Cambodia          2007    59.7   14131858     1714.       14.1  \n#>  8 Asia      China             2007    73.0 1318683096     4959.     1319.   \n#>  9 Asia      Hong Kong, China  2007    82.2    6980412    39725.        6.98 \n#> 10 Asia      India             2007    64.7 1110396331     2452.     1110.   \n#> # … with 33 more rows\n```\n:::\n\n```{.r .cell-code}\n# in this case, we could have obtained the same result with tidyr and dplyr\ngm_nest %>%\n  tidyr::unnest(country_data) %>%\n  group_by(continent) %>%\n  filter(year == max(year)) %>%\n  mutate(pop_millions = pop/1000000) %>%\n  ungroup() %>%\n  filter(continent == \"Asia\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 43 × 7\n#>    continent country           year lifeExp        pop gdpPercap pop_millions\n#>    <fct>     <fct>            <int>   <dbl>      <int>     <dbl>        <dbl>\n#>  1 Asia      Afghanistan       2007    43.8   31889923      975.       31.9  \n#>  2 Asia      Azerbaijan        2007    67.5    8017309     7709.        8.02 \n#>  3 Asia      Bahrain           2007    75.6     708573    29796.        0.709\n#>  4 Asia      Bangladesh        2007    64.1  150448339     1391.      150.   \n#>  5 Asia      Bhutan            2007    65.6    2327849     4745.        2.33 \n#>  6 Asia      Brunei            2007    77.1     386511    48015.        0.387\n#>  7 Asia      Cambodia          2007    59.7   14131858     1714.       14.1  \n#>  8 Asia      China             2007    73.0 1318683096     4959.     1319.   \n#>  9 Asia      Hong Kong, China  2007    82.2    6980412    39725.        6.98 \n#> 10 Asia      India             2007    64.7 1110396331     2452.     1110.   \n#> # … with 33 more rows\n```\n:::\n:::\n\n\nWhy, then, might we need to use nplyr? Well, in other scenarios, it may be far more convenient to work with nested data frames or it may not even be possible to unnest!\n\nConsider a set of surveys that an organization might use to gather market data. It is common for organization to have separate surveys for separate purposes but to gather the same baseline set of data across all surveys (for example , a respondent's age and gender may be recorded across all surveys, but each survey will have a different set of questions). Let's use two fake surveys with the below questions for this example:\n\n###### Survey 1: Job\n\n1. How old are you? (multiple choice)\n2. What city do you live in? (multiple choice)\n3. What field do you work in? (multiple choice)\n4. Overall, how satisfied are you with your job? (multiple choice)\n5. What is your annual salary? (numeric entry)\n\n###### Survey 2: Personal Life\n\n1. How old are you? (multiple choice)\n2. What city do you live in? (multiple choice)\n3. What field do you work in? (mulitple choice)\n4. Overall, how satisfied are you with your personal life (multiple choice)\n5. Please provide any additional detail (text entry)\n\nIn this scenario, both surveys are collecting demographic information --- age, location, and industry --- but differ in the remaining questions. A convenient way to get the response files into the environment would be to use `purrr::map()` to read each file to a nested data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npath <- \"https://raw.githubusercontent.com/markjrieke/nplyr/main/data-raw/\"\n\nsurveys <- \n  tibble::tibble(survey_file = c(\"job_survey\", \"personal_survey\")) %>%\n  mutate(survey_data = purrr::map(survey_file, ~readr::read_csv(paste0(path, .x, \".csv\"))))\n\nsurveys\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 2 × 2\n#>   survey_file     survey_data         \n#>   <chr>           <list>              \n#> 1 job_survey      <spc_tbl_ [500 × 6]>\n#> 2 personal_survey <spc_tbl_ [750 × 6]>\n```\n:::\n:::\n\n\n`tidyr::unnest()` can usually handle idiosyncracies in layout when unnesting, but in this case unnesting throws an error!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys %>%\n  tidyr::unnest(survey_data)\n```\n\n::: {.cell-output .cell-output-error}\n```\n#> Error in `list_unchop()`:\n#> ! Can't combine `x[[1]]$Q5` <double> and `x[[2]]$Q5` <character>.\n```\n:::\n:::\n\n\nThis is because the surveys share column names but not necessarily column types! In this case, both data frames contain a column named `Q5`, but in `job_survey` it's a double and in `personal_survey` it's a character.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys %>%\n  slice(1) %>%\n  tidyr::unnest(survey_data) %>%\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> Rows: 500\n#> Columns: 7\n#> $ survey_file <chr> \"job_survey\", \"job_survey\", \"job_survey\", \"job_survey\", \"j…\n#> $ survey_name <chr> \"job\", \"job\", \"job\", \"job\", \"job\", \"job\", \"job\", \"job\", \"j…\n#> $ Q1          <dbl> 100, 81, 51, 81, 80, 32, 65, 57, 43, 94, 25, 83, 61, 66, 8…\n#> $ Q2          <chr> \"Austin\", \"San Antonio\", \"Austin\", \"Austin\", \"Dallas\", \"Fo…\n#> $ Q3          <chr> \"Consulting\", \"Consulting\", \"Consulting\", \"Technology\", \"C…\n#> $ Q4          <chr> \"Somewhat dissatisfied\", \"Neither satisfied nor dissatisfi…\n#> $ Q5          <dbl> 163, 48, 190, 25, 143, 233, 43, 243, 158, 235, 245, 195, 2…\n```\n:::\n\n```{.r .cell-code}\nsurveys %>%\n  slice(2) %>%\n  tidyr::unnest(survey_data) %>%\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> Rows: 750\n#> Columns: 7\n#> $ survey_file <chr> \"personal_survey\", \"personal_survey\", \"personal_survey\", \"…\n#> $ survey_name <chr> \"personal\", \"personal\", \"personal\", \"personal\", \"personal\"…\n#> $ Q1          <dbl> 91, 32, 40, 23, 88, 69, 96, 40, 57, 40, 39, 70, 29, 38, 57…\n#> $ Q2          <chr> \"Austin\", \"San Antonio\", \"San Antonio\", \"Austin\", \"Dallas\"…\n#> $ Q3          <chr> \"Energy\", \"Healthcare\", \"Consulting\", \"Consulting\", \"Techn…\n#> $ Q4          <chr> \"Neither satisfied nor dissatisfied\", \"Extremely satisfied…\n#> $ Q5          <chr> \"Blandit eros! A, ligula facilisis imperdiet! Interdum pla…\n```\n:::\n:::\n\n\nWe could potentially get around this issue with unnesting by reading in all columns as characters via `readr::read_csv(x, col_types = cols(.default = \"c\"))`, but this presents its own challenges. `Q5` would still be better represented as a double in `job_survey` and, from the survey question text, `Q4` has similar, but distinctly different, meanings across the survey files.\n\nThis is where nplyr can assist! Rather than malign the data types or create separate objects for each survey file, we can use nplyr to perform operations directly on the nested data frames.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys <- \n  surveys %>%\n  nest_mutate(survey_data,\n              age_group = if_else(Q1 < 65, \"Adult\", \"Retirement Age\")) %>%\n  nest_group_by(survey_data, Q3) %>%\n  nest_add_count(survey_data, \n                 name = \"n_respondents_in_industry\") %>%\n  nest_mutate(survey_data, \n              median_industry_age = median(Q1)) %>%\n  nest_ungroup(survey_data)\n\nsurveys %>%\n  slice(1) %>%\n  tidyr::unnest(survey_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 500 × 10\n#>    survey_file survey_name    Q1 Q2    Q3    Q4       Q5 age_g…¹ n_res…² media…³\n#>    <chr>       <chr>       <dbl> <chr> <chr> <chr> <dbl> <chr>     <int>   <dbl>\n#>  1 job_survey  job           100 Aust… Cons… Some…   163 Retire…     107    57  \n#>  2 job_survey  job            81 San … Cons… Neit…    48 Retire…     107    57  \n#>  3 job_survey  job            51 Aust… Cons… Extr…   190 Adult       107    57  \n#>  4 job_survey  job            81 Aust… Tech… Extr…    25 Retire…     108    61.5\n#>  5 job_survey  job            80 Dall… Cons… Extr…   143 Retire…     107    57  \n#>  6 job_survey  job            32 Fort… Ener… Some…   233 Adult        99    59  \n#>  7 job_survey  job            65 Dall… Cons… Some…    43 Retire…     107    57  \n#>  8 job_survey  job            57 Hous… Heal… Some…   243 Adult        75    65  \n#>  9 job_survey  job            43 Dall… Gove… Neit…   158 Adult       111    57  \n#> 10 job_survey  job            94 Fort… Heal… Extr…   235 Retire…      75    65  \n#> # … with 490 more rows, and abbreviated variable names ¹​age_group,\n#> #   ²​n_respondents_in_industry, ³​median_industry_age\n```\n:::\n\n```{.r .cell-code}\nsurveys %>%\n  slice(2) %>%\n  tidyr::unnest(survey_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 750 × 10\n#>    survey_file     surve…¹    Q1 Q2    Q3    Q4    Q5    age_g…² n_res…³ media…⁴\n#>    <chr>           <chr>   <dbl> <chr> <chr> <chr> <chr> <chr>     <int>   <dbl>\n#>  1 personal_survey person…    91 Aust… Ener… Neit… Blan… Retire…     145      61\n#>  2 personal_survey person…    32 San … Heal… Extr… Elem… Adult       131      62\n#>  3 personal_survey person…    40 San … Cons… Some… Eget… Adult       149      61\n#>  4 personal_survey person…    23 Aust… Cons… Extr… Scel… Adult       149      61\n#>  5 personal_survey person…    88 Dall… Tech… Neit… Aene… Retire…     150      61\n#>  6 personal_survey person…    69 Fort… Tech… Neit… Inte… Retire…     150      61\n#>  7 personal_survey person…    96 Hous… Heal… Extr… Blan… Retire…     131      62\n#>  8 personal_survey person…    40 Hous… Cons… Extr… Scel… Adult       149      61\n#>  9 personal_survey person…    57 Fort… Ener… Extr… Pede… Adult       145      61\n#> 10 personal_survey person…    40 Fort… Heal… Extr… Phar… Adult       131      62\n#> # … with 740 more rows, and abbreviated variable names ¹​survey_name,\n#> #   ²​age_group, ³​n_respondents_in_industry, ⁴​median_industry_age\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}