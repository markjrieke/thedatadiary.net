---
title: 'Estimate your uncertainty'
author: ''
date: '2022-06-12'
slug: []
categories: [rstats, bayes theorem]
tags: []
subtitle: 'Modeling patient satisfaction data with empirical Bayesian methods'
summary: ''
authors: []
lastmod: '2022-06-12T16:37:09-05:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---



<p>I recently picked up <a href="http://varianceexplained.org/about/">David Robinson’s</a> book, <a href="http://varianceexplained.org/r/empirical-bayes-book/">Introduction to Empirical Bayes</a>. It’s available online for a price of your own choosing (operating under a “pay-what-you-want” model), so you can technically pick it up for free, but it’s well worth the suggested price of $9.95. The book has a particular focus on practical steps for implementing Bayesian methods with code, which I appreciate. I’ve made it through Part I (of four), which makes for a good stopping point to practice what I’ve read.</p>
<p>The first section is highly focused on modeling the probability of success/failure of some binary outcome using a <a href="https://en.wikipedia.org/wiki/Beta_distribution">beta distribution</a>. This is highly relevant to my work as an analyst, where whether or not a patient responded positively to a particular question on a survey can be modeled with this method. Thus far, however, I’ve taken the <a href="https://en.wikipedia.org/wiki/Frequentist_inference">frequentist</a> approach to analyses, which assumes we know nothing about what the data ought to look like prior to analyzing it. This is largely because I didn’t know of a robust way to estimate a <a href="https://en.wikipedia.org/wiki/Prior_probability">prior</a> for a Bayesian analysis.</p>
<p>Thankfully, however, the book walks through examples of exactly how to do this! We can use a <a href="https://en.wikipedia.org/wiki/Maximum_likelihood_estimation">maximum likelihood estimator</a> to estimate a reasonable prior given the current data. That’s quite a bit of statistical mumbo-jumbo — in this post I’ll walk through an example that spells it out a bit more clearly using fake hospital satisfaction data.</p>
<div id="setting-up-the-data" class="section level2">
<h2>Setting up the data</h2>
<p>First, let’s simulate responses to patient satisfaction surveys. I tend to look at patient satisfaction scores across individual hospital units (e.g., ED, ICU, IMU, etc.). Units can have varying numbers of discharges, so we’ll use a <a href="https://en.wikipedia.org/wiki/Log-normal_distribution">log-normal</a> distribution to estimate the number of responses for each unit.</p>
<pre class="r"><code># simulate 1,500 hospital units with an average of 150 survey returns per unit
set.seed(123)
survey_data &lt;- 
  rlnorm(1500, log(150), 1.5) %&gt;%
  as_tibble() %&gt;%
  rename(n = value)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-3-1.png" width="4500" /></p>
<p>The spectrum of responses is incredibly broad — some units have a massive number of returns (in the tens of thousands!) while others have just a handful. This is fairly consistent with the real-world data that I’ve seen (though the units on the high-side are a bit over-represented here).</p>
<p>Next, let’s assume that there is some true satisfaction rate that is associated with each unit. If each unit had an infinite number of survey returns, the satisfaction rate from the survey returns would approach this true value. In this case, we’ll set the true satisfaction for each unit randomly but have it hover around 66%.</p>
<pre class="r"><code># set the true satisfaction to be different for each unit, but hover around 66%
set.seed(234)
survey_data &lt;- 
  survey_data %&gt;%
  rowwise() %&gt;%
  mutate(true_satisfaction = rbeta(1, 66, 34))</code></pre>
<p>Although there is a true satisfaction associated with each unit, we wouldn’t expect that the reported survey scores would match this exactly. This is especially true when there are few responses — if a unit has a true satisfaction rate of 75% but only 3 responses, it’s impossible for the reported score to match the underlying true rate!</p>
<p>We can simulate the number of patients who responded positively (in survey terms, the number of “topbox” responses) by generating <code>n</code> responses for each unit using a <a href="https://en.wikipedia.org/wiki/Binomial_distribution">binomial distribution</a>.</p>
<pre class="r"><code># simulate the number of patients responding with the topbox value
# we *know* the true value, but the actual score may vary!
set.seed(345)
survey_data &lt;-
  survey_data %&gt;%
  mutate(n = round(n),
         topbox = rbinom(1, n, true_satisfaction)) %&gt;%
  ungroup() %&gt;%
  
  # name each unit
  rowid_to_column() %&gt;%
  mutate(unit = paste(&quot;Unit&quot;, rowid)) %&gt;%
  relocate(unit) %&gt;%
  
  # remove the true satisfaction so we don&#39;t know what it is!
  select(-rowid, -true_satisfaction)

# find patient satisfaction scores
survey_data &lt;- 
  survey_data %&gt;%
  mutate(score = topbox/n)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-6-1.png" width="4500" /></p>
<p>As expected, most of our simulated data hovers around a score of 66%. However, there are a few scores at the extremes of 0% and 100% — given how we simulated the data, it is unlikely that these units are <em>really</em> performing so poorly/so well and it’s likelier that they just have few returns.</p>
<pre class="r"><code># which units have the highest scores?
survey_data %&gt;%
  arrange(desc(score)) %&gt;%
  slice_head(n = 10) %&gt;%
  knitr::kable()</code></pre>
<table>
<thead>
<tr class="header">
<th align="left">unit</th>
<th align="right">n</th>
<th align="right">topbox</th>
<th align="right">score</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Unit 26</td>
<td align="right">12</td>
<td align="right">12</td>
<td align="right">1.0000000</td>
</tr>
<tr class="even">
<td align="left">Unit 591</td>
<td align="right">2</td>
<td align="right">2</td>
<td align="right">1.0000000</td>
</tr>
<tr class="odd">
<td align="left">Unit 616</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">1.0000000</td>
</tr>
<tr class="even">
<td align="left">Unit 811</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">1.0000000</td>
</tr>
<tr class="odd">
<td align="left">Unit 943</td>
<td align="right">12</td>
<td align="right">12</td>
<td align="right">1.0000000</td>
</tr>
<tr class="even">
<td align="left">Unit 1217</td>
<td align="right">6</td>
<td align="right">6</td>
<td align="right">1.0000000</td>
</tr>
<tr class="odd">
<td align="left">Unit 1435</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">1.0000000</td>
</tr>
<tr class="even">
<td align="left">Unit 1437</td>
<td align="right">6</td>
<td align="right">6</td>
<td align="right">1.0000000</td>
</tr>
<tr class="odd">
<td align="left">Unit 863</td>
<td align="right">19</td>
<td align="right">18</td>
<td align="right">0.9473684</td>
</tr>
<tr class="even">
<td align="left">Unit 372</td>
<td align="right">13</td>
<td align="right">12</td>
<td align="right">0.9230769</td>
</tr>
</tbody>
</table>
<pre class="r"><code># which units have the lowest scores?
survey_data %&gt;%
  arrange(score) %&gt;%
  slice_head(n = 10) %&gt;%
  knitr::kable()</code></pre>
<table>
<thead>
<tr class="header">
<th align="left">unit</th>
<th align="right">n</th>
<th align="right">topbox</th>
<th align="right">score</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Unit 1092</td>
<td align="right">4</td>
<td align="right">0</td>
<td align="right">0.0000000</td>
</tr>
<tr class="even">
<td align="left">Unit 248</td>
<td align="right">20</td>
<td align="right">5</td>
<td align="right">0.2500000</td>
</tr>
<tr class="odd">
<td align="left">Unit 1120</td>
<td align="right">7</td>
<td align="right">2</td>
<td align="right">0.2857143</td>
</tr>
<tr class="even">
<td align="left">Unit 416</td>
<td align="right">3</td>
<td align="right">1</td>
<td align="right">0.3333333</td>
</tr>
<tr class="odd">
<td align="left">Unit 456</td>
<td align="right">3</td>
<td align="right">1</td>
<td align="right">0.3333333</td>
</tr>
<tr class="even">
<td align="left">Unit 972</td>
<td align="right">6</td>
<td align="right">2</td>
<td align="right">0.3333333</td>
</tr>
<tr class="odd">
<td align="left">Unit 113</td>
<td align="right">13</td>
<td align="right">5</td>
<td align="right">0.3846154</td>
</tr>
<tr class="even">
<td align="left">Unit 260</td>
<td align="right">15</td>
<td align="right">6</td>
<td align="right">0.4000000</td>
</tr>
<tr class="odd">
<td align="left">Unit 695</td>
<td align="right">15</td>
<td align="right">6</td>
<td align="right">0.4000000</td>
</tr>
<tr class="even">
<td align="left">Unit 1352</td>
<td align="right">17</td>
<td align="right">7</td>
<td align="right">0.4117647</td>
</tr>
</tbody>
</table>
<p>As expected, the units on either end of the spectrum aren’t necessarily outperforming/underperforming — they simply don’t have a lot of survey responses! We can use Bayesian inference to estimate the true satisfaction rate by specifying and updating a prior!</p>
</div>
<div id="generating-a-prior-distribution" class="section level2">
<h2>Generating a prior distribution</h2>
<p>When looking at the entire dataset, the distribution of scores is thrown off a bit by the units with few responses. If we restrict the dataset to only the units that have more than 30 responses (which, <a href="https://www.thedatadiary.net/blog/2022-04-28-30-is-not-statistical/">as I’ve written about before</a>, isn’t necessarily a data-driven cutoff for analysis) we can get a clearer idea of the distribution of the scores.</p>
<pre class="r"><code>survey_data_filtered &lt;-
  survey_data %&gt;%
  filter(n &gt; 30)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-10-1.png" width="4500" /></p>
<p>Alternatively, we can represent this distribution with a density plot:</p>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-11-1.png" width="4500" /></p>
<p>This looks suspiciously like a beta distribution! A beta distribution’s shape can be defined by two parameters — alpha and beta. Varying these parameters lets us adjust the center and width to match any possible beta distribution.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/7/78/PDF_of_the_Beta_distribution.gif" /></p>
<p>What may make sense would be to use <em>this distribution</em> as our prior. I.e., if we have no responses for a unit, we can probably guess that their score would be somewhere around 66% with some healthy room on either side for variability. To do so, we need to estimate an appropriate alpha and beta — rather than guess the values using trial and error we can pass the work off to our computer to find parameters that <strong>maximize</strong> the <strong>likelihood</strong> that our <strong>estimated distribution</strong> matches the true distribution (hence the name, <em>maximum likelihood estimator</em>).</p>
<pre class="r"><code>library(stats4)

# log-likelihood function
log_likelihood &lt;- function(alpha, beta) {
  -sum(dbeta(survey_data_filtered$score, alpha, beta, log = TRUE))
}

# pass various alphas &amp; betas to `log_likelihood` 
# to find combination that maximizes the likelihood!
params &lt;- 
  mle(
    log_likelihood, 
    start = list(alpha = 50, beta = 50),
    lower = c(1, 1)
  )

# extract alpha &amp; beta
params &lt;- coef(params)
alpha0 &lt;- params[1]
beta0 &lt;- params[2]

print(paste(&quot;alpha:&quot;, round(alpha0, 1), &quot;beta:&quot;, round(beta0, 1)))</code></pre>
<pre><code>## [1] &quot;alpha: 39.7 beta: 20.5&quot;</code></pre>
<p>How well does a beta distribution defined by these parameters match our actual data?</p>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-13-1.png" width="4500" /></p>
<p>This is a pretty good representation of our initial data! When we have no survey responses, we can use a beta distribution with the initial parameters as specified by the maximum likelihood estimation. As a unit gets more responses, we can update our estimation to rely more heavily on the data rather than the prior:</p>
<pre class="r"><code># update alpha &amp; beta as new responses come in!
alpha_new &lt;- alpha0 + n_topbox
beta_new &lt;- beta0 + n - n_topbox</code></pre>
</div>
<div id="updating-our-priors" class="section level2">
<h2>Updating our priors</h2>
<p>With a prior distribution defined by <code>alpha0</code> and <code>beta0</code>, we can upgrade our frequentest estimation of each unit’s score to a Bayesian estimation!</p>
<pre class="r"><code># empirical bayes estimation of satisfaction score
survey_eb &lt;-
  survey_data %&gt;%
  mutate(eb_estimate = (topbox + alpha0) / (n + alpha0 + beta0))</code></pre>
<p>What are the top and bottom performing units by this new Bayesian estimation?</p>
<pre class="r"><code># which units have the highest estimated scores?
survey_eb %&gt;%
  arrange(desc(eb_estimate)) %&gt;%
  slice_head(n = 10) %&gt;%
  knitr::kable()</code></pre>
<table>
<thead>
<tr class="header">
<th align="left">unit</th>
<th align="right">n</th>
<th align="right">topbox</th>
<th align="right">score</th>
<th align="right">eb_estimate</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Unit 133</td>
<td align="right">160</td>
<td align="right">133</td>
<td align="right">0.8312500</td>
<td align="right">0.7841640</td>
</tr>
<tr class="even">
<td align="left">Unit 1004</td>
<td align="right">123</td>
<td align="right">103</td>
<td align="right">0.8373984</td>
<td align="right">0.7787827</td>
</tr>
<tr class="odd">
<td align="left">Unit 172</td>
<td align="right">165</td>
<td align="right">133</td>
<td align="right">0.8060606</td>
<td align="right">0.7667547</td>
</tr>
<tr class="even">
<td align="left">Unit 1042</td>
<td align="right">372</td>
<td align="right">291</td>
<td align="right">0.7822581</td>
<td align="right">0.7650930</td>
</tr>
<tr class="odd">
<td align="left">Unit 1294</td>
<td align="right">1409</td>
<td align="right">1083</td>
<td align="right">0.7686302</td>
<td align="right">0.7641391</td>
</tr>
<tr class="even">
<td align="left">Unit 892</td>
<td align="right">349</td>
<td align="right">273</td>
<td align="right">0.7822350</td>
<td align="right">0.7641085</td>
</tr>
<tr class="odd">
<td align="left">Unit 306</td>
<td align="right">247</td>
<td align="right">195</td>
<td align="right">0.7894737</td>
<td align="right">0.7639102</td>
</tr>
<tr class="even">
<td align="left">Unit 1249</td>
<td align="right">1234</td>
<td align="right">943</td>
<td align="right">0.7641815</td>
<td align="right">0.7592901</td>
</tr>
<tr class="odd">
<td align="left">Unit 427</td>
<td align="right">5469</td>
<td align="right">4151</td>
<td align="right">0.7590053</td>
<td align="right">0.7579168</td>
</tr>
<tr class="even">
<td align="left">Unit 920</td>
<td align="right">1637</td>
<td align="right">1243</td>
<td align="right">0.7593158</td>
<td align="right">0.7557585</td>
</tr>
</tbody>
</table>
<pre class="r"><code># which units have the lowest estimated scores?
survey_eb %&gt;%
  arrange(eb_estimate) %&gt;%
  slice_head(n = 10) %&gt;%
  knitr::kable()</code></pre>
<table>
<thead>
<tr class="header">
<th align="left">unit</th>
<th align="right">n</th>
<th align="right">topbox</th>
<th align="right">score</th>
<th align="right">eb_estimate</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Unit 613</td>
<td align="right">1886</td>
<td align="right">932</td>
<td align="right">0.4941676</td>
<td align="right">0.4992689</td>
</tr>
<tr class="even">
<td align="left">Unit 760</td>
<td align="right">112</td>
<td align="right">49</td>
<td align="right">0.4375000</td>
<td align="right">0.5149645</td>
</tr>
<tr class="odd">
<td align="left">Unit 363</td>
<td align="right">226</td>
<td align="right">112</td>
<td align="right">0.4955752</td>
<td align="right">0.5299674</td>
</tr>
<tr class="even">
<td align="left">Unit 316</td>
<td align="right">431</td>
<td align="right">224</td>
<td align="right">0.5197216</td>
<td align="right">0.5368008</td>
</tr>
<tr class="odd">
<td align="left">Unit 1032</td>
<td align="right">235</td>
<td align="right">119</td>
<td align="right">0.5063830</td>
<td align="right">0.5375222</td>
</tr>
<tr class="even">
<td align="left">Unit 1093</td>
<td align="right">354</td>
<td align="right">183</td>
<td align="right">0.5169492</td>
<td align="right">0.5376064</td>
</tr>
<tr class="odd">
<td align="left">Unit 749</td>
<td align="right">5286</td>
<td align="right">2839</td>
<td align="right">0.5370791</td>
<td align="right">0.5384528</td>
</tr>
<tr class="even">
<td align="left">Unit 291</td>
<td align="right">865</td>
<td align="right">460</td>
<td align="right">0.5317919</td>
<td align="right">0.5400741</td>
</tr>
<tr class="odd">
<td align="left">Unit 515</td>
<td align="right">60</td>
<td align="right">26</td>
<td align="right">0.4333333</td>
<td align="right">0.5463929</td>
</tr>
<tr class="even">
<td align="left">Unit 622</td>
<td align="right">242</td>
<td align="right">127</td>
<td align="right">0.5247934</td>
<td align="right">0.5515432</td>
</tr>
</tbody>
</table>
<p>There are a few things that are worth noting with these estimates:</p>
<ul>
<li>The estimated score is not the same as the actual reported score! As more responses come in, however, the estimated score converges to the actual.</li>
<li>The prior pulls estimated scores towards the prior mean — low scores are pulled up a bit and high scores are pulled down a bit.</li>
<li>The top (and bottom) performing units are no longer dominated by units with few returns!</li>
</ul>
<p>We can also estimate the uncertainty around the estimated score with a <a href="https://en.wikipedia.org/wiki/Credible_interval">credible interval</a>. Credible intervals are the Bayesian counterpart to a frequentist’s <a href="https://en.wikipedia.org/wiki/Confidence_interval">confidence interval</a> — both estimate the region that the true value could fall in given a certain probability — credible intervals, however, are informed by the prior distribution.</p>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-18-1.png" width="4500" /></p>
<p>Because credible intervals are informed in part by the prior, they are tighter than their confidence interval counterparts. Like with the estimated score, however, as n-size increases, the Bayesian and frequentist interval estimations converge. In the absence of larger swathes of data, Bayesian methods can offer additional insight into our data by means of a prior distribution.</p>
</div>
<div id="some-closing-thoughts" class="section level2">
<h2>Some closing thoughts</h2>
<p>Overall, this has been a fairly glowing review of the methods laid out in the first section of <em>Introduction to Empirical Bayes</em>. That being said, Bayesian methods of inference are not inherently <em>better</em> than frequentist methods — while they can offer additional context via a prior, there are situations where frequentist methods are preferred. From a math perspective, the prior provides diminishing returns as sample size increases, so it may be better forgoe Bayesian analysis when sample sizes are large. From an organizational perspective, Bayesian inference may be difficult to explain. In my own work, it’s highly unlikely that I’ll use Bayesian inference in any critical projects any time soon — I can imagine a lengthy uphill battle trying to explain the difference between the reported score and the estimated score informed by a prior.</p>
<p>Finally, there are a few things in this toy analysis that I am hoping to improve upon as I progress further through the book:</p>
<ul>
<li>As I mentioned above and <a href="https://www.thedatadiary.net/blog/2022-04-28-30-is-not-statistical/">in previous writings</a>, using <code>n = 30</code> is a relatively arbitrary cutoff point for analysis. In this case, the prior distribution is fairly sensitive to the cutoff point selected — I am hoping that later sections in the book highilight more robust ways of partitioning data for setting priors.</li>
<li>In the above analysis we’re only examining one variable (univariate analysis) — I am looking forward to extending these methods to multivariate analyses and regressions.</li>
<li>The beta distribution is appropriate for modeling the probability distribution of binary outcomes. In this example, where the outcome is simply the proportion of patients that responded favorably to the survey, modeling the outcome with a beta distribution is appropriate (responses can either be in the “topbox” or not). When there are more than two possible outcomes — for example, when trying to model <a href="https://en.wikipedia.org/wiki/Net_promoter_score">Net Promoter Score</a> as the proportion of “promoters,” “passives,” and “detractors” — the more general <a href="https://en.wikipedia.org/wiki/Dirichlet_distribution">Dirichlet distribution</a> is more appropriate.</li>
<li>I’m hoping also that the book covers methods for dealing with time-dependent data. For example, we’d expect that concerted efforts (or lack thereof) by the hospital units could significantly impact the underlying “true satisfaction” that we’re attempting to estimate via surveying. We expect that more recent survey responses should be more impactful in informing our posterior estimation, but I’ve yet to find any robust literature on how to weight the recency of responses. In the past, I’ve used <a href="https://en.wikipedia.org/wiki/Exponential_decay">exponentional decay</a> to reduce the weight of old responses, but this feels a bit arbitrary.</li>
</ul>
<p>Overall, this has been a long way of saying that I’m happy with the book so far and I’m excited to see what comes next as I continue reading!</p>
</div>
