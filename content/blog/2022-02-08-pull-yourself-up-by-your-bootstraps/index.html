---
title: "Pull Yourself Up by Your Bootstraps"
author: ''
date: '2022-02-08'
slug: []
categories:
- rstats
- tidymodels
tags: []
subtitle: Using bootstrap resamples to generate confidence intervals from non-linear
  models
summary: ''
authors: []
lastmod: '2022-02-08T08:15:27-06:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>


<p>Statistical modeling sometimes presents conflicting goals. Oftentimes, building a model involves a mix of objectives that don’t necessarily mesh well together: super-accurate point predictions, explainability, fast performance, or an expression of confidence in the prediction. In my work as an analyst, I generally am focused on how explainable the model is while being able to express a confidence interval around each prediction. For that, simple linear models do the trick. If, however, I want to regularize via <code>{glmnet}</code> (which — with good reason — <a href="https://stats.stackexchange.com/questions/224796/why-are-confidence-intervals-and-p-values-not-reported-as-default-for-penalized">doesn’t provide confidence intervals</a>) or use a non-linear model like <code>{xgboost}</code>, I have to drop the confidence interval around predictions. Or so I had previously thought! As it turns out, building a series of models from bootstrap resamples provides an alternative method of generating a confidence interval around a prediction.</p>
<div id="setting-a-baseline-with-penguins" class="section level3">
<h3>Setting a baseline with penguins</h3>
<p>First, let’s build out a baseline linear model with the Palmer Penguins dataset. This dataset contains information on 344 penguins across three species types and three islands. For this example, we’ll use the penguin information to predict <code>body_mass_g</code>.</p>
<pre class="r"><code># load the data in from the tidytuesdayR package
penguins_src &lt;- tidytuesdayR::tt_load(2020, week = 31)</code></pre>
<pre><code>## 
##  Downloading file 1 of 2: `penguins.csv`
##  Downloading file 2 of 2: `penguins_raw.csv`</code></pre>
<pre class="r"><code># extract out the penguins dataset
penguins &lt;- penguins_src$penguins
rm(penguins_src)

penguins</code></pre>
<pre><code>## # A tibble: 344 x 8
##    species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g
##    &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;
##  1 Adelie  Torgersen           39.1          18.7               181        3750
##  2 Adelie  Torgersen           39.5          17.4               186        3800
##  3 Adelie  Torgersen           40.3          18                 195        3250
##  4 Adelie  Torgersen           NA            NA                  NA          NA
##  5 Adelie  Torgersen           36.7          19.3               193        3450
##  6 Adelie  Torgersen           39.3          20.6               190        3650
##  7 Adelie  Torgersen           38.9          17.8               181        3625
##  8 Adelie  Torgersen           39.2          19.6               195        4675
##  9 Adelie  Torgersen           34.1          18.1               193        3475
## 10 Adelie  Torgersen           42            20.2               190        4250
## # ... with 334 more rows, and 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;</code></pre>
<p>We’ll need to do some lite preprocessing before we start modeling — it looks like there are some <code>NAs</code> in <code>body_mass_g</code> and in <code>sex</code>. If I were creating a more serious model, I might keep the rows with <code>NAs</code> for <code>sex</code>, but since there are so few and this is an explainer, I’ll just filter them out.</p>
<pre class="r"><code># remove NA from body_mass_g and sex
penguins &lt;- 
  penguins %&gt;%
  filter(!is.na(body_mass_g),
         !is.na(sex))

penguins</code></pre>
<pre><code>## # A tibble: 333 x 8
##    species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g
##    &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;
##  1 Adelie  Torgersen           39.1          18.7               181        3750
##  2 Adelie  Torgersen           39.5          17.4               186        3800
##  3 Adelie  Torgersen           40.3          18                 195        3250
##  4 Adelie  Torgersen           36.7          19.3               193        3450
##  5 Adelie  Torgersen           39.3          20.6               190        3650
##  6 Adelie  Torgersen           38.9          17.8               181        3625
##  7 Adelie  Torgersen           39.2          19.6               195        4675
##  8 Adelie  Torgersen           41.1          17.6               182        3200
##  9 Adelie  Torgersen           38.6          21.2               191        3800
## 10 Adelie  Torgersen           34.6          21.1               198        4400
## # ... with 323 more rows, and 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;</code></pre>
<p>It’s always good practice to explore the dataset prior to fitting a model, so let’s jump into some good ol’ fashioned EDA.</p>
<pre class="r"><code># how are species/island related to body mass?
penguins %&gt;%
  ggplot(aes(x = species,
             y = body_mass_g,
             color = species)) +
  geom_boxplot() +
  geom_point(alpha = 0.25,
             position = position_jitter()) +
  facet_wrap(~island)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-3-1.png" width="4500" /></p>
<p>Interesting! It looks like the Gentoo and Chinstrap species are only found on the Biscoe and Dream islands, respectively, whereas the Adelie species can be found on all three islands. At first glance, there’s not a meaningful difference that Island has on the weight of the Adelie penguins, so I think we’re safe to toss out the <code>island</code> feature and just keep <code>species</code>.</p>
<pre class="r"><code># how does sex relate to body mass?
penguins %&gt;%
  ggplot(aes(x = sex,
             y = body_mass_g,
             color = sex)) +
  geom_boxplot() +
  geom_point(alpha = 0.25,
             position = position_jitter())</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-4-1.png" width="4500" /></p>
<p>Unsurprisingly, male penguins are typically heavier than female penguins.</p>
<pre class="r"><code># are penguins getting heavier or lighter as years progress?
penguins %&gt;%
  mutate(year = as.character(year)) %&gt;%
  ggplot(aes(x = year,
             y = body_mass_g)) +
  geom_boxplot() +
  geom_point(alpha = 0.25,
             position = position_jitter())</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-5-1.png" width="4500" /></p>
<p>It doesn’t look like there is significant signal being drawn from <code>year</code>, so we’ll toss that out as well.</p>
<pre class="r"><code># how do other body measurements compare with the total body mass?
penguins %&gt;%
  select(bill_length_mm:body_mass_g) %&gt;%
  pivot_longer(ends_with(&quot;mm&quot;),
               names_to = &quot;measurement&quot;,
               values_to = &quot;value&quot;) %&gt;%
  ggplot(aes(x = value,
             y = body_mass_g,
             color = measurement)) +
  geom_point(alpha = 0.5) + 
  facet_wrap(~measurement, scales = &quot;free_x&quot;) +
  geom_smooth(method = &quot;lm&quot;,
              se = FALSE)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-6-1.png" width="4500" /></p>
<p>For bill and flipper length, there’s a pretty clear relationship, but it looks like bill depth has a <em>classic</em> case of <a href="https://en.wikipedia.org/wiki/Simpson%27s_paradox">Simpson’s paradox</a>. Let’s explore that further to find a meaningful interaction to apply.</p>
<pre class="r"><code># which feature interacts with bill depth to produce simpson&#39;s pardox?
penguins %&gt;%
  ggplot(aes(x = bill_depth_mm,
             y = body_mass_g,
             color = species)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;,
              se = FALSE)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-7-1.png" width="4500" /></p>
<p>So, very clearly, the Gentoo species has a very different relationship between bill depth and body mass than the Adelie/Chinstrap species. We’ll add this as an interactive feature to the model.</p>
<p>With all that completed, let’s (finally) setup and build the baseline linear model with confidence intervals around the prediction!</p>
<pre class="r"><code># remove features
penguins &lt;- 
  penguins %&gt;%
  select(-island, -year)

# split into testing and training datasets
set.seed(123)
penguins_split &lt;- initial_split(penguins)
penguins_test &lt;- testing(penguins_split)
penguins_train &lt;- training(penguins_split)

# setup a pre-processing recipe
penguins_rec &lt;- 
  recipe(body_mass_g ~ ., data = penguins_train) %&gt;%
  step_dummy(all_nominal()) %&gt;% 
  step_interact(~starts_with(&quot;species&quot;):bill_depth_mm)

# fit a workflow
penguins_lm &lt;- 
  workflow() %&gt;%
  add_recipe(penguins_rec) %&gt;%
  add_model(linear_reg() %&gt;% set_engine(&quot;lm&quot;)) %&gt;%
  fit(penguins_train)

# predict on training data with confidence intervals
bind_cols(penguins_lm %&gt;% predict(penguins_train),
          penguins_lm %&gt;% predict(penguins_train, type = &quot;conf_int&quot;, level = 0.95),
          penguins_train) %&gt;%
  ggplot(aes(x = body_mass_g,
             y = .pred)) +
  geom_point(alpha = 0.5) +
  geom_segment(aes(x = body_mass_g,
                   xend = body_mass_g,
                   y = .pred_lower,
                   yend = .pred_upper),
               alpha = 0.25) +
  labs(title = &quot;Predicting the Palmer Penguins - Training&quot;,
       subtitle = &quot;Linear model predicting a penguin&#39;s weight in grams&quot;,
       x = &quot;Actual weight (g)&quot;,
       y = &quot;Predicted weight (g)&quot;,
       caption = &quot;Errorbars represent the a 95% confidence interval&quot;) +
  theme(plot.title.position = &quot;plot&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-8-1.png" width="4500" /></p>
<p>This model does generally okay, but the confidence interval around each prediction is pretty <a href="https://mc-stan.org/rstanarm/articles/rstanarm.html">clearly too confident</a>! Let’s solve this with bootstrapping.</p>
</div>
<div id="whats-a-bootstrap" class="section level3">
<h3>What’s a bootstrap?</h3>
<p>Before progressing any further, it’s probably important to define what exactly a bootstrap is/what bootstrapping is. Bootstrapping is a resampling method that lets us take one dataset and turn it into many datasets. Bootstrapping accomplishes this by repeatedly pulling a random row from the source dataset and, importantly, bootstrapping allows for rows to be repeated! Let’s look at an example for a bit more clarity.</p>
<table>
<thead>
<tr class="header">
<th align="right">rowid</th>
<th align="right">x1</th>
<th align="right">x2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">0.8</td>
<td align="right">104</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">0.7</td>
<td align="right">102</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="right">0.9</td>
<td align="right">88</td>
</tr>
<tr class="even">
<td align="right">4</td>
<td align="right">0.4</td>
<td align="right">124</td>
</tr>
<tr class="odd">
<td align="right">5</td>
<td align="right">0.3</td>
<td align="right">79</td>
</tr>
</tbody>
</table>
<p>Let’s say we want to make bootstrap resamples of this dataset. We’ll draw five random rows from the dataset and, sometimes, we’ll have the same row show up in our new bootstrapped dataset multiple times:</p>
<table>
<thead>
<tr class="header">
<th align="right">rowid</th>
<th align="right">x1</th>
<th align="right">x2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">0.8</td>
<td align="right">104</td>
</tr>
<tr class="even">
<td align="right">3</td>
<td align="right">0.9</td>
<td align="right">88</td>
</tr>
<tr class="odd">
<td align="right">4</td>
<td align="right">0.4</td>
<td align="right">124</td>
</tr>
<tr class="even">
<td align="right">4</td>
<td align="right">0.4</td>
<td align="right">124</td>
</tr>
<tr class="odd">
<td align="right">2</td>
<td align="right">0.7</td>
<td align="right">102</td>
</tr>
</tbody>
</table>
<p>Another bootstrap dataset might look like this:</p>
<table>
<thead>
<tr class="header">
<th align="right">rowid</th>
<th align="right">x1</th>
<th align="right">x2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">2</td>
<td align="right">0.7</td>
<td align="right">102</td>
</tr>
<tr class="even">
<td align="right">3</td>
<td align="right">0.9</td>
<td align="right">88</td>
</tr>
<tr class="odd">
<td align="right">5</td>
<td align="right">0.3</td>
<td align="right">79</td>
</tr>
<tr class="even">
<td align="right">3</td>
<td align="right">0.9</td>
<td align="right">88</td>
</tr>
<tr class="odd">
<td align="right">5</td>
<td align="right">0.3</td>
<td align="right">79</td>
</tr>
</tbody>
</table>
<p>Bootstrap datasets allow us to create many datasets from the original dataset and evaluate models across these bootstraps. Models that are well informed will give similar outputs across each dataset, despite of the randomness within each dataset, whereas less confident models will have a wider variation across the bootstrapped datasets.</p>
</div>
<div id="generating-some-confident-penguins" class="section level3">
<h3>Generating some confident penguins</h3>
<p>Let’s say we want to use <code>{xgboost}</code> to predict penguin weight and we’ll use bootstrapping to generate a confidence interval. Firstly, we’ll create the bootstrap datasets from our training set.</p>
<pre class="r"><code>penguins_boot &lt;- penguins_train %&gt;% bootstraps()

penguins_boot</code></pre>
<pre><code>## # Bootstrap sampling 
## # A tibble: 25 x 2
##    splits           id         
##    &lt;list&gt;           &lt;chr&gt;      
##  1 &lt;split [249/92]&gt; Bootstrap01
##  2 &lt;split [249/90]&gt; Bootstrap02
##  3 &lt;split [249/91]&gt; Bootstrap03
##  4 &lt;split [249/87]&gt; Bootstrap04
##  5 &lt;split [249/98]&gt; Bootstrap05
##  6 &lt;split [249/84]&gt; Bootstrap06
##  7 &lt;split [249/91]&gt; Bootstrap07
##  8 &lt;split [249/95]&gt; Bootstrap08
##  9 &lt;split [249/94]&gt; Bootstrap09
## 10 &lt;split [249/86]&gt; Bootstrap10
## # ... with 15 more rows</code></pre>
<p>By default, the <code>bootstraps()</code> function will create 25 bootstrap datasets, but we could theoretically create as many as we want. Now that we have our bootstraps, let’s create a function that will fit a model to each of the bootstraps and save to disk. We’ll use the default parameters for our <code>{xgboost}</code> model.</p>
<pre class="r"><code># define a basic xgboost model
penguins_xgb &lt;-
  boost_tree() %&gt;%
  set_mode(&quot;regression&quot;) %&gt;%
  set_engine(&quot;xgboost&quot;)

# function that will fit a model and save to a folder
fit_bootstrap &lt;- function(index) {
  
  # pull out individual bootstrap to fit
  xgb_boot &lt;- penguins_boot$splits[[index]] %&gt;% training()
  
  # fit to a workflow
  workflow() %&gt;%
    add_recipe(penguins_rec) %&gt;%
    add_model(penguins_xgb) %&gt;%
    fit(xgb_boot) %&gt;%
    write_rds(paste0(&quot;models/model_&quot;, index, &quot;.rds&quot;))
  
}</code></pre>
<p>This function will create a new model for each bootstrap, so we’ll end up with 25 separate models. Let’s fit!</p>
<pre class="r"><code># fit to 25 bootstrapped datasets
for (i in 1:25) {
  
  fit_bootstrap(i)
  
}</code></pre>
<p>Now let’s define a function that will predict based on these 25 bootstrapped models, then predict on our training data.</p>
<pre class="r"><code>predict_bootstrap &lt;- function(new_data, index){
  
  read_rds(paste0(&quot;models/model_&quot;, index, &quot;.rds&quot;)) %&gt;%
    predict(new_data) %&gt;%
    rename(!!sym(paste0(&quot;pred_&quot;, index)) := .pred)
  
}

# predict!
training_preds &lt;- 
  seq(1, 25) %&gt;%
  map_dfc(~predict_bootstrap(penguins_train, .x))

training_preds</code></pre>
<pre><code>## # A tibble: 249 x 25
##    pred_1 pred_2 pred_3 pred_4 pred_5 pred_6 pred_7 pred_8 pred_9 pred_10
##     &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;
##  1  5552.  5638.  5555.  5703.  5726.  5783.  5404.  5566.  5493.   5547.
##  2  3470.  3340.  3334.  3350.  3311.  3303.  3315.  3421.  3692.   3436.
##  3  5309.  5274.  5241.  5286.  5206.  5084.  5506.  5531.  5274.   5309.
##  4  4160.  4013.  3988.  4111.  4075.  4073.  4284.  4050.  4033.   4033.
##  5  4003.  3931.  4096.  3968.  4008.  3918.  3941.  4093.  3941.   3880.
##  6  3967.  4039.  4095.  4047.  4021.  4055.  3980.  4115.  4067.   4084.
##  7  4647.  4551.  4750.  4555.  4690.  4396.  4235.  4686.  4764.   4659.
##  8  5240.  5288.  5291.  5276.  5308.  5508.  5570.  5375.  5340.   5268.
##  9  4138.  4111.  4106.  4236.  4135.  4219.  4218.  4211.  4160.   4071.
## 10  4728.  4723.  4715.  4823.  4765.  4727.  4836.  4777.  4765.   4633.
## # ... with 239 more rows, and 15 more variables: pred_11 &lt;dbl&gt;, pred_12 &lt;dbl&gt;,
## #   pred_13 &lt;dbl&gt;, pred_14 &lt;dbl&gt;, pred_15 &lt;dbl&gt;, pred_16 &lt;dbl&gt;, pred_17 &lt;dbl&gt;,
## #   pred_18 &lt;dbl&gt;, pred_19 &lt;dbl&gt;, pred_20 &lt;dbl&gt;, pred_21 &lt;dbl&gt;, pred_22 &lt;dbl&gt;,
## #   pred_23 &lt;dbl&gt;, pred_24 &lt;dbl&gt;, pred_25 &lt;dbl&gt;</code></pre>
<p>Now we have a column of predictions for each model — we can summarise our point prediction for each row with the average across all models and set the confidence interval based on the standard deviation of the predictions.</p>
<pre class="r"><code>training_preds %&gt;%
  bind_cols(penguins_train) %&gt;%
  rowid_to_column() %&gt;%
  pivot_longer(starts_with(&quot;pred_&quot;),
               names_to = &quot;model&quot;,
               values_to = &quot;.pred&quot;) %&gt;%
  group_by(rowid) %&gt;%
  summarise(body_mass_g = max(body_mass_g),
            .pred_mean = mean(.pred),
            std_dev = sd(.pred)) %&gt;%
  riekelib::normal_interval(.pred_mean, std_dev) %&gt;%
  ggplot(aes(x = body_mass_g,
             y = .pred_mean)) +
  geom_point(alpha = 0.5) +
  geom_segment(aes(x = body_mass_g, 
                   xend = body_mass_g,
                   y = ci_lower,
                   yend = ci_upper),
               alpha = 0.25) +
  labs(title = &quot;Predicting the Palmer Penguins - Training&quot;,
       subtitle = &quot;XGBoost model predicting a penguin&#39;s weight in grams&quot;,
       x = &quot;Actual weight (g)&quot;,
       y = &quot;Predicted weight (g)&quot;,
       caption = &quot;Errorbars represent the a 95% confidence interval&quot;) +
  theme(plot.title.position = &quot;plot&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-16-1.png" width="4500" /></p>
<p>And just like that, we’ve trained a series of models with <code>{xgboost}</code> that let us apply a confidence interval around a point prediction! Now that we’ve done so on the training set, let’s look at performance on the test set.</p>
<pre class="r"><code>seq(1, 25) %&gt;%
  map_dfc(~predict_bootstrap(penguins_test, .x)) %&gt;%
  bind_cols(penguins_test) %&gt;%
  rowid_to_column() %&gt;%
  pivot_longer(starts_with(&quot;pred_&quot;),
               names_to = &quot;model&quot;,
               values_to = &quot;.pred&quot;) %&gt;%
  group_by(rowid) %&gt;%
  summarise(body_mass_g = max(body_mass_g),
            .pred_mean = mean(.pred),
            std_dev = sd(.pred)) %&gt;%
  riekelib::normal_interval(.pred_mean, std_dev) %&gt;%
  ggplot(aes(x = body_mass_g,
             y = .pred_mean)) +
  geom_point(alpha = 0.5) +
  geom_segment(aes(x = body_mass_g, 
                   xend = body_mass_g,
                   y = ci_lower,
                   yend = ci_upper),
               alpha = 0.25) +
  labs(title = &quot;Predicting the Palmer Penguins - Testing&quot;,
       subtitle = &quot;XGBoost model predicting a penguin&#39;s weight in grams&quot;,
       x = &quot;Actual weight (g)&quot;,
       y = &quot;Predicted weight (g)&quot;,
       caption = &quot;Errorbars represent the a 95% confidence interval&quot;) +
  theme(plot.title.position = &quot;plot&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-17-1.png" width="4500" /></p>
<p>The performance on the test data is slightly less accurate than on the training data, but that is to be expected. Importantly, we’ve used bootstrap resampling to generate a confidence interval from a model that otherwise normally returns a simple point prediction.</p>
</div>
<div id="some-noteworthy-caveats" class="section level3">
<h3>Some noteworthy caveats</h3>
<p>The prediction interval above is all well and good, but it comes with some <em>hefty</em> caveats. Firstly, the confidence interval in the Testing plot is generated from the mean and standard deviation from each prediction. This assumes that the predictions are distributed normally, which may not necessarily be the case.</p>
<pre class="r"><code>training_preds %&gt;%
  slice_head(n = 1) %&gt;%
  pivot_longer(starts_with(&quot;pred&quot;)) %&gt;%
  ggplot(aes(x = value)) +
  geom_density()</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-18-1.png" width="4500" /></p>
<p>This density plot for one of the predictions shows that there’s definitely some non-normal behavior! There’s a few ways of addressing this.</p>
<ol style="list-style-type: decimal">
<li>Create many, many, more bootstraps and models so that the prediction distribution approaches normality (with only 25 points, we really shouldn’t even expect normality from this example).</li>
<li>Report out the actual values of the percentiles in the distribution (e.g., the 2.5% percentile is below X, 97.5% is above Y, and the mean is at Z).</li>
<li>Report out the actual distribution as the result.</li>
</ol>
<p>Ideally, you should do all three.</p>
<p>The second major caveat is that this is not one model, but a whole host of models and these take up a large amount of disk space. In this example, our 25 models take up 25 times more space than our original model and it takes some time to read in, fit, and wrangle the results. We can trade disk space for computation time by writing a function that fits and predicts without saving a model, but again, that’s a tradeoff between speed and space. For linear models, it may be a better route to have STAN simulate thousands of results via <code>{rstanarm}</code> or <code>{brms}</code>, but for non-linear models, boostrapping is the best way to go for now!</p>
</div>
<div id="polling-bites" class="section level3">
<h3>Polling Bites</h3>
<p>Currently, the Generic Ballot is holding steady with a slight sliver more Americans wanting Republicans in Congress than Democrats (<strong>50.7%</strong> to <strong>49.3%</strong>, respectively). Joe Biden’s net approval continues to slide, currently sitting at <strong>-11.4%</strong> (<strong>41.8%</strong> approve, <strong>53.1%</strong> disapprove).</p>
<p><img src="pics/generic_ballot_current.png" /></p>
<p><img src="pics/approval_disapproval_current.png" /></p>
<p><img src="pics/net_approval_current.png" /></p>
</div>
