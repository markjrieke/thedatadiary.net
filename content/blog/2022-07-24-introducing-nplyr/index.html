---
title: Introducing {nplyr}
author: ''
date: '2022-07-24'
slug: []
categories: 
- rstats
- nplyr
tags: []
subtitle: A grammar of (nested) data manipulation
summary: ''
authors: []
lastmod: '2022-07-24T16:20:57-05:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---



<p>Data manipulation and transformation is a fundamental part of any analysis. There are excellent tools in the R ecosystem for manipulating data frames (<a href="https://dplyr.tidyverse.org/">dplyr</a>, <a href="https://rdatatable.gitlab.io/data.table/">data.table</a>, and <a href="https://arrow.apache.org/docs/r/">arrow</a>, to name a few). Sometimes, however, it is desirable to work with <em>nested</em> data frames, for which few tools are readily available.</p>
<p>This is where <a href="https://markjrieke.github.io/nplyr/">nplyr</a> comes into play! nplyr is a grammar of nested data manipulation that allows users to perform dplyr-like manipulations on data frames nested within a list-col of another data frame. Most dplyr verbs have nested equivalents in nplyr. For example:</p>
<ul>
<li><code>nest_mutate()</code> is the nested equivalent of <code>mutate()</code></li>
<li><code>nest_select()</code> is the nested equivalent of <code>select()</code></li>
<li><code>nest_filter()</code> is the nested equivalent of <code>filter()</code></li>
<li><code>nest_summarise()</code> is the nested equivalent of <code>summarise()</code></li>
<li><code>nest_group_by()</code> is the nested equivalent of <code>group_by()</code></li>
</ul>
<div id="installation" class="section level3">
<h3>Installation</h3>
<p>nplyr 0.1.0 is available on <a href="https://cran.r-project.org/web/packages/nplyr/index.html">CRAN</a>. Alternatively, you can install the development version from github with the <a href="https://cran.r-project.org/package=devtools">devtools</a> or <a href="https://cran.r-project.org/package=remotes">remotes</a> package:</p>
<pre class="r"><code># install from CRAN
install.packages(&quot;nplyr&quot;)

# install from github
devtools::install_github(&quot;markjrieke/nplyr&quot;)</code></pre>
</div>
<div id="usage" class="section level3">
<h3>Usage</h3>
<p>To get started, we’ll create a nested column for the country data within each continent from the <a href="https://cran.r-project.org/package=gapminder">gapminder</a> dataset.</p>
<pre class="r"><code>library(nplyr)

gm_nest &lt;-
  gapminder::gapminder_unfiltered %&gt;%
  tidyr::nest(country_data = -continent)

gm_nest</code></pre>
<pre><code>## # A tibble: 6 × 2
##   continent country_data        
##   &lt;fct&gt;     &lt;list&gt;              
## 1 Asia      &lt;tibble [578 × 5]&gt;  
## 2 Europe    &lt;tibble [1,302 × 5]&gt;
## 3 Africa    &lt;tibble [637 × 5]&gt;  
## 4 Americas  &lt;tibble [470 × 5]&gt;  
## 5 FSU       &lt;tibble [139 × 5]&gt;  
## 6 Oceania   &lt;tibble [187 × 5]&gt;</code></pre>
<p>dplyr can perform operations on the top-level data frame, but with nplyr, we can perform operations on the nested data frames:</p>
<pre class="r"><code>gm_nest_example &lt;-
  gm_nest %&gt;%
  nest_filter(country_data, year == max(year)) %&gt;%
  nest_mutate(country_data, pop_millions = pop/1000000)

# each nested tibble is now filtered to the most recent year
gm_nest_example</code></pre>
<pre><code>## # A tibble: 6 × 2
##   continent country_data     
##   &lt;fct&gt;     &lt;list&gt;           
## 1 Asia      &lt;tibble [43 × 6]&gt;
## 2 Europe    &lt;tibble [34 × 6]&gt;
## 3 Africa    &lt;tibble [53 × 6]&gt;
## 4 Americas  &lt;tibble [33 × 6]&gt;
## 5 FSU       &lt;tibble [9 × 6]&gt; 
## 6 Oceania   &lt;tibble [11 × 6]&gt;</code></pre>
<pre class="r"><code># if we unnest, we can see that a new column for pop_millions has been created
gm_nest_example %&gt;%
  slice_head(n = 1) %&gt;%
  tidyr::unnest(country_data)</code></pre>
<pre><code>## # A tibble: 43 × 7
##    continent country           year lifeExp        pop gdpPercap pop_millions
##    &lt;fct&gt;     &lt;fct&gt;            &lt;int&gt;   &lt;dbl&gt;      &lt;int&gt;     &lt;dbl&gt;        &lt;dbl&gt;
##  1 Asia      Afghanistan       2007    43.8   31889923      975.       31.9  
##  2 Asia      Azerbaijan        2007    67.5    8017309     7709.        8.02 
##  3 Asia      Bahrain           2007    75.6     708573    29796.        0.709
##  4 Asia      Bangladesh        2007    64.1  150448339     1391.      150.   
##  5 Asia      Bhutan            2007    65.6    2327849     4745.        2.33 
##  6 Asia      Brunei            2007    77.1     386511    48015.        0.387
##  7 Asia      Cambodia          2007    59.7   14131858     1714.       14.1  
##  8 Asia      China             2007    73.0 1318683096     4959.     1319.   
##  9 Asia      Hong Kong, China  2007    82.2    6980412    39725.        6.98 
## 10 Asia      India             2007    64.7 1110396331     2452.     1110.   
## # … with 33 more rows</code></pre>
<p>nplyr also supports grouped operations with <code>nest_group_by()</code>:</p>
<pre class="r"><code>gm_nest_example &lt;-
  gm_nest %&gt;%
  nest_group_by(country_data, year) %&gt;%
  nest_summarise(
    country_data,
    n = n(),
    lifeExp = median(lifeExp),
    pop = median(pop),
    gdpPercap = median(gdpPercap)
  )

gm_nest_example</code></pre>
<pre><code>## # A tibble: 6 × 2
##   continent country_data     
##   &lt;fct&gt;     &lt;list&gt;           
## 1 Asia      &lt;tibble [58 × 5]&gt;
## 2 Europe    &lt;tibble [58 × 5]&gt;
## 3 Africa    &lt;tibble [13 × 5]&gt;
## 4 Americas  &lt;tibble [57 × 5]&gt;
## 5 FSU       &lt;tibble [44 × 5]&gt;
## 6 Oceania   &lt;tibble [56 × 5]&gt;</code></pre>
<pre class="r"><code># unnesting shows summarised tibbles for each continent
gm_nest_example %&gt;%
  slice(2) %&gt;%
  tidyr::unnest(country_data)</code></pre>
<pre><code>## # A tibble: 58 × 6
##    continent  year     n lifeExp      pop gdpPercap
##    &lt;fct&gt;     &lt;int&gt; &lt;int&gt;   &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;
##  1 Europe     1950    22    65.8 7408264      6343.
##  2 Europe     1951    18    65.7 7165515      6509.
##  3 Europe     1952    31    65.9 7124673      5210.
##  4 Europe     1953    17    67.3 7346100      6774.
##  5 Europe     1954    17    68.0 7423300      7046.
##  6 Europe     1955    17    68.5 7499400      7817.
##  7 Europe     1956    17    68.5 7575800      8224.
##  8 Europe     1957    31    67.5 7363802      6093.
##  9 Europe     1958    18    69.6 8308052.     8833.
## 10 Europe     1959    18    69.6 8379664.     9088.
## # … with 48 more rows</code></pre>
</div>
<div id="other-use-cases" class="section level3">
<h3>Other use cases</h3>
<p>In the previous set of examples, the output from nplyr’s nested operations could be obtained by unnesting and performing grouped dplyr operations.</p>
<pre class="r"><code># we can use nplyr to perform operations on the nested data
gm_nest %&gt;%
  nest_filter(country_data, year == max(year)) %&gt;%
  nest_mutate(country_data, pop_millions = pop/1000000) %&gt;%
  slice_head(n = 1) %&gt;%
  tidyr::unnest(country_data)</code></pre>
<pre><code>## # A tibble: 43 × 7
##    continent country           year lifeExp        pop gdpPercap pop_millions
##    &lt;fct&gt;     &lt;fct&gt;            &lt;int&gt;   &lt;dbl&gt;      &lt;int&gt;     &lt;dbl&gt;        &lt;dbl&gt;
##  1 Asia      Afghanistan       2007    43.8   31889923      975.       31.9  
##  2 Asia      Azerbaijan        2007    67.5    8017309     7709.        8.02 
##  3 Asia      Bahrain           2007    75.6     708573    29796.        0.709
##  4 Asia      Bangladesh        2007    64.1  150448339     1391.      150.   
##  5 Asia      Bhutan            2007    65.6    2327849     4745.        2.33 
##  6 Asia      Brunei            2007    77.1     386511    48015.        0.387
##  7 Asia      Cambodia          2007    59.7   14131858     1714.       14.1  
##  8 Asia      China             2007    73.0 1318683096     4959.     1319.   
##  9 Asia      Hong Kong, China  2007    82.2    6980412    39725.        6.98 
## 10 Asia      India             2007    64.7 1110396331     2452.     1110.   
## # … with 33 more rows</code></pre>
<pre class="r"><code># in this case, we could have obtained the same result with tidyr and dplyr
gm_nest %&gt;%
  tidyr::unnest(country_data) %&gt;%
  group_by(continent) %&gt;%
  filter(year == max(year)) %&gt;%
  mutate(pop_millions = pop/1000000) %&gt;%
  ungroup() %&gt;%
  filter(continent == &quot;Asia&quot;)</code></pre>
<pre><code>## # A tibble: 43 × 7
##    continent country           year lifeExp        pop gdpPercap pop_millions
##    &lt;fct&gt;     &lt;fct&gt;            &lt;int&gt;   &lt;dbl&gt;      &lt;int&gt;     &lt;dbl&gt;        &lt;dbl&gt;
##  1 Asia      Afghanistan       2007    43.8   31889923      975.       31.9  
##  2 Asia      Azerbaijan        2007    67.5    8017309     7709.        8.02 
##  3 Asia      Bahrain           2007    75.6     708573    29796.        0.709
##  4 Asia      Bangladesh        2007    64.1  150448339     1391.      150.   
##  5 Asia      Bhutan            2007    65.6    2327849     4745.        2.33 
##  6 Asia      Brunei            2007    77.1     386511    48015.        0.387
##  7 Asia      Cambodia          2007    59.7   14131858     1714.       14.1  
##  8 Asia      China             2007    73.0 1318683096     4959.     1319.   
##  9 Asia      Hong Kong, China  2007    82.2    6980412    39725.        6.98 
## 10 Asia      India             2007    64.7 1110396331     2452.     1110.   
## # … with 33 more rows</code></pre>
<p>Why, then, might we need to use nplyr? Well, in other scenarios, it may be far more convenient to work with nested data frames or it may not even be possible to unnest!</p>
<p>Consider a set of surveys that an organization might use to gather market data. It is common for organization to have separate surveys for separate purposes but to gather the same baseline set of data across all surveys (for example , a respondent’s age and gender may be recorded across all surveys, but each survey will have a different set of questions). Let’s use two fake surveys with the below questions for this example:</p>
<div id="survey-1-job" class="section level6">
<h6>Survey 1: Job</h6>
<ol style="list-style-type: decimal">
<li>How old are you? (multiple choice)</li>
<li>What city do you live in? (multiple choice)</li>
<li>What field do you work in? (multiple choice)</li>
<li>Overall, how satisfied are you with your job? (multiple choice)</li>
<li>What is your annual salary? (numeric entry)</li>
</ol>
</div>
<div id="survey-2-personal-life" class="section level6">
<h6>Survey 2: Personal Life</h6>
<ol style="list-style-type: decimal">
<li>How old are you? (multiple choice)</li>
<li>What city do you live in? (multiple choice)</li>
<li>What field do you work in? (mulitple choice)</li>
<li>Overall, how satisfied are you with your personal life (multiple choice)</li>
<li>Please provide any additional detail (text entry)</li>
</ol>
<p>In this scenario, both surveys are collecting demographic information — age, location, and industry — but differ in the remaining questions. A convenient way to get the response files into the environment would be to use <code>purrr::map()</code> to read each file to a nested data frame.</p>
<pre class="r"><code>path &lt;- &quot;https://raw.githubusercontent.com/markjrieke/nplyr/main/data-raw/&quot;

surveys &lt;- 
  tibble::tibble(survey_file = c(&quot;job_survey&quot;, &quot;personal_survey&quot;)) %&gt;%
  mutate(survey_data = purrr::map(survey_file, ~readr::read_csv(paste0(path, .x, &quot;.csv&quot;))))

surveys</code></pre>
<pre><code>## # A tibble: 2 × 2
##   survey_file     survey_data            
##   &lt;chr&gt;           &lt;list&gt;                 
## 1 job_survey      &lt;spec_tbl_df [500 × 6]&gt;
## 2 personal_survey &lt;spec_tbl_df [750 × 6]&gt;</code></pre>
<p><code>tidyr::unnest()</code> can usually handle idiosyncracies in layout when unnesting, but in this case unnesting throws an error!</p>
<pre class="r"><code>surveys %&gt;%
  tidyr::unnest(survey_data)</code></pre>
<pre><code>## Error:
## ! Can&#39;t combine `Q5` &lt;double&gt; and `Q5` &lt;character&gt;.</code></pre>
<p>This is because the surveys share column names but not necessarily column types! In this case, both data frames contain a column named <code>Q5</code>, but in <code>job_survey</code> it’s a double and in <code>personal_survey</code> it’s a character.</p>
<pre class="r"><code>surveys %&gt;%
  slice(1) %&gt;%
  tidyr::unnest(survey_data) %&gt;%
  glimpse()</code></pre>
<pre><code>## Rows: 500
## Columns: 7
## $ survey_file &lt;chr&gt; &quot;job_survey&quot;, &quot;job_survey&quot;, &quot;job_survey&quot;, &quot;job_survey&quot;, &quot;j…
## $ survey_name &lt;chr&gt; &quot;job&quot;, &quot;job&quot;, &quot;job&quot;, &quot;job&quot;, &quot;job&quot;, &quot;job&quot;, &quot;job&quot;, &quot;job&quot;, &quot;j…
## $ Q1          &lt;dbl&gt; 100, 81, 51, 81, 80, 32, 65, 57, 43, 94, 25, 83, 61, 66, 8…
## $ Q2          &lt;chr&gt; &quot;Austin&quot;, &quot;San Antonio&quot;, &quot;Austin&quot;, &quot;Austin&quot;, &quot;Dallas&quot;, &quot;Fo…
## $ Q3          &lt;chr&gt; &quot;Consulting&quot;, &quot;Consulting&quot;, &quot;Consulting&quot;, &quot;Technology&quot;, &quot;C…
## $ Q4          &lt;chr&gt; &quot;Somewhat dissatisfied&quot;, &quot;Neither satisfied nor dissatisfi…
## $ Q5          &lt;dbl&gt; 163, 48, 190, 25, 143, 233, 43, 243, 158, 235, 245, 195, 2…</code></pre>
<pre class="r"><code>surveys %&gt;%
  slice(2) %&gt;%
  tidyr::unnest(survey_data) %&gt;%
  glimpse()</code></pre>
<pre><code>## Rows: 750
## Columns: 7
## $ survey_file &lt;chr&gt; &quot;personal_survey&quot;, &quot;personal_survey&quot;, &quot;personal_survey&quot;, &quot;…
## $ survey_name &lt;chr&gt; &quot;personal&quot;, &quot;personal&quot;, &quot;personal&quot;, &quot;personal&quot;, &quot;personal&quot;…
## $ Q1          &lt;dbl&gt; 91, 32, 40, 23, 88, 69, 96, 40, 57, 40, 39, 70, 29, 38, 57…
## $ Q2          &lt;chr&gt; &quot;Austin&quot;, &quot;San Antonio&quot;, &quot;San Antonio&quot;, &quot;Austin&quot;, &quot;Dallas&quot;…
## $ Q3          &lt;chr&gt; &quot;Energy&quot;, &quot;Healthcare&quot;, &quot;Consulting&quot;, &quot;Consulting&quot;, &quot;Techn…
## $ Q4          &lt;chr&gt; &quot;Neither satisfied nor dissatisfied&quot;, &quot;Extremely satisfied…
## $ Q5          &lt;chr&gt; &quot;Blandit eros! A, ligula facilisis imperdiet! Interdum pla…</code></pre>
<p>We could potentially get around this issue with unnesting by reading in all columns as characters via <code>readr::read_csv(x, col_types = cols(.default = "c"))</code>, but this presents its own challenges. <code>Q5</code> would still be better represented as a double in <code>job_survey</code> and, from the survey question text, <code>Q4</code> has similar, but distinctly different, meanings across the survey files.</p>
<p>This is where nplyr can assist! Rather than malign the data types or create separate objects for each survey file, we can use nplyr to perform operations directly on the nested data frames.</p>
<pre class="r"><code>surveys &lt;- 
  surveys %&gt;%
  nest_mutate(survey_data,
              age_group = if_else(Q1 &lt; 65, &quot;Adult&quot;, &quot;Retirement Age&quot;)) %&gt;%
  nest_group_by(survey_data, Q3) %&gt;%
  nest_add_count(survey_data, 
                 name = &quot;n_respondents_in_industry&quot;) %&gt;%
  nest_mutate(survey_data, 
              median_industry_age = median(Q1)) %&gt;%
  nest_ungroup(survey_data)

surveys %&gt;%
  slice(1) %&gt;%
  tidyr::unnest(survey_data)</code></pre>
<pre><code>## # A tibble: 500 × 10
##    survey_file survey_name    Q1 Q2          Q3            Q4       Q5 age_group
##    &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;         &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;    
##  1 job_survey  job           100 Austin      Consulting    Some…   163 Retireme…
##  2 job_survey  job            81 San Antonio Consulting    Neit…    48 Retireme…
##  3 job_survey  job            51 Austin      Consulting    Extr…   190 Adult    
##  4 job_survey  job            81 Austin      Technology    Extr…    25 Retireme…
##  5 job_survey  job            80 Dallas      Consulting    Extr…   143 Retireme…
##  6 job_survey  job            32 Fort Worth  Energy        Some…   233 Adult    
##  7 job_survey  job            65 Dallas      Consulting    Some…    43 Retireme…
##  8 job_survey  job            57 Houston     Healthcare    Some…   243 Adult    
##  9 job_survey  job            43 Dallas      Government S… Neit…   158 Adult    
## 10 job_survey  job            94 Fort Worth  Healthcare    Extr…   235 Retireme…
## # … with 490 more rows, and 2 more variables: n_respondents_in_industry &lt;int&gt;,
## #   median_industry_age &lt;dbl&gt;</code></pre>
<pre class="r"><code>surveys %&gt;%
  slice(2) %&gt;%
  tidyr::unnest(survey_data)</code></pre>
<pre><code>## # A tibble: 750 × 10
##    survey_file     survey_name    Q1 Q2          Q3        Q4    Q5    age_group
##    &lt;chr&gt;           &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;    
##  1 personal_survey personal       91 Austin      Energy    Neit… Blan… Retireme…
##  2 personal_survey personal       32 San Antonio Healthca… Extr… Elem… Adult    
##  3 personal_survey personal       40 San Antonio Consulti… Some… Eget… Adult    
##  4 personal_survey personal       23 Austin      Consulti… Extr… Scel… Adult    
##  5 personal_survey personal       88 Dallas      Technolo… Neit… Aene… Retireme…
##  6 personal_survey personal       69 Fort Worth  Technolo… Neit… Inte… Retireme…
##  7 personal_survey personal       96 Houston     Healthca… Extr… Blan… Retireme…
##  8 personal_survey personal       40 Houston     Consulti… Extr… Scel… Adult    
##  9 personal_survey personal       57 Fort Worth  Energy    Extr… Pede… Adult    
## 10 personal_survey personal       40 Fort Worth  Healthca… Extr… Phar… Adult    
## # … with 740 more rows, and 2 more variables: n_respondents_in_industry &lt;int&gt;,
## #   median_industry_age &lt;dbl&gt;</code></pre>
</div>
</div>
