[
  {
    "objectID": "posts/2021-01-17-r-ggplot2-plotly/index.html",
    "href": "posts/2021-01-17-r-ggplot2-plotly/index.html",
    "title": "R, ggplot2, & plotly",
    "section": "",
    "text": "Editor’s note: I’ve gone back & read my previous post, & have one general thought - yeeeesh… Everything is so… “matter of fact” in tone & doesn’t really sound like me. I’ll give myself a pass, since it was the first post, was written around midnight (which is very late for me!), and probably won’t ever be read by anyone besides me/my mom (hi mom!). That being said, I’m going to try to make a more conscious effort going forward of having my voice be expressed in my writing. This is my blog, after all, so it should sound like my voice when read back.\n\n\nPlotting in R\nI’ve started getting more familiar with R & wrangling my way through a few plotting examples (Youtube university is, once again, my best friend), but I thought it would be worthwhile to work towards plotting my own dataset. Luckily enough, plotting with R is pretty intuitive, once you get ahold of the basic syntax. I had put together a dataset on past US presidential elections for a separate personal project, and was able to convert to a .csv to use for some basic plotting practice.\nIt’s generally well understood that the Republican party has a structural advantage in presidential elections due to the winner-take-all nature of the electoral college, but I wanted to see if I could quantify this advantage in an understandable format using R. I used the ggplot2, dplyr, and plotly packages to put this together.\n\n\nPutting Together the Plot\nI imported the entire dataset and assigned it to a dataframe (R’s version of, say, an excel table). Using the base R plot() function, I plotted the entire dataframe:\n\nWithout specifying which variables I want to look at, plot() will output a set of summary plots, with every variable plotted against every other variable. This isn’t great for gathering any meaningful insight, but helps get a “lay of the land” view of the dataframe. In this case, I’m interested in how the percentage of the popular vote a candidate wins is related to the percentage of the electoral vote they win. Using plot(), I can graph popular_vote_pct and electoral_vote_pct variables from the dataframe:\n\nFigure 2 shows the basic data I want to represent, but there’s a lot of noise. The dataset includes every major candidate in every election since Washington’s run for re-election in 1788. I’m really only interested in the modern two-party system, so I filtered out the elections prior to 1952, as well as any candidate that won 0 electoral votes (i.e., third parties). The new, filtered plot is shown in Figure 3, below:\n\nNow, with all the data manipulation squared away, I can start with the fun part: making it look good! ggplot’s base plot is, right off the bat, just a bit nicer looking than base R’s plot() function:\n\nggplot color maps very easily, and with a little googling (aka - jumping through multiple color converters online to convert colors from hexadecimal to rgb to hcl), I was able to make some formatting changes that give the below static chart:\n\nDespite some frustrations (more on that, below), I was able to add a simple linear regression to the plot, with the shaded bands representing the 95% confidence interval for each regression. Since the Republican regression is above the Democratic regression, the chart implies that, for a given share of popular vote, Republican candidates on average win a larger share of the electoral college than their Democratic counterparts.\n\nThis finding matches the general consensus and my prior expectations, but I also found something mildly surprising. Ideally, I would imagine, we’d want a candidate’s share of the electoral vote to match their share of the popular vote. However, if I add a reference line of y = x, we can see that both parties tend to underperform in the electoral college when they lose the popular vote, but overperform in the electoral college when they win the popular vote!\n\nI plotted the absolute vote share from published election results, rather than the two-party vote share (2PV) (i.e., the percentage of vote won if only the top two candidates are considered). Converting to the 2PV would shift the plot to the right, but keep the same overall trend, as Democrats and Republicans have won 100% of the electoral college since 1952. This exercise was more about exploring R’s ggplot() function, so going back into the dataset to account for this marginal change doesn’t seem like an efficient use of time, but I did want to make a note of it, for transparency’s sake.\nFinally, I used the ggplotly() to convert from a static ggplot to an interactive plotly, and exported as an html file. For reasons I’ve yet to figure out, the custom textbox formatting did not want to play nice with the linear regression lines, so I had to take those out. I plan on figuring this wrinkle out eventually, but for now I’m happy with the final plot. You can hover over individual datapoints below to see more details!\n\nThis is an archive of a post previously hosted on Squarespace. You can view the original interactive content here.\n\n\n\nSome Notes\nI’ve published all of my work to github, and I’ll continue to do so in the future. The files I uploaded are, to say the least, in pretty rough shape. That being said, I don’t really plan on tweaking them for this post - I’ve used them as training tools, and it might be interesting in the future to look at the progress I’ve made.\nAlso, I just realized that the interactive plotly chart looks like junk when viewed via mobile (the data points and labels don’t resize automatically). I’ll have to figure out a way to fix this in the future… Maybe I can set the point size as a ratio of the plot width? It’s something to think about, but again, I’m happy with my first run using ggplot & plotly.\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {R, Ggplot2, \\& Plotly},\n  date = {2021-01-17},\n  url = {https://www.thedatadiary.net/posts/2021-01-17-r-ggplot2-plotly},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “R, Ggplot2, & Plotly.” January 17,\n2021. https://www.thedatadiary.net/posts/2021-01-17-r-ggplot2-plotly."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "the data diary",
    "section": "",
    "text": "Trump vs. Desantis in 2024 Republican Primary Polling\n\n\n\npolitics\n\n\nbayes\n\n\nstan\n\n\n\nMixed scales lead to mixed results\n\n\n\nMark Rieke\n\n\nJan 21, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMy 2022 Magnum Opus\n\n\n\nrstats\n\n\nstan\n\n\nbayes\n\n\nhealthcare\n\n\n\nOrdered categorical models for estimating Net Promoter Score: a hierarchical Bayesian implementation\n\n\n\nMark Rieke\n\n\nDec 30, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChief Twit\n\n\n\nrstats\n\n\n\nA causal look at how Musk’s twitter ownership has affected Tesla stock\n\n\n\nMark Rieke\n\n\nDec 16, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHierarchical Hospitals\n\n\n\nrstats\n\n\nstan\n\n\nbayes\n\n\nhealthcare\n\n\n\nMultilevel Models for Patient Satisfaction\n\n\n\nMark Rieke\n\n\nNov 14, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nForecast Launch!\n\n\n\npolitics\n\n\n\nA look under the hood of the 2022 Midterm Model\n\n\n\nMark Rieke\n\n\nSep 19, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinding new wedding bops with {tidyclust} and {spotifyr}\n\n\n\nrstats\n\n\ntidymodels\n\n\n\n\n\n\n\nMark Rieke\n\n\nAug 20, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroducing {nplyr}\n\n\n\nrstats\n\n\nnplyr\n\n\n\n\n\n\n\nMark Rieke\n\n\nJul 24, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Math Behind workboots\n\n\n\nrstats\n\n\nworkboots\n\n\ntidymodels\n\n\n\n\n\n\n\nMark Rieke\n\n\nJul 5, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEstimate your uncertainty\n\n\n\nrstats\n\n\nbayes\n\n\n\n\n\n\n\nMark Rieke\n\n\nJun 12, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPractical Data Visualization Tips for Excel Users\n\n\n\nrstats\n\n\n\n\n\n\n\nMark Rieke\n\n\nMay 31, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n“30 is not Statistical”\n\n\n\nrstats\n\n\n\n\n\n\n\nMark Rieke\n\n\nApr 28, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImpeachment Republicans and Democracy\n\n\n\npolitics\n\n\n\n\n\n\n\nMark Rieke\n\n\nApr 6, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroducing {workboots}\n\n\n\nrstats\n\n\ntidymodels\n\n\nworkboots\n\n\n\nGenerate bootstrap prediction intervals from a tidymodel workflow!\n\n\n\nMark Rieke\n\n\nMar 14, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Data Science Hierarchy of Needs\n\n\n\nrstats\n\n\n\nWhy you should put a roof on your house before hiring an interior decorator\n\n\n\nMark Rieke\n\n\nFeb 22, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPull Yourself Up by Your Bootstraps\n\n\n\nrstats\n\n\ntidymodels\n\n\n\n\n\n\n\nMark Rieke\n\n\nFeb 8, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHow Popular is Joe Biden?\n\n\n\npolitics\n\n\n\nBuilding a Presidential Approval Model\n\n\n\nMark Rieke\n\n\nJan 26, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Data Diary: Year in Review\n\n\n\npersonal\n\n\n\n\n\n\n\nMark Rieke\n\n\nJan 12, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDo Voters Want Democrats or Republicans in Congress?\n\n\n\npolitics\n\n\n\nBuilding a Generic Ballot Poll Aggregator\n\n\n\nMark Rieke\n\n\nDec 14, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTechnical Books!\n\n\n\nrstats\n\n\n\n\n\n\n\nMark Rieke\n\n\nNov 28, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiamonds are Forever\n\n\n\ntidymodels\n\n\n\nFeature Engineering with the Diamonds Dataset\n\n\n\nMark Rieke\n\n\nNov 14, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nElection Night: Some Closing Thoughts on the VA Governor Race\n\n\n\npolitics\n\n\n\n\n\n\n\nMark Rieke\n\n\nNov 2, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPolling Average of the VA Governor’s Race using purrr::map functions\n\n\n\npolitics\n\n\n\n\n\n\n\nMark Rieke\n\n\nOct 19, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRStudio’s Call for Documentation\n\n\n\narchive\n\n\nrstats\n\n\n\n\n\n\n\nMark Rieke\n\n\nOct 5, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCatching Up (again)\n\n\n\narchive\n\n\n\n\n\n\n\nMark Rieke\n\n\nSep 23, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTidymodels and the Titanic\n\n\n\narchive\n\n\nrstats\n\n\ntidymodels\n\n\n\n\n\n\n\nMark Rieke\n\n\nAug 8, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Gas Price Fallacy\n\n\n\narchive\n\n\npolitics\n\n\n\n\n\n\n\nMark Rieke\n\n\nJul 18, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBlexas?\n\n\n\narchive\n\n\npolitics\n\n\n\n\n\n\n\nMark Rieke\n\n\nJul 11, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCOVID Cases Improve with Introduction of Vaccines\n\n\n\narchive\n\n\n\n\n\n\n\nMark Rieke\n\n\nJun 3, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPresident of the Polls\n\n\n\narchive\n\n\npolitics\n\n\n\n\n\n\n\nMark Rieke\n\n\nMay 5, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA Lukewarm Case for DC Statehood\n\n\n\narchive\n\n\npolitics\n\n\n\n\n\n\n\nMark Rieke\n\n\nApr 27, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCatching Up\n\n\n\narchive\n\n\n\n\n\n\n\nMark Rieke\n\n\nApr 20, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSeasonality is a Weak Predictor of Border Crossings\n\n\n\narchive\n\n\npolitics\n\n\n\n\n\n\n\nMark Rieke\n\n\nApr 5, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRecent Works\n\n\n\narchive\n\n\n\n\n\n\n\nMark Rieke\n\n\nMar 15, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\naRtwork!\n\n\n\narchive\n\n\n\n\n\n\n\nMark Rieke\n\n\nMar 7, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDoug Collins Saved Raphael Warnock’s Senate Bid\n\n\n\narchive\n\n\npolitics\n\n\n\n\n\n\n\nMark Rieke\n\n\nFeb 28, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(Kind of) Projecting the 2020 Election\n\n\n\narchive\n\n\npolitics\n\n\n\n\n\n\n\nMark Rieke\n\n\nFeb 21, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScorecasting\n\n\n\narchive\n\n\npolitics\n\n\n\n\n\n\n\nMark Rieke\n\n\nFeb 14, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSome Worthwhile Links\n\n\n\narchive\n\n\n\n\n\n\n\nMark Rieke\n\n\nFeb 8, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Min-Wage Debate\n\n\n\narchive\n\n\npolitics\n\n\n\n\n\n\n\nMark Rieke\n\n\nJan 31, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYour Doctor Probably Isn’t an Idiot\n\n\n\narchive\n\n\nbayes\n\n\n\n\n\n\n\nMark Rieke\n\n\nJan 24, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR, ggplot2, & plotly\n\n\n\narchive\n\n\n\n\n\n\n\nMark Rieke\n\n\nJan 17, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBaby Steps\n\n\n\narchive\n\n\n\n\n\n\n\nMark Rieke\n\n\nJan 10, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHello World!\n\n\n\narchive\n\n\n\n\n\n\n\nMark Rieke\n\n\nJan 9, 2021\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2021-01-10-baby-steps/index.html",
    "href": "posts/2021-01-10-baby-steps/index.html",
    "title": "Baby Steps",
    "section": "",
    "text": "An Uphill Battle\nToday marks the beginning of what I imagine will be a long journey, with a significant number of hiccups & frustrations along the way. The end goal I have is to build out an election forecast model (in the spirit of FiveThirtyEight & The Economist), but along the way, I plan on getting better at a few things:\n\nWriting : while I’ve never been a poor writer, I’ve always gravitated more toward math & science, & in my career as an engineer, a good amount of my communication has been visual. If possible, I’ve always preferred to leave words off the page & have a chart speak for me. While I still think that, in general, its better the explain a concept visually (a picture vs. a thousand words, and all), I also believe supplementing a visual with my a well written analysis & opinion can improve its reception.\nStats : in my current job, almost everything I model is deterministic, rather than probabilistic (physical systems tend to behave the way that natural laws expect them to). It has been a long time since I’ve done any sort of stats work (& it was all basic introductory analyses), so I expect an uphill battle with getting my head wrapped around Bayes’ Theorem, Monte Carlo simulations, Brier’s Tests, etc.\nCoding : most of my experience in coding is with VBA - typically just for manipulating data in Excel. I’ve built out a good number of forms using VBA, but don’t typically tend to dig into anything far beyond simple manipulation. The front end of Excel is effectively setup as a visual programming tool, so there’s not a great incentive to do much array manipulation outside of the spreadsheet. Excel is a wonderful tool, & is sufficient for my current job, but I’ve definitely found where its limits lie. I’m excited to dig into R, the stats based program that seems almost to be designed specifically for what I’d like to do.\n\n\n\nThe First Plot\nR has a few sample datasets, and r:base includes a pretty basic plot function. With the sample set, cars, I made a quick plot of the stopping distance vs. the speed.\n\n\nCode\nplot(cars)\n\n\n\n\n\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {Baby {Steps}},\n  date = {2021-01-10},\n  url = {https://www.thedatadiary.net/posts/2021-01-10-baby-steps},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “Baby Steps.” January 10, 2021. https://www.thedatadiary.net/posts/2021-01-10-baby-steps."
  },
  {
    "objectID": "posts/2021-01-09-hello-world/index.html",
    "href": "posts/2021-01-09-hello-world/index.html",
    "title": "Hello World!",
    "section": "",
    "text": "I’m currently setting up the website & will have an official post soon(ish).\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {Hello {World!}},\n  date = {2021-01-09},\n  url = {https://www.thedatadiary.net/posts/2021-01-09-hello-world},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “Hello World!” January 9, 2021. https://www.thedatadiary.net/posts/2021-01-09-hello-world."
  },
  {
    "objectID": "posts/2021-01-24-your-doctor-probably-isn-t-an-idiot/index.html",
    "href": "posts/2021-01-24-your-doctor-probably-isn-t-an-idiot/index.html",
    "title": "Your Doctor Probably Isn’t an Idiot",
    "section": "",
    "text": "There’s a great standup routine about doctors (which I spent about an hour trying to find online with no luck!) with a punchline to the effect of, “getting a positive cancer test then requesting a second opinion is basically the medical equivalent of telling your doctor you think they’re an idiot to their face.” The joke makes sense in context (and is a lot funnier to hear, rather than read), and is logical at a general level (why would a patient, who probably isn’t a medical expert, be able to say that a doctor’s assessment is wrong?), but there’s a hidden nugget of nuance about cancer screenings missed by the joke that make them such an interesting introduction to one of the foundational equations in statistics, Bayes’ Theorem.\n\nWhat is Bayes’ Theorem?\nTo understand Bayes’ Theorem, it’s probably best to get a grasp on frequency-based probability, which is often considered the contrast of bayesian/uncertainty-based probability. Consider a perfectly ideal coin flip. I know that, for any given coin flip, the probabilities of landing either heads-up or tails-up are exactly the same: 50%. Moreover, this is true no matter how many times I flip the coin. If the coin lands heads-up on the first flip, I still have a 50% chance of the coin landing heads-up on the next flip (and the next flip, and the next flip, etc.).\nBut what if I’m told the coin has a manufacturing defect, and is slightly heavier on one side (lets say, to favor tails-up)? I might assume, starting out, that the defect is small, and has a negligible effect on my odds of the coin landing heads-up. But every flip that lands tails-up changes my certainty about the true odds. That’s the heart of Bayes’ Theorem, and the biggest difference between bayesian statistics and frequentist statistics. With frequentist statistics, when the data updates, the uncertainty stays the same, whereas with bayesian statistics, when the data updates, the uncertainty updates as well.\nSo why is this important? Well, at a base level, just about every forecasting model needs to make use of Bayes’ Theorem. So with the long term goal of building a predictive election model, it’s pretty dang important to have a firm understanding of the foundation the model will rest on. But in a more general sense, I think it’s important to understand how views can (and should) update in the light of new data. From what I can tell, the majority of opinions (especially political opinions…) are either based on assumptions or cherry-picked data points, and typically don’t update - even when presented with new evidence. In contrast, to think like a bayesian is to weigh the severity of new information against the history of data and update your views accordingly.\n\n\nUgly vs. Pretty Bayes\n\nEquation 1 above shows Bayes’ Theory. As expressed in statistical language, it reads, “the probability of A, given event B, is equal to the probability of B, given event A, and the probability of A divided by the probability of B.” As written, Bayes’ Theorem is… unintuitive… Even reading the description back to myself stirs up memories of fumbling through my high school stats class. The way the equation is written doesn’t lend itself towards being accessible, but, as Grant Sanderson points out in this video, reframing the equation into a geometry problem makes Bayes’ Theorem much easier to understand (much of the rest of this post is applying Bayes’ Theorem via Grant’s geometrical framing).\nTo understand how a geometrical framing can help make sense of Bayes’ Theorem, it’s best to run through an example. So let’s get back to the doctor’s office & cancer screening.\nLet’s first consider a population group of 10,000, arranged on a grid of 100 x 100. If we know that 1% of the population has cancer, we can divide the group into two segments, cancer-free and cancerous, as shown below:\n\nIf we avoid any compounding risk factors (like age, sex, diet, etc.) & assume that the likelihood of having cancer is the same for everyone, any person in the population can say that they are 99% certain that they do not have cancer. But how might this certainty update for someone who gets a positive result from a cancer screening test?\nThe reliability of cancer screening tests are measured by their sensitivity & specificity. A test’s sensitivity is the the proportion of cancer-positive patients it correctly identifies (i.e., “true positives”). For example, if a screening test has a sensitivity of 90% and is used to test 100 cancerous patients, we’d expect 90 of these patients to receive a correct positive result and the remaining 10 patients to receive an incorrect negative result. The specificity, on the other hand, is the proportion of cancer-free patients the test correctly identifies. If the screening test’s specificity is 92% and is used to test 100 cancer-free patients, we’d expect 92 patients to correctly receive a negative result and 8 patients to incorrectly receive a positive result (a “false positive”). I tend to find it easier just to think about the positive cases, so from now on, I’ll refer to a test’s true positive rate and false positive rate, rather than the sensitivity & specificity.\nLet’s assume that a cancer screening test has the true positive & false positive rates above, 90% & 8%, respectively. How certain should someone who tests positive be that they truly have cancer? A test that gives a true positive 90% of the time seems pretty damning, but the 8% false positive rate isn’t insignificant. An important step is to realize that this person is no longer looking for the probability of having cancer, but instead looking for the probability of having cancer given that they have a positive test result.\n\nFor someone who receives a positive test result, it may be helpful to think about the hypothetical question: “What if everyone took this test?” This reframing can help us think in terms of people, rather than probabilities.\nGiven that 1% of the 10,000 person population has cancer, we can divide the group into two segments: 100 people with cancer, and 9,900 people without cancer.\n\nIf everyone takes the screening test, we’d expect 90 true positives (90% x 100 = 90) and a whopping 792 false positives (8% x 9,900 = 792)!\n\nAlthough the test is fairly accurate in terms of sensitivity & specificity (90% and 92% are both considered A’s, by most grading standards) the sheer number of non-cancerous people in the population results in a large number of false positives. Of all the 882 positive cases (792 + 90 = 882), only 90 are true positives, meaning that the probability of having cancer given a positive test result is about 10% (90 / 882 = 10.2%). While this is a significant increase from the prior assumption, 1%, it’s still far likelier that someone with one positive test result doesn’t have cancer. This is why it’s important to get a second opinion. It’s not that your first doctor is an idiot, just that your uncertainty has changed!\nNow what would happen if all the people who received a positive result took another test? Well, of this subset of 882 patients, we expect that 792 are cancer free and 90 are cancerous:\n\nWhen these 882 patients take the second test, we still expect the test to hold the same true positive & false positive rates - meaning we can expect 81 true positives (90% x 90 = 81) and about 63 false positives (8% x 792 = 63). This means that, of the 144 positive cases (81 + 63 = 144), 81 are true positives, and the probability of having cancer given two positive results is about 56% (81 / 144 = 56%).\n\nWith this new round of data from test results, those who receive a second positive result once again update their prior assumption from 10% to 56%. In fact, every test result, positive or negative, should either support or refute the prior. Each positive test result, appropriately, increases your likelihood of actually having cancer. Similarly, each negative result decreases your likelihood.\n\nThat’s the beauty of Bayes’ Theorem in a nutshell. Gathering new information allows you to update your prior belief!\n\n\nIn Summary…\nI may have gotten too in the weeds with this post, though, to be fair, walking through Bayes’ Theorem in detail also helps my understanding. I likely wont dive as deep into stats topics in the future. In part, they’re a bit of a slog to read through if you’re not as excited as I am by this kind of stuff. But it also took me a good chunk of time to write this post. Going forward, I’d like to better balance my time between the three goals of coding, writing, and learning stats.\nAs always, I’ve posted my work to github, though this file just includes an excel workbook & a few pictures. Next week, I’ll dig more into plotting with ggplot - likely with a much shorter post!\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {Your {Doctor} {Probably} {Isn’t} an {Idiot}},\n  date = {2021-01-24},\n  url = {https://www.thedatadiary.net/posts/2021-01-24-your-doctor-probably-isn-t-an-idiot},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “Your Doctor Probably Isn’t an Idiot.”\nJanuary 24, 2021. https://www.thedatadiary.net/posts/2021-01-24-your-doctor-probably-isn-t-an-idiot."
  },
  {
    "objectID": "posts/2021-01-31-the-min-wage-debate/index.html",
    "href": "posts/2021-01-31-the-min-wage-debate/index.html",
    "title": "The Min-Wage Debate",
    "section": "",
    "text": "On January 26, House Democrats introduced a bill to raise the federal minimum wage from $7.25 per hour to $15 per hour by 2025. In the weeks leading up to the introduction, there’s been an influx on twitter of bad faith attacks, outright factually incorrect statements, and the type of fact-free arguments that pundits love (to be fair, my twitter timeline is biased towards my left-leaning friends, so the majority of what I see are poorly formulated left-leaning takes, but it’s pretty easy to find similarly bad right-leaning takes). The slew of emotion-driven arguments muddies the water around the minimum wage discussion by avoiding references to data. In an effort to find the signal in all this noise, I dug into publicly available databases to hopefully provide at least one opinion grounded in empiricism, rather than emotion.\n\nMy Priors\nFor transparency’s sake, prior to taking a look into the data behind the minimum wage debate, I was of the belief that the minimum wage should increase and that the proposed $15 per hour seemed reasonable. I didn’t have an empirically driven reason for this belief, just a vague sense that the minimum wage hadn’t risen in a while and had therefore effectively been deflating. Anecdotally, I also hadn’t seen a good defense of keeping the minimum wage static (in fact, most of the arguments against raising the minimum wage that I’d seen were laughably bad). My prior was built on little data, so the analysis I set out to do would either strongly confirm or refute it.\n\n\nThe History of the Minimum Wage\nIn 1947, the federal government introduced a minimum wage for hourly-compensated labor as part of an amendment to the Fair Labor Standards Act (FLSA). First set at $0.40 per hour, the minimum wage has risen periodically throughout its 80 year history - most recently rising to $7.25 per hour in 2009. Currently, 29 states and D.C. have state minimum wages greater than the minimum wage, and several state minimum wages are increasing in 2021 (either due to ballot initiatives or automatic increases based on cost of living).\nI’ve seen a theory float around that, had the minimum wage risen with inflation, it would be $22 per hour today, rather than $7.25 per hour. This is pretty overtly false.* Using the consumer price index (CPI) as the standard measure of inflation, the nominal minimum wage throughout the years can be adjusted to real (aka, inflation-adjusted) dollars:\nIn inflation-adjusted terms, the minimum wage peaked around 1968 at $12.20 per hour ($1.60 per hour, unadjusted). The current minimum wage of $7.25 per hour, while on the lower end of inflation-adjusted historical values, is not the lowest it’s ever been, and a $15 per hour minimum wage would set a new record for both adjusted and unadjusted minimum wage. Critics of the proposed increase may point to this as reason to keep the minimum wage at its current value - why increase the minimum wage beyond its historical high if it hasn’t even reached its historical low? Supporters, on the other hand, may argue that the minimum wage has never been enough.\n\n\nThe Minimum Wage’s Dance Between Two Thresholds\nIn 1978, the Census Bureau and Department of Health and Human Services set a baseline administrative threshold to determine eligibility for financial assistance from the federal government. Dubbed the “poverty threshold,” this value was created based on an approximation of the annual budget various family units require to meet basic food & shelter needs (for example, a single adult with no children would need to earn less per hour to meet his needs than, say, a nuclear family of two working adults and two children). The Census Bureau updates the threshold annually by simply adjusting for inflation.\nMany groups, however, argue that the poverty threshold doesn’t meet basic needs and instead advocate for a living wage. The living wage is similar in concept to the poverty threshold, but generally much higher, as it includes an expanded food budget (the poverty threshold is based on USDA’s “thrifty” food plan), a budget cap on rent (generally set at ~30% of a monthly budget), healthcare, and childcare, amongst other additions.\nBased on MIT Lab’s Living Wage Calculator, we can see that, for a family of four with two working adults, the minimum wage has historically been marginally greater than the poverty threshold, but never reaches (or approaches) the living wage:\n\nFigure 2, above, shows the national minimum and living wages, but these values vary by location. Figure 3 below shows the minimum and living wages for each state. Even states with minimum wages greater than the federal minimum do not meet the local living wage:\n\n\n\nThe Proposed Increase\nSo how does the proposed increase to the minimum wage fare against the living wage and poverty threshold in the future? If inflation continues to hold at about 1.6%, the increased minimum wage will get significantly closer to, but not greater than, the living wage in 2025.\n\nIs this enough? Arguably, no, as the proposed increase is less than the estimated living wage. But it is certainly a step in the right direction, and if passed, would likely keep the minimum wage above the poverty threshold for quite some (the poverty threshold rises roughly at a rate of $1 per hour every 10 years).\n\n\nMy Posterior\nIn general, my prior was confirmed by the analysis - my belief that the minimum wage should be increased has strengthened, and there’s a believable argument that the $15 per hour increase could be raised even higher. There are some additional points that I didn’t discuss above, however, that are still worth noting:\n\nThere are many different groups that have estimated living wages, and results can vary (I used MIT Lab’s data because it was the most readily available & also provided state, county, and metropolitan level data). In general, however, living wage estimates agree that the poverty threshold is far too low, and typically show living wages in excess of $15 per hour.\nThe percentage of hourly workers earning the federal minimum wage (or less) has decreased over the years and currently rests at about 1.9%. This is in part due to many states having minimum wages greater than the federal minimum. If the minimum wage increases to $15 per hour, the total number of workers earning the federal minimum wage will likely increase (the linked chart shows spikes that correspond to minimum wage increases in the ’90s and 2009).\nSome critics of the increased minimum wage argue that the minimum wage is only meant for teenagers working summer jobs. The data doesn’t support this argument - over 80% of federal minimum wage workers are 20+ years old.\nIn 2019, the Congressional Budget Office released a report that estimated that job losses due to an increased minimum wage could range between 4.7 million and 0, with a median of 1.3 million lost jobs. The report also notes, however, that about 17 million workers would benefit from the wage increase.\n\n\nThe linked NYT opinion article does give itself the caveat that the $22 per hour figure is based on “inflation and productivity,” though others have repeated this $20+ per hour wage argument without this caveat. The opinion article doesn’t mention any sources or databases, though I expect that the author is using GDP as a proxy for inflation - several articles point out that if the minimum wage had kept pace with GDP growth since 1968, it’d be significantly greater than even the proposed $15 per hour minimum wage. Correlating this to inflation, however, is at best a significant oversight by the author/editor, and at worst intentionally deceptive.\n\n\n\nSome Other Notes\nAs always, source data for this post can be found on github. I made an overt attempt to keep the code a bit cleaner this time around (having a “test area” in the code helped out). It’s still not perfect, and I suspect I’ll just naturally get better at writing neatly formatted scripts as the language becomes more intuitive.\nI think I’m going to take a break for a couple weeks from some of these longer posts - I’m currently finishing this a bit after midnight (which is very late for me!) - and between writing this & the Bayes’ Theorem post, I’ve had little time to dedicate to stats. Next week, I’ll put together a less intensive piece to give myself time to push forward with the stats class. Maybe after that I can write a quick post about the accuracy of prediction models, then get into another deep dive. We’ll see how I feel about it in the next couple weeks.\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {The {Min-Wage} {Debate}},\n  date = {2021-01-31},\n  url = {https://www.thedatadiary.net/posts/2021-01-31-the-min-wage-debate},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “The Min-Wage Debate.” January 31, 2021.\nhttps://www.thedatadiary.net/posts/2021-01-31-the-min-wage-debate."
  },
  {
    "objectID": "posts/2021-02-08-some-worthwhile-links/index.html",
    "href": "posts/2021-02-08-some-worthwhile-links/index.html",
    "title": "Some Worthwhile Links",
    "section": "",
    "text": "Rather than diving deep into a topic this week, I took a bit of a break to focus on playing catchup with the stats course I’m taking. Instead, I’ve listed out below a number of creators that I follow on various platforms. If you’re interested in data or critical thinking, each is well worth your time and attention.\n\nNewsletters\n\nFiveThirtyEight : While it’s not technically a newsletter, the FiveThirtyEight site, created by statistician Nate Silver prior to the 2008 presidential election, is the original source for data-driven news (or, at least, one of the first sites to popularize data as a news resource). Nate created the site specifically because the narrative created by pundits, that the 2008 election was super close, was pretty easily refutable when you looked at the polling data, which showed that Obama was going to win handily. Now, FiveThirtyEight is a powerhouse of data analysis for politics, sports, and science, and often serves as a good reality check against the narratives espoused by talking heads on the major news networks.\n\nG. Elliott Morris’ Newsletter : G. Elliott Morris is a data journalist for the Economist and created their forecast for the 2020 presidential election. In addition to regularly writing for the Economist, Elliott also writes a weekly newsletter in which he comments on polls that caught his eye (he also has a subscriber newsletter, for those who want to get his thoughts on even more topics). Elliott is also writing a book on the history of public polls, their limitations, and their future in American politics, which I am looking forward to reading when it releases later this year. As an aside, Elliott and I are the same age, and he was a large part of the inspiration for me to start diving into statistics again (i.e., if he can do it, so can I). Elliot is pretty bearish on the future of American democracy, especially following Donald Trump’s repeated attempts to overturn the overwhelmingly clear and overwhelmingly fair results of the election and the attempted (but, thankfully, woefully unorganized) coup by insurrectionists on Jan. 6th. Despite all this, I’m a bit more hopeful for the future of democracy, and hope to be able to provide a more positive opinion alongside Elliott’s (provided it’s supported by the data!).\nInfinite Monkeys : Started by a collection of college students who met via #ElectionTwitter, the Infinite Monkeys newsletter (named such from the theory that, an infinite collection of monkeys hitting keys on typewriters will eventually write the entirety of Shakespeare’s work by random chance) take a look at geographical trends and their relation to current political headlines. It’s a relatively recent startup, and I’m looking forward to the development of the newsletter & its coalition of authors over the coming years.\nVisual in the Noise : The Visual in the Noise is a weekly newsletter focused on data visualization. Most often looking at sports (particularly, NBA) data, the Visual in the Noise is a great touch-point for the importance of visualization and how it can help make data more insightful.\n\n\n\nPodcasts\n\nThe Daily : The Daily is, appropriately, a daily (Mon. - Fri.) podcast hosted by the New York Times, covering important topics in the American landscape. The podcast generally focuses in on individuals, and how national stories can affect people personally (for example, touching base with a bar throughout the pandemic as they wade through the difficulties of diminished business, PPP applications, and unclear direction from the government). On Sundays, a guest reads an older, long form New York Times piece.\nThe Intelligence : The Intelligence, similarly to the Daily, is a daily weekday podcast covering important topics in the news, though typically has a more global focus than the Daily. Rather than following individuals, the Intelligence often brings in subject matter experts and local correspondents.\nChecks and Balance : This weekly podcast by the Economist takes a deep dive into one big topic shaping American politics each week. Approximately 45 minutes per podcast, the Checks and Balance hosts take care to thoroughly explore each topic.\nFiveThirtyEight’s Politics Podcast : Every week, the FiveThirtyEight team covers the latest news in politics, utilizing polling data to guide their discussion. During election years, they also host intermittent “Model Talks,” where Nate Silver talks about into some of the intricacies of the site’s forecast models based on questions from listeners.\n\nThe Rational Reminder : A non-politics podcast, the Rational Reminder is a weekly podcast discussing index investing and rational decision making. Although the podcast is made by and for Canadians, most of the content is widely applicable, and the podcast has garnered an international audience.\n\n\n\nYouTube\n\n3blue1brown : Many concepts in math can feel daunting and teaching methods are often unintuitive. Grant Sanderson’s channel attempts to introduce viewers to the beauty of math through intuitive visualizations and animations. As a fun fact, the animations are run via a python package, manim, developed on-the-fly by Grant himself!\nPhilip DeFranco : One of the original members of the YouTube community, Phil has grown from a weekly commentary on popular videos via a webcam in his bedroom to a daily rundown of the news backed by a full production staff. Phil does an excellent job of presenting the news whilst making it clear where the official reporting stops and his opinion starts.\nLegal Eagle : Dubbed “YouTube’s Lawyer,” Devin (DJ) Stone provides a perspective on the role the law plays in current events and controversies (as well as more fun videos, like reviewing a Spongebob episode for legal accuracy). I’m not sure how he manages to balance the two full time jobs of running channel with near-daily longform content and being a lawyer with active litigation, but I appreciate that he is able to find time for thoughtful (and often comedic) insight.\n\nCommon Sense Investing : Ben Felix’s Common Sense Investing investigates the academic research supporting passive, rather than active, portfolio management (in summary: the data shows that passive index investing is overwhelmingly a more effective long term investment strategy than trusting an active portfolio manager with your money).\nStandup Maths : Mathematician, comedian, and Excel-enthusiast Matt Parker shares the joy that can be found in math by exploring topics in a comedic setting. Matt’s book, Humble Pi, explores some of history’s most famous mathematical blunders, and is coming up soon on my reading list.\nNumberphile : The Numberphile channel is a collection of interviews of prominent mathematicians explaining interesting historical math problems on trademark brown parchment paper. Grant Sanderson and Matt Parker make appearances on the channel a number of times (the infamous Parker square first made its appearance on Numberphile).\nMinutePhysics : As Henry Reich, the channel owner, puts it, the channel is simply about “cool physics and other sweet science.” Henry’s videos explain concepts in physics via a whiteboard, expo markers, and a backdrop of jazzy standup bass.\n\n\n\nElection Twitter\n\nThere are quite a few, so I’ll just highlight a few & link ot the rest\n\n\nLakshya Jain : Lakshya is a software engineer and self-described amateur elections mapper/analyst. He’s a very vocal (and self-labeled) partisan democrat, so I take his non-analytical posts with a grain of salt, but his analytical posts are very insightful.\nJack Kersting : A relative rarity on Election Twitter, Jack is a conservative forecaster. He’s not an ardent twitter user, but developed one of the most complete and thorough election forecasts I’ve seen outside of professional work.\nMax : A self described mapmaker, shitposter, and ardent supporter of Long Nebraska, Max is known for his oddball posts and lukewarm political takes.\nSome other folks I follow for election maps/data: Nate Silver, G. Elliott Morris, U Mich Voter, and Sam\n\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {Some {Worthwhile} {Links}},\n  date = {2021-02-08},\n  url = {https://www.thedatadiary.net/posts/2021-02-08-some-worthwhile-links},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “Some Worthwhile Links.” February 8,\n2021. https://www.thedatadiary.net/posts/2021-02-08-some-worthwhile-links."
  },
  {
    "objectID": "posts/2021-02-14-scorecasting/index.html",
    "href": "posts/2021-02-14-scorecasting/index.html",
    "title": "Scorecasting",
    "section": "",
    "text": "A baseball forecast that correctly predicts the winner of the 15 opening day games could be a truly accurate model, or could just be getting lucky. Over the course of 6 months and 2,430 regular season games, however, a great forecast will continue to shine whereas an initially lucky one will falter. In data rich environments like sports, there are lots of events (games) over the course of a season to judge how well a model is performing.\nWhen there aren’t a lot of events to forecast, like presidential elections that occur once every four years (quadrennially?), it’s more difficult to tell how well a forecast performs (a handful of correct/incorrect predictions could just be good/bad luck!), but forecasters still have tools available to evaluate their model. This week, I took a look at a few different methods of comparing different models.\n\nScoring the Forecasters\nThe most common scoring method, the Brier score, is a measurement of a probabilistic forecast’s accuracy based on the confidence of the prediction. Each event has its own score, and the average of all predicted events is the model’s Brier score. Highly confident predictions are highly rewarded/punished for their accuracy/inaccuracy, whereas timid predictions don’t move the needle too much, regardless of the outcome. Scores can range from 0.00 to 1.00, with 0.00 being a perfect score (you can read more about Brier scores here, but the gist is that the lower the score, the better). In presidential forecasts, each state can be considered an event.\nOftentimes, presidential forecasters report Brier scores as weighted by each state’s number of electors. Correctly predicting Texas’ winner in this scoring system is far more important than correctly predicting Wyoming’s winner, given that Texas’ 38 electoral votes far overshadow Wyoming’s 3. I’m not quite convinced that this is the most meaningful way to evaluate models (California is pretty easy to predict and heavily weighted by its 55 electoral votes, but most of us were more concerned with Georgia’s outcome, despite being undervalued by this scoring method), but forecasters do use this scoring method.\nFinally, I came up with my own scoring method that makes a “bet” between $0 and $100 based on prediction confidence. 100% confidence would turn into a $100 bet, and 50% confidence (aka, a coin toss) would be a $0 bet. Each model’s average winnings (including losses) is reported as the score.\n\nI scored a few prominent presidential forecasts based on the above methodologies (you can read more about the JHK, Economist, FiveThirtyEight, and Bitecofer forecasts at the links here). While all the scoring methods are similar - rewarding confidence in correct predictions and penalizing meek or incorrect predictions - each model’s performance is all over the map (with perhaps the exception of Bitecofer, which scores in the lower half of all methods). But does that mean these methods are useless? No! If anything, it highlights the importance that each forecast method’s performance should be scored across a wide variety of scoring methodologies. While it might not make a huge difference at the margins, it may separate some models as clearly ahead or behind the curve.\nSo, how does each forecast model measure up? It depends on which yardstick you use!\nHere are some other things to consider with regards to each model:\n\nUnlike the Economist, FiveThirtyEight, and Bitecofer models, which simulate each state’s outcome thousands of times and reports the confidence as the percentage of simulations won, the JHK forecast reports the percentage of winning results that fall within the 80% confidence interval around the expected vote. Lower confidence intervals result in tighter bands, so this relatively low confidence interval means that the model is allowed to make quite a few 100% confident predictions (which, luckily for the model, all came true in this case).\nThe Bitecofer forecast is the only model that doesn’t utilize polls and instead uses an in-house developed negative-partisanship model.\nBased on conversations between Nate Silver of FiveThirtyEight and Elliott Morris of the Economist, it appears that FiveThirtyEight added a bit of uncertainty ad-hoc to account for COVID, whereas the Economist did not.\n\nAs always, source files and code can be found on github. Next week, I plan on making a relatively modest prediction of the election’s popular vote outcome based on polls from the final week.\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {Scorecasting},\n  date = {2021-02-14},\n  url = {https://www.thedatadiary.net/posts/2021-02-14-scorecasting},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “Scorecasting.” February 14, 2021. https://www.thedatadiary.net/posts/2021-02-14-scorecasting."
  },
  {
    "objectID": "posts/2021-02-21-kind-of-projecting-the-2020-election/index.html",
    "href": "posts/2021-02-21-kind-of-projecting-the-2020-election/index.html",
    "title": "(Kind of) Projecting the 2020 Election",
    "section": "",
    "text": "I’m about 4 months too late, but to practice forecasting, I made a modest projection for the 2020 national popular vote using polling data from the two weeks leading up to election day. In the weeks leading up to the election, aggregated polling was fairly stable, and the model projection was within 1.5% of the actual outcome (both the model and actual outcome are adjusted to exclude third parties and instead show the two-party vote share).\n\nThe projected outcome of Biden’s vote share, 53.6%, is only the most likely outcome in a distribution of possible outcomes predicted by the model. Of the possible outcomes, Biden wins the popular vote about 70% of the time, according to the November 2nd projection.\n\nLike the projected vote share, the probability of Biden winning the popular vote remained fairly constant in the two weeks leading up to the election.\n\nIf you were like me, obsessing over the prominent forecast models prior to election day, you may notice that this projection is substantially less confident in the outcome than the leading forecasters. FiveThirtyEight and the Economist, for example, both projected similar popular vote outcomes (within a percentage point of this forecast), but gave Biden at least a 97% of winning the popular vote! There are a couple reasons for this difference:\n\nThis model is one-dimensional : this is a pretty simple model built just to get practice with forecasting and some of the tools in R, so it only uses polls (and, at that, only a small subset of polls), whereas other forecast models used a wide variety of variables to inform the model (economic indicators, demographics, partisanship, etc.).\nThis model doesn’t weight polls : aside from the sample size of the poll, this model doesn’t apply any weights or corrections to the polling data. The polling method, date the poll was taken, and pollster house effect (i.e., how partisan the pollster tends to be relative to the average) can be used to inflate or deflate the weight of each poll in the model. This simple model ignores all of that and treats every poll as equal.\nThis model forces an uncertainty range : unlike other models, which are a set of linear regressions, this model is a relatively simple beta distribution of the vote, with the sum of parameters manually set to 50. This is a bit of technical mumbo-jumbo, but the gist is that a beta distribution allows you to control its “peaky-ness,” and I did this manually, whereas other forecasters had the model do it for them. Increasing the sum of parameters increases how peaky the distribution looks, and a sum of 50 was used based on Florian Muellerklein’s Georgia runoff model, which also used a sum of 50.\n\n\nSome Notes\nAs always, you can find source data and code on github. I’m pretty happy with how this turned out - I’ve been getting a bit more comfortable with R, and the tools used for this post were pretty intuitive to implement. I’m also happy with the color palette I selected (HTML Color Picker is a godsend). The only improvement is that I could/should have saved quite a bit of code by writing over one of the plot themes, rather than re-writing the theme for each plot. Something to remember going forward.\nNext week, I’ll dig into some of the county-level data from the election to see if there was any ticket splitting between the presidential election and the down-ballot races.\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {(Kind of) {Projecting} the 2020 {Election}},\n  date = {2021-02-21},\n  url = {https://www.thedatadiary.net/posts/2021-02-21-kind-of-projecting-the-2020-election},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “(Kind of) Projecting the 2020 Election.”\nFebruary 21, 2021. https://www.thedatadiary.net/posts/2021-02-21-kind-of-projecting-the-2020-election."
  },
  {
    "objectID": "posts/2021-02-28-doug-collins-saved-raphael-warnock-s-senate-bid/index.html",
    "href": "posts/2021-02-28-doug-collins-saved-raphael-warnock-s-senate-bid/index.html",
    "title": "Doug Collins Saved Raphael Warnock’s Senate Bid",
    "section": "",
    "text": "I’ll be honest - prior to writing this post, I had never heard of Doug Collins (R), the third major candidate in the race for Georgia’s special senate election after Raphael Warnock (D) and Kelly Loeffler (R). I wasn’t particularly tuned in to the Georgia senate elections prior to the runoff (by which time, the special election race had narrowed to just Warnock and Loeffler) and most of the coverage I had seen prior to Nov. 3rd pitted Warnock against Leoffler, without considering Collins. Even Google search trends show that people were more interested in Loeffler than Collins leading up to the election.\n\nDespite my ignorance, Collins was a major candidate in the special election, and ended up with a significant portion of the republican vote. It may be a bit obvious, but republicans splitting votes between Loeffler and Collins made Warnock a significantly more competitive candidate. However, the role of voter dropoff relative to the regular senate election is worth exploring in detail.\n\n\nComparing Results\nGeorgia’s regular senate election was a much more typical election than the special election - a tightly contested election between two candidates, Jon Ossoff (D) and David Perdue (R). The county result map comparing the voteshare of the two major candidates shows democratic strongholds in urban areas and a republican lean in rural areas. The county result map of the special election, if comparing Warnock to both Loeffler and Collins, is noticeably redder.\n\n\nIf we remove Collins, however, and just look at the county map comparing the top two candidates, the map shifts drastically in Warnock’s favor.\n\n\nAt face value, this explains how Warnock was able to advance to the runoff - split ticket votes aren’t usually good for the party with multiple major candidates. Voter dropoff between the regular and special election, however, shows just how much this pushed Warnock over the edge.\n\n\nVoter Retention: a Tale of Two Elections\nAbout 5 million Georgians voted in each of the senate elections in November. In the regular election, the major candidates, Ossoff and Perdue, accounted for about 98% of the votes, the rest going to Libertarian Shane Hazel or other write-in candidates. In the special election, on the other hand, a huge portion of Georgia voters didn’t vote for the major candidates - Warnock, Loeffler, and Collins only account for 79% of the votes! That’s about a 1 million voters who didn’t vote for their party’s major candidate (i.e., “dropped-off”).\nTo get a clear grasp of what voter retention means in this context, let’s consider a hypothetical county with 100 voters, of which 60 voted for Perdue and 40 voted for Ossoff in the regular election. Let’s also say these 100 voters split their special election votes in the following way: 35 votes for Loeffler, 15 votes for Collins, 30 votes for Warnock, and 20 write-in votes. In this scenario, Warnock retained 75% of regular election votes (30 / 40 = 75%), republicans, collectively, retained 83% ([35 + 15] / 60 = 83%), and Loeffler retained 58% (35 / 60 = 58%). In this hypothetical county, republicans collectively improved relative to the regular election, since they had a greater vote retention, but Loeffler on her own worsened, despite winning more votes than Warnock.\nIf we compare retentions for the entire state of Georgia, we can see that Loeffler and Collins were collectively better at retaining regular election votes than Warnock, retaining about 90% of Perdue votes compared to Warnock’s retention of about 68% of Ossoff votes. On her own, however, Loeffler was worse at retaining votes than Warnock, retaining a little over 50% of Perdue votes. This means that Warnock improved democratic performance relative to the regular election when compared against Loeffler directly.\n\nRepeating this comparison across every county in Georgia shows that Loeffler and Collins, collectively, improved republican performance relative to the regular senate election across every single county. When, however, Collins is omitted, and Warnock and Loeffler are compared directly, democratic performance improves across the majority of counties.\n\n\n\nIn Summary\nWhile it was obvious from the beginning that the split ticket hurt republicans in Georgia’s special senate election, it’s interesting to see just how much this split ticket helped Warnock. Collectively, republicans handily won the special election, but splitting votes between Loeffler and Collins meant that Warnock ended up winning a plurality of the votes.\nPolitical analysists are probably better than me at examining why multiple republicans ran as major contenders for the special senate election, but a quick take is that Kelly Loeffler wasn’t a particularly strong candidate. Although she was an incumbent, she wasn’t a senator any Georgian had ever voted for - she gained her senate seat through appointment. Loeffler came to office as a moderate, but quickly pivoted to a more Trumpy ideology, eventually defining herself as “more conservative than Atilla the Hun” in a campaign ad (I would normally just add a hyperlink, but this ad is just too weird not to link directly - I originally thought this was a bad parody).\n\nHer campaign was also plagued by a few scandals, like darkening Warnock’s skin in a campaign ad, taking photos with known KKK members, and potentially making stock trades based on COVID-19 information not-yet released to the public. It’s a bit of a conjecture, so take this with a grain of salt, but all of the above factors may have provided Collins an opportunity to run as a stronger & less divisive alternative to Loeffler.\n\n\nSome Final Notes\nChoropleth charts (maps) can be misleading in the wrong context - it’s easy to subconsciously associate area with population. It wasn’t particularly relevant to the post above, but in spirit of the animation “Land doesn’t vote, people do”, I added dot-plot maps where bubble size corresponds to total number of votes.\n\n\nAs always, source data and code can be found on github. I’m particularly happy with how this post turned out. I learned a lot of new things worth highlighting (some of this gets into technical mumbo jumbo):\n\nLearned how to use the maps, gganimate, and gifski packages;\nPicked up new method of piping objects into a ggplot object;\nWorked with geom_col and geom_poly for the first time;\nUsed forcats for the first time (just to reorder a factor, but I’ll still count it as a win);\nAdded new colors to the dd color palette;\nCreated a reusable theme var to reduce code;\nStarted using tibbles.\n\nFor this post, I had originally wanted to compare presidential vote to senate, governor, and house vote, but I had to pivot a bit to just the Georgia senate elections, for a few reasons. Firstly, the senate county dataset from Kaggle, for whatever reason, doesn’t include the winner of each county. Adding this by hand, just for Georgia’s 159 counties and two senate elections took hours. There’s probably a more efficient way to do this by scraping the data from online, but then I’d have to have learned a scraping package in addition to all of the other packages. I may have to hold on the original post idea for a bit while I pick up these skills.\nThat being said, I’ve already started working on next week’s post. It’s a bit of a departure from what I’ve been doing, so I’m excited to see how it’ll turn out.\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {Doug {Collins} {Saved} {Raphael} {Warnock’s} {Senate} {Bid}},\n  date = {2021-02-28},\n  url = {https://www.thedatadiary.net/posts/2021-02-28-doug-collins-saved-raphael-warnock-s-senate-bid},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “Doug Collins Saved Raphael Warnock’s Senate\nBid.” February 28, 2021. https://www.thedatadiary.net/posts/2021-02-28-doug-collins-saved-raphael-warnock-s-senate-bid."
  },
  {
    "objectID": "posts/2021-03-07-artwork/index.html",
    "href": "posts/2021-03-07-artwork/index.html",
    "title": "aRtwork!",
    "section": "",
    "text": "This week, I did something a bit different - the artwork above was made in R! The code to create the graph is actually pretty short, only taking up 28 lines. The bulk of the work was spent writing the csv containing all the polygon points and colors. I spent most of the past week doing some back end work that will pay off in the future. Namely, I set up a local clone of my repository on github and figured out how to embed Shiny applications on Squarespace.\nI’d like to address something that has been nagging me for a bit. Last week, I wrote about Georgia’s special senate race. I spent a lot of time learning new packages and methods, and am happy with how the plots and majority of the post turned out. Near the end of the post, however, I made the conjecture that Doug Collins may have seen an opportunity to run against Kelly Loeffler because she was a polarizing candidate with a string of controversies surrounding her campaign. While I shared sources that generally support this position, I didn’t back it up with any sort of data or in-depth analysis. I’m not a political scientist nor am I an expert in election strategy, so in hindsight I think it was pretty irresponsible to add my uninformed opinion to the post. I’ll leave the post up unedited, since it’s important to keep a true record of what I’ve written, but moving forward, I’ll be better about writing the story the data reveals, rather than one I’d like to believe.\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {aRtwork!},\n  date = {2021-03-07},\n  url = {https://www.thedatadiary.net/posts/2021-03-07-artwork},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “aRtwork!” March 7, 2021. https://www.thedatadiary.net/posts/2021-03-07-artwork."
  },
  {
    "objectID": "posts/2021-03-15-recent-works/index.html",
    "href": "posts/2021-03-15-recent-works/index.html",
    "title": "Recent Works",
    "section": "",
    "text": "One of the history teachers at my highschool was known for his prolific catchphrase, “give me the stuff, not the fluff,” often uttered to students attempting to submit history papers padded with superfluous words and sentences in order to meet a minimum word threshold. While I never took a class with this teacher, the phrase has stuck with me. With that in mind, I’ve reprioritized some of the things I’ve been working on. Here’s what I’ve been up to over the past week:\n\nTX COVID Tracker: Over the weekend, I put together and published my first Shiny application, a county-level interactive Texas COVID tracker. Using data from the New York Times, the tracker lets the user view county-level historical data. The goal is to fill in the gaps of the Times’ Texas tracker, which shows historical state data and live county data, but doesn’t offer historical county data.\n\nClasses: I had previously spent evenings working on projects in R and had pushed off some of the statistics classes to focus on these projects. This past week, I’ve scheduled an hour each day for dedicated class time, alternating daily between a Bayesian inference course and a machine learning course.\n\n\nMy plans for the upcoming week:\n\nTX COVID Tracker: While the interactive tracker is functional, it still leaves a lot to be desired. Being the first Shiny app I developed, I ran into a lot of learning curve issues but should be able to make updates more quickly. This upcoming week, I plan on converting to a bootstrap layout, adding in an interactive state map with leaflet, adding in statewide hospitalization and vaccination information, adding a state and county level log-log plot, making some formatting changes to help with mobile viewing, and updating themes/appearances. Eventually, I’d like to write a scheduleR script to automatically update the data, but that may need to be put off to focus on the laundry list above.\nClasses: I’ll still continue with the daily schedule for coursework and may be able to finish the Bayesian inference course this week.\n\nBetween the COVID tracker and classes, I don’t think I’ll have too much time to work on anything else. That being said, I’ve got some projects/articles in the backlog that I’m looking forward to working on:\n\nPolarization - top down or bottom up? It’s no secret that we are living in the most polarized political landscape since the Civil War, but I’m interested in exploring where this polarization originates. Do elected politicians split the public by pushing increasingly divisive policies? Or do voters lead the polarization effort by increasingly self-segregating into isolated camps?\nTwo Party PVI (Partisan Voter Index): The partisan voter index (PVI) is a measure of a state’s (or county’s) partisan preference relative to the national environment. There’s a story here about how the national environment is progressing - are our country voting preferences converging or diverging? What states are trending towards Democrats? What states are trending towards Republicans?\nThe Gas Price Fallacy: I’ve seen quite a few bad faith attempts to blame increasing gas prices on Joe Biden recently. Additionally, it’s particularly frustrating that I’ve seen a number of my colleagues in the oil & gas industry repeat this nonsense. As a working member of the oil & gas industry, I think I’m qualified and have a duty to explain why the administration change isn’t the cause of the rising gas prices (the TL;DR version is that we’re recovering from a global pandemic & oil oversupply, you can see that gas prices are just returning to pre-COVID Trump administration levelshere.)\n\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {Recent {Works}},\n  date = {2021-03-15},\n  url = {https://www.thedatadiary.net/posts/2021-03-15-recent-works},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “Recent Works.” March 15, 2021. https://www.thedatadiary.net/posts/2021-03-15-recent-works."
  },
  {
    "objectID": "posts/2021-04-05-seasonality-is-a-weak-predictor-of-border-crossings/index.html",
    "href": "posts/2021-04-05-seasonality-is-a-weak-predictor-of-border-crossings/index.html",
    "title": "Seasonality is a Weak Predictor of Border Crossings",
    "section": "",
    "text": "Last week, the Washington Post published an article postulating that the recent increase in crossings at the border cannot be attributed to Biden administration policies, but rather is a function of seasonal patterns and pent up demand due to restricted travel in 2020. While the article is well intentioned, a simple linear model that predicts crossings based on month shows seasonality is a poor predictor (or, at least is a poor predictor on its own).\n\nExamining the Data\nThe US Border Patrol (USBP) publishes monthly data summarizing the number of encounters/crossings at the Southern border. Since November of 2020, border crossings have increased monthly, from about 70,000 in November to a little over 100,000 in February.\n\nLooking at the long term monthly data, however, reveals two key aspects:\n\n2019 was an exceptionally high year for crossings, and 2021 is on track to have a similar number of crossings;\nThere seems to be a cyclical set of peaks and troughs in annual border crossing numbers.\n\n\nLooking at the chart above, it’s difficult to determine which months correspond to peaks and troughs. Aligning by month offers a clearer picture of how monthly border crossings in each year compare to other years.\n\nFrom this chart, it does appear that there is some semblance of a monthly pattern, albeit with extreme outliers of 2019, 2020, and 2021. Appearances, however, can be deceiving, and a mathematical model can help distinguish signal from noise. Using month as a predictive input, we can create a model that estimates the expected number of crossings in said month. If we look at the residual error (the actual number of crossings minus the predicted number of crossings) over time, we can get an idea of how well the model is performing. If seasonality is a good predictor of the number of border crossings, the model will accurately account for seasonal shifts, and the residual error plot would be expected to remove or reduce the “waviness” that appears in the crossing plot and only show the long term trends.\n\nPlotting the residual error, however, doesn’t filter out seasonal noise. In fact, apart from the y-axis shifting down, the residual plot is strikingly similar to the crossings plot. This means that the month offers little power on its own in predicting the number of border crossings.\n\n\nClosing Remarks\nThe Washington Post article makes good points that aren’t discussed fully here, but are worth mentioning:\n\nThose who planned on crossing the border in 2020 but couldn’t due to travel restrictions may have simply waited until now to travel.\nUnaccompanied migrants are arriving at the border in rates that exclude the possibility of seasonal patterns.\n\nAlso notable is that seasonal patterns - while not a good predictor of the number of border crossings on its own - may be more impactful in a more robust model. As a professor from the University of San Diego explains, conditions in the migrant’s country of origin and the countries they pass through are among a host of variables that play a significant role in determining if migrants make the trip to the US border. While a more robust model may be able to accurately incorporate season into its predictions, simply using month as a predictor, as the Washington Post does in their article, does not explain the surge at the border (evidenced by the fact that this equally simple model refutes their finding).\nFinally, it should be noted that, above all else, there is a humanitarian crisis at the border. If you’d like to find a way to help or donate, Global Giving is an excellent resource.\n\n\nSome Other Updates\nHere’s what I’ve been working on recently:\n\nTidyTuesday: I’ve made my first contribution to #tidytuesday! For those who are unaware, TidyTuesday is a weekly data project in R for the R4DS (R for data science) community. Each week, a public dataset is released on Monday, allowing users to explore and create interesting visualizations and analyses based on the dataset. This week, a dataset based on global deforestation was released, but it came along with interesting information on the production of vegetable oil. I plotted the global annual vegetable oil production by crop type in the steamgraph below.\n\n\n\nCourses: I’ve continued with the machine learning and Bayesian courses, though I’ve descoped to roughly two days each week, as my personal schedule has gotten quite hectic. The ML course is excellent for understanding the theory that goes into each algorithm, but in practice, I expect that I will likely make use of the tidymodels R package’s relatively simple interface.\nRmd: I’ve started writing my code in a R markdown document, which allows me to mix both code and prose. I mix in some off-the-rails/stream of consciousness commentary as I step through the process to get to a functional code. For regularly updated/critical code/projects, I’ll still stick to concise scripts.\n\nThat’s all for this week - as always, you can read through the code for this piece or for the tidytuesday piece on github. See you next week.\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {Seasonality Is a {Weak} {Predictor} of {Border} {Crossings}},\n  date = {2021-04-05},\n  url = {https://www.thedatadiary.net/posts/2021-04-05-seasonality-is-a-weak-predictor-of-border-crossings},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “Seasonality Is a Weak Predictor of Border\nCrossings.” April 5, 2021. https://www.thedatadiary.net/posts/2021-04-05-seasonality-is-a-weak-predictor-of-border-crossings."
  },
  {
    "objectID": "posts/2021-04-20-catching-up/index.html",
    "href": "posts/2021-04-20-catching-up/index.html",
    "title": "Catching Up",
    "section": "",
    "text": "The past few weeks have been a bit lite (read::absent) in terms of posting updates. When not taking the machine learning course, I’ve been spending quite a bit of time working on building out a database of demographic data (from 1980 to 2019). The goal is to be able to build this database out once, then reference it repeatedly for future projects. If you’re so inclined, you can read my unedited ad-hoc thoughts while working on the database here. There’s lots of code interspersed with prose, so it’s a bit of a slog to read through, but gives a really detailed account of how I worked through the different problems that arose.\nThat being said, I did have a bit of time to squeeze in a quick chart. YouGov recently conducted a poll on each state’s favorability rating according to Democrats and Republicans. Not surprisingly, state favorability is closely aligned with Biden’s voteshare in November.\n\nI’ll keep this short and sweet. I may continue to write sparsely over the next month or so, due to a few trips (now that I have the COVID vaccine), but will continue to work on the database in the background.\nAs always, you can find my work on Github.\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {Catching {Up}},\n  date = {2021-04-20},\n  url = {https://www.thedatadiary.net/posts/2021-04-20-catching-up},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “Catching Up.” April 20, 2021. https://www.thedatadiary.net/posts/2021-04-20-catching-up."
  },
  {
    "objectID": "posts/2021-04-27-a-lukewarm-case-for-dc-statehood/index.html",
    "href": "posts/2021-04-27-a-lukewarm-case-for-dc-statehood/index.html",
    "title": "A Lukewarm Case for DC Statehood",
    "section": "",
    "text": "Once again, I’ll be keeping this very short, as I’ve continued to primarily focus on building out the demographic/economic database. I, did, however, sneak in some time to explore the 2020 Census Apportionment Results that were released yesterday. Some surprises came out of the release: Texas and Florida underperformed expectations, only gaining two and one seat, respectively; Arizona didn’t gain a seat; and New York lost a seat but was apparently 89 people short of retaining its seats. Given that Texas and Florida each gained one less seat than was generally expected, there’s been some speculation online that Donald Trump’s attempt to undercount Hispanics was successful, but backfired. I’ll hold my judgments on this theory until I can read some more in-depth opinions (if they get written).\nWith the new apportionment and population data, each individual’s representative power in congress has shifted. Including both Senators and House Representatives, states with smaller populations continue to have outsized representation in congress: Wyoming and Vermont have significantly more representatives per million residents than California or Texas, for example. Residents of Washington D.C., however, receive no representation in congress.\n\n\n\nAs a side note, the reps-per-million will be greater than the total number of congressional representatives in states with less than one million residents. This chart is really meant to compare the uneven representative power of each state.\nIf D.C. were to become a state, it would have outsized representative power, similar to Wyoming and Vermont, due to its size. That, however, isn’t really a justification to deny ~700,000 Americans national representation, and the arguments against D.C. statehood have been weak at best and implicitly racist at worst, given D.C.’s majority-minority population.\nStill, it’s virtually impossible that D.C. statehood receive the filibuster-proof 60 votes in the Senate (I’d doubt that even a compromise of retrocession into Maryland would pass). For the time being, residents of D.C. will have to wait for representation until polarized ideological walls come down and Republicans vote for D.C. statehood, Democrats gain enough seats for a supermajority, or the filibuster is abolished.\nAs always, you can find my work on Github.\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {A {Lukewarm} {Case} for {DC} {Statehood}},\n  date = {2021-04-27},\n  url = {https://www.thedatadiary.net/posts/2021-04-27-a-lukewarm-case-for-dc-statehood},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “A Lukewarm Case for DC Statehood.” April\n27, 2021. https://www.thedatadiary.net/posts/2021-04-27-a-lukewarm-case-for-dc-statehood."
  },
  {
    "objectID": "posts/2021-05-05-president-of-the-polls/index.html",
    "href": "posts/2021-05-05-president-of-the-polls/index.html",
    "title": "President of the Polls",
    "section": "",
    "text": "Elliot Morris wrote in his newsletter last week about the increase in the public’s opinion that the government ought to be doing more. A summary of the last twenty years of polling by NBC shows that, while there seems to be a reactive effect based on the party of the president, support for increased government activity has generally been on the rise.\n\nThe combination of Biden’s approval across several categories, public support of his proposals (with the exception of his original cap on refugees, which he then raised after public outcry), and the public support of increased government activity gives Biden a strong argument in pressing congress to get his progressive policies pushed through to his desk. Despite the popularity, his $4 trillion infrastructure and families plan largely depends on what the senate parliamentarian will allow into a reconciliation bill (which only needs majority approval, rather than a filibuster-proof 60 votes) and the votes of a few moderate Democratic senators, since the bills will receive no Republican support in the senate.\n\nOutlook for the Coming Weeks\nI’ll be taking a break for the next few weeks, due to a flurry of weekend trips/weddings now that I/most of my friends are fully vaccinated. I’ll continue to work on the database in the background (notably, I need to dive deep into the census bureau demographic data, which needs a lot of fixing). I’ll likely write a short update in either late May or early June.\nAs always, you can find my work on Github.\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {President of the {Polls}},\n  date = {2021-05-05},\n  url = {https://www.thedatadiary.net/posts/2021-05-05-president-of-the-polls},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “President of the Polls.” May 5, 2021. https://www.thedatadiary.net/posts/2021-05-05-president-of-the-polls."
  },
  {
    "objectID": "posts/2021-06-03-covid-cases-improve-with-introduction-of-vaccines/index.html",
    "href": "posts/2021-06-03-covid-cases-improve-with-introduction-of-vaccines/index.html",
    "title": "COVID Cases Improve with Introduction of Vaccines",
    "section": "",
    "text": "As vaccines have become widely available in the US, new COVID cases and deaths have dropped significantly from winter peak, with the 7-day average for both cases and deaths nearing the averages reported during the initial lockdown in the summer of last year (note that, in the chart for the 7-day average of deaths below, the scale is restricted to 15 deaths per million; this cuts off some of the state surges, but shows the US average better than a chart with an unedited scale).\n\n\nAccording to the US Vaccine Tracker, 41% of Americans are fully vaccinated as of today. Even more heartening is the fact that the partisan divide regarding vaccine hesitancy, while still existent, is shrinking.\nWhile this is certainly good news about the country as a whole, individual states, counties, and cities may have varying levels of success in curbing the spread of the virus in the local community. The New York Times created a helpful dashboard that lets you look at the spread of the virus on a state, county, or metro area scale.\nAll this is to say that, while the pandemic is still not (and possibly will never be) a thing of the past, the introduction of vaccines certainly has appeared to help curb the spread.\n\nCatching Up\nIt’s been a while since I’ve written, due to a flurry of weddings and trips. While I had originally hoped to get back onto a regular weekly writing schedule, I will again have to push out the next post until late June, due to some exciting personal news: June 21st, I’ll be starting a new job! I’ll be transitioning from engineering in the oil & gas industry to healthcare analytics, which I’m really excited about! In the meantime, however, there’s a flurry of work to do in my current job to ensure that the person backfilling me is prepared to pick up the projects I’m working on. Hopefully after that, I can get back to a regular schedule.\nAs always, you can find my work on github.\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {COVID {Cases} {Improve} with {Introduction} of {Vaccines}},\n  date = {2021-06-03},\n  url = {https://www.thedatadiary.net/posts/2021-06-03-covid-cases-improve-with-introduction-of-vaccines},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “COVID Cases Improve with Introduction of\nVaccines.” June 3, 2021. https://www.thedatadiary.net/posts/2021-06-03-covid-cases-improve-with-introduction-of-vaccines."
  },
  {
    "objectID": "posts/2021-07-11-blexas/index.html",
    "href": "posts/2021-07-11-blexas/index.html",
    "title": "Blexas?",
    "section": "",
    "text": "Last year, Donald Trump won Texas’ 38 electoral votes handily, earning 52% of the vote compared to Biden’s 46% (R+6). Taken on its own, this is hardly surprising - Texas has gone to the Republican presidential candidate in every election since 1980. Looking at the relative gains made in Texas over recent election cycles, however, paints a much more hopeful picture for Democrats hoping to flip the state & garner the nickname, “blexas.”\nOn election day, FiveThirtyEight and the Economist gave Biden a 38% and 30% chance of winning in Texas, respectively. While still bearish on Biden, this is far more bullish than 2016, when FiveThirtyEight’s model gave Clinton a mere 5% chance of winning in Texas (in fact, both FiveThirtyEight and the Economist were more confident in Biden’s chance of winning Texas in 2020 than FiveThirtyEight was that Trump would win the presidency in 2016 (28%)). Part of this shift can be attributed to Democratic gains nationally, but Texas Democrats have been steadily gaining more ground than can be explained by national swing.\n\nThe Cook Political Report publishes its Partisan Voter Index (PVI) following each presidential election. PVI is a measure of how a state, district, or county votes relative to the national environment. For example, say a Democratic candidate wins 53% of the two-party voteshare nationally, but 51% in a given state. Despite the state going to the Democratic candidate, the state PVI would be R+2%, since the candidate performed 2% under the national vote (the actual PVI calculated in the Cook report is slightly more involved, but this basic understanding is sufficient for our purposes). Looking at Texas’ PVI over past elections, we see that Democrats have been making relative gains in every election since 2004, despite Texas still voting more Republican than the nation.\nMuch of this can likely be attributed to demographic shifts drive by major Texas cities - Dallas, Houston, Austin, and San Antonio have seen massive population increases, largely due to domestic and international migration (as opposed to natural changes - e.g., births). As Texas grows, it also continues to diversify. The non-hispanic white population in Texas dropped from 45% in 2010 to 41% in 2019, and non-white population groups have driven growth over the past 10 years.\n\nAll that being said, while I expect that Texas will continue to experience demographic shifts that are favorable in the eyes of Democratic politicians, in the absence of any real modeling work, I’m hesitant to say that Texas will turn blue in the near term. Despite gains in the presidential results, Texas Democrats didn’t outperform expectations in the house, nor did they even advance a candidate in the special election for TX-06 (two Republican candidates advanced to a runoff). Governor Abbott is also introducing a special legislative session with one goal (of many) of making Texas a state with some of the most restrictive voting laws with targeted partisan effects. Looking to other states as a reference, North Carolina had also seen similar PVI shifts in the past without resulting in Democratic victories (though, to be fair, North Carolina hasn’t experienced the same level of demographic shift that Texas is undergoing).\nPerhaps there is some modeling work I can do to produce a more definitive stance, but until then, I’ll hold on making any bold predictions.\nAs always, you can find my work on github.\n\nGeneral Updates\nIt’s been quite a while, but it’s good to get back into writing again. I wrote the scripts/made the charts for this post about two weeks ago, but haven’t had the time (or rather, haven’t made the time) to write the post itself. While I feel like I’ve been saying this for three months now, I do hope to get back to a more regular schedule soon - perhaps biweekly, to avoid rushing projects. We’ll see - in any regard, here are some updates that I’m excited about:\n\nI started my new job a few weeks ago! It’s both very rewarding (I get to use R & work with large polling datasets daily!) and very demanding. I enjoy the challenge & am excited for upcoming projects that I’ve been tasked with.\nI’ve been steadily making headway against the Machine Learning course I’ve been taking - at this point, I’m about halfway finished.\nI’ve begun to poke around in the tidymodels framework. I’m interested in the standardization the packages supply for generating models in R.\n\n\nSome reading/viewing material:\n\nI linked to it above, but it’s worth reading through this NYT article on the special legislative session in Texas. I only touched on voting rights, but session is primed as another hot-button issue session following spring’s ultra-conservative agenda.\nChecks and Balance, the Economist’s weekly podcast, focused on Critical Race Theory & the troubled history of race in American education in their most recent podcast, “History Test.” It’s well worth a listen, especially if you’re like me, and had never heard of CRT until recently.\nJust over 6 months ago on January 6th, violent Trump supporters stormed the U.S. capitol. With time and overt lies being propagated by Fox News, OANN, and Newsmaxx, it’s easy to forget exactly what happened and how it felt on that day. This NYT Visual Investigation does an excellent job of reconstructing the timeline of the events that day.\n\n\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {Blexas?},\n  date = {2021-07-11},\n  url = {https://www.thedatadiary.net/posts/2021-07-11-blexas},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “Blexas?” July 11, 2021. https://www.thedatadiary.net/posts/2021-07-11-blexas."
  },
  {
    "objectID": "posts/2021-07-18-the-gas-price-fallacy/index.html",
    "href": "posts/2021-07-18-the-gas-price-fallacy/index.html",
    "title": "The Gas Price Fallacy",
    "section": "",
    "text": "As America has vaccinated its population, life has seemingly begun to return to the pre-pandemic normal. Businesses have been opening to higher levels of capacity, schools are planning for higher levels of in-person learning in the fall, and, notably, Americans have returned to pre-pandemic levels of transit.\nConservative commentators and representatives have pointed out that prices of commodity goods - in particular, gasoline - have skyrocketed over the past year and attribute this increase to Biden’s presidency. Looking at retail gasoline prices, we can see a steady increase since Biden took office.\n\nWhat they fail to point out, however, is that the price of gasoline (and other commodities) significantly dropped during the pandemic, and that the increases are largely a return to pre-pandemic prices.\n\nWhile there are certainly opportunities to critique the current administration’s energy policy (banning new drilling leases on federal land/water and canceling the Keystone XL pipeline’s border-crossing permit, for example), attributing the recent return to pre-pandemic gasoline prices is a particularly weak and intentionally misleading avenue of attack.\nAs always, you can find my work on github.\n\nSome Reading/Viewing Material\n\nThe Economist wrote an interesting article finding a significant link between a county’s in-person voting rate and new COVID cases in November.\nElliot Morris summarized the work of several political scientists in a recent article describing why the GOP slid so far towards authoritarianism in the past decade. The article is behind a subscriber paywall, but is well worth the read. In short, however, “ethnically antagonistic” voters are much more likely to agree with statements traditionally viewed as authoritarian. This group hadn’t coalesced under a single party until Trump brought these anti-racial voters into the party (recall his role in the birther conspiracy and the racial antagonism surrounding his 2016 campaign), at which point democratic (note, small “d”) norms became a partisan issue.\nIn my machine learning class, I’ve started learning about the implementation of neural networks. The course’s instruction style is highly technical, but Grant Sanderson’s series on neural networks has helped me align a technical and intuitive understanding of the topic.\n\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {The {Gas} {Price} {Fallacy}},\n  date = {2021-07-18},\n  url = {https://www.thedatadiary.net/posts/2021-07-18-the-gas-price-fallacy},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “The Gas Price Fallacy.” July 18, 2021.\nhttps://www.thedatadiary.net/posts/2021-07-18-the-gas-price-fallacy."
  },
  {
    "objectID": "posts/2021-08-08-tidymodels-and-the-titanic/index.html",
    "href": "posts/2021-08-08-tidymodels-and-the-titanic/index.html",
    "title": "Tidymodels and the Titanic",
    "section": "",
    "text": "This week, I thought I’d do something a bit different. I’ve been working with & getting used to tidymodels, a suite of R packages for building machine learning models with tidyverse principles (you can thank Julia Silge’s blog for providing a whole host of examples and walkthroughs). Using tidymodels and Kaggle’s Titanic dataset, I created a few simple models to predict whether or not each passenger survived.\n\nExploratory Data Analysis\nFirst off, it’s important to get to know the dataset in a bit of detail before diving into model building. The Titanic dataset is relatively small, containing 12 columns of data on 891 passengers.\n\nPassengerId : ordered number assigned to each passenger (1, 2, 3… etc.).\nSurvived : indicates whether the passenger survived or not (imported as numeric, where a 1 means that the passenger survived and a 0 means that the passenger died.\nPClass : passenger class (1st, 2nd, or 3rd).\nName : passenger’s name.\nSex : passenger’s sex.\nAge : passenger’s age.\nSibSp : number of the passenger’s siblings and/or spouses aboard the ship.\nParch : number of the passenger’s parents and/or children aboard the ship.\nTicket : passenger’s ticket number.\nFare : price of the passenger’s ticket.\nCabin : passenger’s cabin number.\nEmbarked : port from which the passenger embarked.\n\nThe passenger’s name and ticket number are unique, and don’t offer any much predictive power (at least, not for the type we’ll be deploying), so I’ve removed those columns from the selection. The majority of passengers are missing Cabin information, so I’ve similarly removed that column. Let’s take a look at the age distribution by gender. Density plots are good for this sort of objective, but a quick note - density plots don’t show the counts (like a histogram), just the relative distribution of each group.\n\nBoth men and women have similar age distributions, with the majority being adults roughly in their twenties. It’d be interesting to look at which age groups survived.\n\nThere’s a spike survivorship at a young age (as expected, due to the prioritization of children). Young adults make up the majority of both survivors and those who died, simply because young adults made up the majority of passengers. It may be more interesting to see which male/female age groups survived.\n\nInterestingly, there’s a large portion of the women who died were children. To gain some more insight, however, it may be beneficial to bin the results. As mentioned above, density plots don’t show a count of each age, but the relative amounts instead. We can use a histogram to get a better idea of the actual amount in each group.\n\nFrom the histogram, we can see that there were far more male passengers than female passengers. Let’s setup age brackets and see how many of each age group survived.\n\nDespite there being more male passengers, there were more female survivors in just about every age bracket. I had expected that women would have a greater percentage of survivorship, but was mildly surprised that the absolute number of female survivors was greater than the number of male survivors.\nLets look at how survivorship is related to the number of family members each passenger was traveling with.\n\nWhile there’s not huge variation between survivorship percentages across each class, we can see that the majority of passengers were traveling alone.\nFinally, I looked at the distribution of the fare price by survivorship. As expected, passengers who didn’t survive skewed towards low cost fares while survivors were more evenly distributed across fare prices.\n\n\n\nModel Fitting and Evaluation\nNow that we’ve explored the data a bit, we can get started on some actual model fitting and evaluation. I split the dataset into a training set and test set, and built two simple models - a logistic regression and a random forest model. In very light detail, a logistic regression is the most basic classification model based on the generalized linear model and a random forest model is a decision tree-based algorithm. With no tuning applied, neither model performed particularly well - the logistic regression and random forest models had accuracies of 85.5% and 83.8% on the test set, respectively. While the logistic regression had a slightly higher accuracy on the test set, the random forest performed better on the metric of area under the ROC (receiver-operator characteristic) curve - 0.899 compared to 0.888 (generally, binary classification systems with ROC AUC values close to 1 perform better). A comparison between the two ROC curves is shown below.\nIt’s not perfect, but the purpose was to explore the tidymodels framework, and I’m pretty happy with the outcome/practice along the way.\n\n\n\nSome Things to Read/Watch/Listen to\n\nThere’s been a concerted effort by prominent conservatives to promote vaccination and shift the blame for vaccine hesitancy to the Biden administration, pointing in particular to one of Kamala Harris’ comments during the Vice Presidential debate. This criticism falls fairly short, given that commentators like Tucker Carlson and legislators like Marjorie Taylor Green continue to spread vaccine conspiracy theories. Further, a statistical model by the Economist found that the strongest predictor of whether or not someone has been vaccinated is who they voted for in the 2020 presidential election.\nJulia Silge was recently featured as a guest on an excellent episode of the Not So Standard Podcast. Well worth a listen for R dorks like myself.\nPerry Bacon Jr wrote an informative piece on the misplaced importance on swing voters in election cycles.\n\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {Tidymodels and the {Titanic}},\n  date = {2021-08-08},\n  url = {https://www.thedatadiary.net/posts/2021-08-08-tidymodels-and-the-titanic},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “Tidymodels and the Titanic.” August 8,\n2021. https://www.thedatadiary.net/posts/2021-08-08-tidymodels-and-the-titanic."
  },
  {
    "objectID": "posts/2021-09-23-catching-up-again/index.html",
    "href": "posts/2021-09-23-catching-up-again/index.html",
    "title": "Catching Up (again)",
    "section": "",
    "text": "Wow, it’s been quite a while! Once again, I’m catching up from a long hiatus (this time, there was about a month’s gap between posts). Although I haven’t been writing here, I have been keeping myself incredibly busy - for that reason, I think I’m going to switch up the format of this site. Here’s a few changes I’m planning on making, & also why I plan on making them.\n\nOpening up topic options\nUp until now, I’ve pretty much exclusively been looking at politically-related things from a data-centric point of view, partially because most news outlets are sensationalist and it annoys me, and partially because the 2020 election & aftermath was on my mind for most of early 2021 (also, wanting to understand the Economist’s Election Forecast methodology was the spark that led to taking stats classes, learning R, and [eventually] landing a new job). While I still want to/expect that I will touch on political-esque topics, I want to expand into things I’m more generally interested in. I’ve spent a lot of time this year working on projects that don’t touch politics and it was difficult to spur the enthusiasm to work on a political project just to fill the site after having spent hours coding something unrelated. I’ve imposed this political filter on myself, & expanding the horizon to include any/all topics that interest me will allow me to more consistently write without overextending myself.\n\n\nMoving away from Squarespace\nCurrently, this site is hosted by Squarespace. This was great for getting setup & used to working online, but after a year of working with it, I’ve realized that it isn’t the ideal platform for my use case. Early next year, hopefully, I’ll switch over to using rmarkdown, Hugo, and Netifly to build & deploy a site directly from R. This will make my life a lot easier, for a couple of reasons:\n\nI will have a lot more control over layouts and themes\nI’ll be able to more easily share code, images, and interactives(!)\nThe code & the website will be housed under one directory (rather than existing as two separate entities)\n\nAdditionally, the platform I’m planning on moving to is more blog/personal-professional focused, rather than retail focused, like Squarespace. I may also be able to move towards having posts appear in emails, rather than having to link to the post itself.\n\n\nTimeline\nI haven’t yet settled on this yet, but I may move from a weekly schedule to a bi-weekly schedule (not that I ever really stuck to the weekly schedule). The projects I’ve been working on typically take quite a bit of time, so trying to churn one out each week means that I may have to suffer quality for a schedule, which I don’t want to do. I’d rather have enough time to fully devote to completing something.\nAnyways, that’s a lot of updates - I’ll hopefully check in within a few weeks time!\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {Catching {Up} (Again)},\n  date = {2021-09-23},\n  url = {https://www.thedatadiary.net/posts/2021-09-23-catching-up-again},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “Catching Up (Again).” September 23,\n2021. https://www.thedatadiary.net/posts/2021-09-23-catching-up-again."
  },
  {
    "objectID": "posts/2021-10-05-rstudio-s-call-for-documentation/index.html",
    "href": "posts/2021-10-05-rstudio-s-call-for-documentation/index.html",
    "title": "RStudio’s Call for Documentation",
    "section": "",
    "text": "In my job, I spend a good amount of time working in the platform setup by our survey vendor, Qualtrics. There are some pre-formatted reports that we can send on a recurring basis through Qualtrics, but for one-off or custom reports, I can work with the raw data in R. A few weeks ago, however, I was asked to setup a recurring email to send a customized report to a group of hospital directors each week. While R makes generating the report simple, sending out each week was tedious, as each one needed to be sent separately. Since the reports contain patient information, I couldn’t automate via a third party server like GitHub Actions. I needed a way to localize the automation to my computer.\nLuckily enough, I was able to work out a solution! I wrote about it in a submission to RStudio’s 2021 Call for Documentation. You can read my article on Automated Email Reports with R, VBA, and the Task Scheduler for more detail.\n\nSome programming notes\n\nI’ve been named one of RStudio Community’s New Users of the Month!\nI’ve started working in Rmarkdown for these posts (you can actually view the native file for this post here). This allows me to mix in code and prose in one document & should make the process a bit easier on my end.\nI’ve scheduled out posts every two weeks for the rest of the year. I wanted to give myself enough time to work on some longer term projects, so be on the lookout for more in store!\n\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {RStudio’s {Call} for {Documentation}},\n  date = {2021-10-05},\n  url = {https://www.thedatadiary.net/posts/2021-10-05-rstudio-s-call-for-documentation},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “RStudio’s Call for Documentation.”\nOctober 5, 2021. https://www.thedatadiary.net/posts/2021-10-05-rstudio-s-call-for-documentation."
  },
  {
    "objectID": "posts/2021-10-19-polling-average-of-the-va-governor-s-race-using-purrr-map-functions/index.html",
    "href": "posts/2021-10-19-polling-average-of-the-va-governor-s-race-using-purrr-map-functions/index.html",
    "title": "Polling Average of the VA Governor’s Race using purrr::map functions",
    "section": "",
    "text": "Rolling poll averages can be misleading in the absence of errorbars or an expected distribution of outcomes. FiveThirtyEight is currently tracking polls of Virginia’s Governor race slated for early November, and has kindly made their polls available to the public. Their current polling average, however, looks to be a simple rolling average and doesn’t include a confidence interval. I’ve attempted to improve upon their tracker here by providing a weighted polling average and a 95% confidence interval.\n\n\nHow this works\nSince we’re only considering the top candidates from each party, we’ll look at each candidate’s two-party voteshare of each poll. To get the two-party voteshare, third party or other minor candidates are removed from each poll and each candidate’s percentage is recalculated as if they were the only two options on the ballot (in practice, this only removes a tiny amount of undecideds and third party voters). Then, the daily polling average is calculated by weighting each poll by sample size and recency. Using Bayes’ theorem and a weak uniform prior, we can use the same method recalculate the polling average and confidence interval for each day between today and the election. Because polls are weighted by recency, as we look further and further into the future, our confidence in the polls decreases and the confidence interval around the polling average fans out. Each candidate’s probability of winning is the portion of the portion of the projected election-day polling distribution in their favor, based on that day’s polling average.\n\n\nSome caveats worth noting\nThis is an inherently flawed method, and it’s worth pointing out a few of the flaws and shortcuts I used:\n\nThe functions used to weight polls are nowhere near perfect.\nThe original weighting functions (which I haven’t changed) were chosen somewhat arbitrarily. In hindsight, they’re probably placing too much emphasis on recency and the error bars ought to be larger. While I have received some advice on tuning arbitrary functions as a part of a larger model, I haven’t implemented here. It’s more prudent to think of this as an over-confident polling aggregate, rather than any sort of model. For a true projection model, I’d recommend looking at Jack Kersting’s website.\n\n\nThe weighting method ignores important weighting factors\nThis weighting method is super simple and ignores common weighting factors, like pollster and survey methodology. Other less-common poll weighting methods, like accounting for partisan non-response bias and and how the pollster weights their results (notably, whether or not the pollster weights by education) were similarly ignored. There is definitely a strong argument for including these weighting factors, but for me, this exercise was more about learning to use purrr::map() and other related functions when writing the script for this plot.\n\n\nSome pollsters are filtered out by design\nI debated this for quite some time, but decided to add a filter to remove polls conducted by Rasmussen and Trafalgar. Trafalgar is excluded from any of the Economist’s polling databases for opaque yet clearly shoddy methodology and Rasmussen is clearly partisan. Removing these from the average follows the general consensus on ET (though, to be transparent, ET does tend to slant far to the left). In future polling projects, I’d hope to develop some more robust methodology to programatically downweight problematic pollsters (how’s that for a tongue twister?), but for now I’m just going to exclude.\n\n\n\nFinal thoughts on polling\nThis methodology certainly has its flaws, but it is transparent. I’ll continuously update this plot up until election day on my github.\n\n\nSome programming notes\nI’ve finished migrating my site to Netlify! I had originally planned to make the switch from Squarespace sometime early in 2022, but motivation struck me during a relatively light work week and I was able to rebuild the site using blogdown. This allows for a lot more customization and control than was available with Squarespace, but the biggest upside is definitely the ease of sharing in-line code, here’s a quick example:\n\n\nCode\nlibrary(tidyverse)\n\n# let's put together a plot from the diamonds dataset\ndiamonds %>%\n  ggplot(aes(x = carat,\n             y = price,\n             color = cut)) +\n  geom_point(alpha = 0.1) +\n  theme_minimal() +\n  viridis::scale_color_viridis(discrete = TRUE)\n\n\n\n\n\nThis ease of use and visibility will make things more seamless for me and allow me to dig into more technical content in more detail in the future!\nI’ll be taking a (much needed) vacation next week, spending some time off the grid in the Grand Canyon and surrounding area with my family. I’ve got a short post lined up for early November when I return - see you then!\nAs always, you can find the source files for the script to generate the polling average and for this site on my github.\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {Polling {Average} of the {VA} {Governor’s} {Race} Using\n    Purrr::map Functions},\n  date = {2021-10-19},\n  url = {https://www.thedatadiary.net/posts/2021-10-19-polling-average-of-the-va-governor-s-race-using-purrr-map-functions},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “Polling Average of the VA Governor’s Race Using\nPurrr::map Functions.” October 19, 2021. https://www.thedatadiary.net/posts/2021-10-19-polling-average-of-the-va-governor-s-race-using-purrr-map-functions."
  },
  {
    "objectID": "posts/2021-11-02-election-night-some-closing-thoughts-on-the-va-governor-race/index.html",
    "href": "posts/2021-11-02-election-night-some-closing-thoughts-on-the-va-governor-race/index.html",
    "title": "Election Night: Some Closing Thoughts on the VA Governor Race",
    "section": "",
    "text": "A few weeks ago I had written about the VA Governor’s race before going on vacation - in that time it seems as though Terry McAuliffe’s campaign had lost a lot of steam and Youngkin made up a lot of ground in the final weeks of the campaign. At the time of this writing, it seems overwhelmingly likely that Glenn Youngkin will become the next governor of Virginia. To avoid some of the galaxy-brain takes that will inevitabely wind up twitter, I thought I’d distract myself by following up on my previous post.\nFirstly, I should share the updated polling average. A few weeks ago, McAullife appeared to have a sizeable lead in the polls:\n\nHowever, as of election day, the race had significantly tightened to effectively a coin-toss:\n\nAs I mention in the above tweet, the win probability isn’t a true forecast, just the portion of each candidate’s election day distribution above 50%. That being said, actual forecasts similarly had the race down to a near 50-50 split as of this morning:\n\n\nEven the model most confident in McAuliffe built by Lakshya Jain and Thorongil had dropped McAuliffe’s win probability from ~85% to 67% over the course of a few weeks:\n\nWhile I definitely plan on utilizing a more scientific poll-weighting methodology in the future, I do find it interesting that even a simple averaging method can produce relatively accurate results in line with the majority of other forecasters.\nRegarding post-hoc analysis of why McAuliffe lost, I won’t dredge up any of my own (partially because it’d be irresponsible & pundit-y to do so without referencing any data and partially because it’s getting late & I’m a bit tired), but I’ll point out a few tweets from Nate Cohn that show that the results appear to show a near uniform shift across precincts and different voting groups. This would suggest that McAuliffe’s loss is tied more closely to the national environment, rather than shifts amongst specific groups/counties.\n\n\nThis won’t stop the networks from ascribing the win/loss to very specific campaign issues (I’ve already seen quite a few folks ascribe Youngkin’s win to education, race, suburban-reversion, etc., without any evidence to back up such claims). Until there are deep dives into data regarding the election, I’d treat any comments from pundits with a hefty grain of salt.\n\nSome closing thoughts\nThat’s all for me today! I’ll be back in a few weeks with some non-political content, looking at a machine learning model predicting the price of a diamond in the diamonds dataset.\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {Election {Night:} {Some} {Closing} {Thoughts} on the {VA}\n    {Governor} {Race}},\n  date = {2021-11-02},\n  url = {https://www.thedatadiary.net/posts/2021-11-02-election-night-some-closing-thoughts-on-the-va-governor-race},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “Election Night: Some Closing Thoughts on the VA\nGovernor Race.” November 2, 2021. https://www.thedatadiary.net/posts/2021-11-02-election-night-some-closing-thoughts-on-the-va-governor-race."
  },
  {
    "objectID": "posts/2021-11-14-diamonds-are-forever-feature-engineering-with-the-diamonds-dataset/index.html",
    "href": "posts/2021-11-14-diamonds-are-forever-feature-engineering-with-the-diamonds-dataset/index.html",
    "title": "Diamonds are Forever",
    "section": "",
    "text": "Are y’all ready for some charts?? This week, I did a bit of machine learning practice with the diamonds dataset. This dataset is interesting and good for practice for a few reasons:\n\nthere are lots of observations (50,000+);\nit includes a mix of numeric and categorical variables;\nthere are some data oddities to deal with (log scales, interactions, non-linear relations)\n\nI’ll be doing a bit of feature engineering prior to fitting an tuning a linear model that predicts the each diamond’s price with the glmnet package. This will give a good end-to-end glimpse into the data exploration and model fitting process! Before we get into that, let’s load some packages and get a preview of the dataset.\n\n\nCode\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(vip)\n\ntheme_set(theme_minimal())\n\ndiamonds %>%\n  slice_head(n = 10)\n\n\n# A tibble: 10 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n\n\nSince we’re predicting price, let’s look at its distribution first.\n\n\nCode\ndiamonds %>%\n  ggplot(aes(x = price)) +\n  geom_histogram()\n\n\n\n\n\nWe’re definitely gonna want to apply a transformation to the price when modeling - let’s look at the distribution on a log-10 scale.\n\n\nCode\ndiamonds %>%\n  ggplot(aes(x = price)) +\n  geom_histogram() +\n  scale_x_log10()\n\n\n\n\n\nThat’s a lot more evenly distributed, if not perfect. That’s a fine starting point, so now we’ll look through the rest of the data.\n\n\nCode\ndiamonds %>%\n  ggplot(aes(x = carat)) +\n  geom_histogram()\n\n\n\n\n\nCode\ndiamonds %>%\n  ggplot(aes(x = cut,\n             y = price)) +\n  geom_boxplot()\n\n\n\n\n\nCode\ndiamonds %>%\n  count(cut) %>%\n  ggplot(aes(x = cut,\n             y = n)) +\n  geom_col()\n\n\n\n\n\nCode\ndiamonds %>%\n  ggplot(aes(x = color,\n             y = price)) +\n  geom_boxplot()\n\n\n\n\n\nCode\ndiamonds %>%\n  count(color) %>%\n  ggplot(aes(x = color,\n             y = n)) +\n  geom_col()\n\n\n\n\n\nCode\ndiamonds %>%\n  ggplot(aes(x = clarity,\n             y = price)) +\n  geom_boxplot()\n\n\n\n\n\nCode\ndiamonds %>%\n  count(clarity) %>%\n  ggplot(aes(x = clarity,\n             y = n)) +\n  geom_col()\n\n\n\n\n\nCode\ndiamonds %>%\n  ggplot(aes(x = depth)) +\n  geom_histogram()\n\n\n\n\n\nCode\ndiamonds %>%\n  ggplot(aes(x = table)) +\n  geom_histogram() \n\n\n\n\n\nCode\ndiamonds %>%\n  ggplot(aes(x = x)) +\n  geom_histogram()\n\n\n\n\n\nCode\ndiamonds %>%\n  ggplot(aes(x = y)) +\n  geom_histogram() \n\n\n\n\n\nCode\ndiamonds %>% \n  ggplot(aes(x = z)) +\n  geom_histogram()\n\n\n\n\n\nIt looks like there may be a good opportunity to try out a few normalization and resampling techniques, but before we get into any of that, let’s build a baseline linear model.\n\n\nCode\n# splits\ndiamonds_split <- initial_split(diamonds)\ndiamonds_train <- training(diamonds_split)\ndiamonds_test <- testing(diamonds_split)\n\n# resamples (don't want to use testing data!)\ndiamonds_folds <- vfold_cv(diamonds_train)\n\n# model spec\nmod01 <-\n  linear_reg() %>%\n  set_engine(\"lm\")\n\n# recipe\nrec01 <-\n  recipe(price ~ ., data = diamonds_train) %>%\n  step_dummy(all_nominal_predictors())\n\n# controls\nctrl_preds <- \n  control_resamples(save_pred = TRUE)\n\n# create a wf\nwf01 <-\n  workflow() %>%\n  add_model(mod01) %>%\n  add_recipe(rec01)\n\n# parallel processing\ndoParallel::registerDoParallel()\n\n# fit\nrs01 <- \n  fit_resamples(\n    wf01,\n    diamonds_folds,\n    control = ctrl_preds\n  )\n\n# metrics!\ncollect_metrics(rs01)\n\n\n# A tibble: 2 × 6\n  .metric .estimator     mean     n std_err .config             \n  <chr>   <chr>         <dbl> <int>   <dbl> <chr>               \n1 rmse    standard   1135.       10 8.10    Preprocessor1_Model1\n2 rsq     standard      0.919    10 0.00129 Preprocessor1_Model1\n\n\nAnd right off the bat, we can see a fairly high value for rsq! However, rsq doesn’t tell the whole story, so we should check our predictions and residuals plots.\n\n\nCode\naugment(rs01) %>%\n  ggplot(aes(x = price,\n             y = .pred)) +\n  geom_point(alpha = 0.01) +\n  geom_abline(linetype = \"dashed\",\n              size = 0.1,\n              alpha = 0.5)\n\n\n\n\n\nThis is definitely not what we want to see! It looks like there’s an odd curve/structure to the graph and we’re actually predicting quite a few negative values. The residuals plot doesn’t look too great either.\n\n\nCode\naugment(rs01) %>%\n  ggplot(aes(x = price,\n             y = .resid)) +\n  geom_point(alpha = 0.01) +\n  geom_hline(yintercept = 0,\n             linetype = \"dashed\",\n             alpha = 0.5,\n             size = 0.1)\n\n\n\n\n\nWhat we’d like to see is a 0-correlation plot with errors normally distributed; what we’re seeing instead, however, is a ton of structure.\nThat being said, that’s okay! we expected this first pass to be pretty rough! And the price is clearly on a log-10 scale. To make apples-apples comparisons with models going forward, I’ll retrain this basic linear model to predict the log10(price). This’ll involve a bit of data re-manipulation!\n\n\nCode\n# log transform price\ndiamonds_model <-\n  diamonds %>%\n  mutate(price = log10(price),\n         across(cut:clarity, as.character))\n\n# bad practice copy + paste lol\n\n# splits\nset.seed(999)\ndiamonds_split <- initial_split(diamonds_model)\ndiamonds_train <- training(diamonds_split)\ndiamonds_test <- testing(diamonds_split)\n\n# resamples (don't want to use testing data!)\nset.seed(888)\ndiamonds_folds <- vfold_cv(diamonds_train)\n\n# model spec\nmod01 <-\n  linear_reg() %>%\n  set_engine(\"lm\")\n\n# recipe\nrec01 <-\n  recipe(price ~ ., data = diamonds_train) %>%\n  step_dummy(all_nominal_predictors())\n\n# controls\nctrl_preds <- \n  control_resamples(save_pred = TRUE)\n\n# create a wf\nwf01 <-\n  workflow() %>%\n  add_model(mod01) %>%\n  add_recipe(rec01)\n\n# parallel processing\ndoParallel::registerDoParallel()\n\n# fit\nset.seed(777)\nrs01 <- \n  fit_resamples(\n    wf01,\n    diamonds_folds,\n    control = ctrl_preds\n  )\n\n# metrics!\ncollect_metrics(rs01)\n\n\n# A tibble: 2 × 6\n  .metric .estimator   mean     n std_err .config             \n  <chr>   <chr>       <dbl> <int>   <dbl> <chr>               \n1 rmse    standard   0.0793    10 0.00557 Preprocessor1_Model1\n2 rsq     standard   0.966     10 0.00494 Preprocessor1_Model1\n\n\nAnd wow, that one transformation increased our rsq to 0.96! Again, that’s not the whole story, and we’re going to be evaluating models based on the rmse. Let’s look at how our prediction map has updated:\n\n\nCode\nrs01 %>%\n  augment() %>%\n  ggplot(aes(x = price,\n             y = .pred)) +\n  geom_point(alpha = 0.01) +\n  geom_abline(linetype = \"dashed\",\n              size = 0.1,\n              alpha = 0.5) \n\n\n\n\n\nNow that is a much better starting place to be at! Let’s look at our coefficients\n\n\nCode\nset.seed(666) # :thedevilisalive:\nwf01 %>%\n  fit(diamonds_train) %>%\n  pull_workflow_fit() %>%\n  vip::vi() %>%\n  mutate(Variable = fct_reorder(Variable, Importance)) %>%\n  ggplot(aes(x = Variable,\n             y = Importance,\n             fill = Sign)) +\n  geom_col() +\n  coord_flip() + \n  theme(plot.title.position = \"plot\") +\n  labs(x = NULL,\n       y = NULL,\n       title = \"Diamonds are forever\",\n       subtitle = \"Variable importance plot of a basic linear regression predicting diamond price\")\n\n\n\n\n\nAnother way of looking at it:\n\n\nCode\nset.seed(666)\nwf01 %>%\n  fit(diamonds_train) %>%\n  pull_workflow_fit() %>%\n  vip::vi() %>%\n  mutate(Importance = if_else(Sign == \"NEG\", Importance * -1, Importance),\n         Variable = fct_reorder(Variable, Importance)) %>%\n  ggplot(aes(x = Variable,\n             y = Importance,\n             fill = Sign)) +\n  geom_col() +\n  coord_flip() +\n  labs(title = \"Diamonds are forever\",\n       subtitle = \"Variable importance plot of a basic linear regression predicting diamond price\",\n       x = NULL,\n       y = NULL) +\n  theme(plot.title.position = \"plot\")\n\n\n\n\n\nThis is a good, but definitely improvable, starting point. We can likely decrease our overall error with a bit of feature engineering and drop unimportant features by tuning a regularized model. There are some oddities in this initial model that will need to be improved upon; for one, we can definitively say that the carat feature ought to be positively associated with price\n\n\nCode\ndiamonds_train %>%\n  ggplot(aes(x = carat,\n             y = price)) +\n  geom_point(alpha = 0.01) +\n  labs(title = \"A clear positive (albeit nonlinear) relationship between `carat` and `price`\") +\n  theme(plot.title.position = \"plot\")\n\n\n\n\n\nAnother few things that are interesting to note in this plot! It looks like there are clusterings of carat ratings around round-ish numbers. My hypothesis here is that carat ratings tend to get rounded up to the next size. There’s also a clear abscence of diamonds priced at $1,500 (~3.17 on the log10 scale). I suppose there is some industry-specific reason to avoid a diamond price of $,1500?\n\n\nCode\ndiamonds_train %>%\n  ggplot(aes(x = carat,\n             y = price)) +\n  geom_point(alpha = 0.01) +\n  labs(title = \"A clear positive (albeit nonlinear) relationship between `carat` and `price`\") +\n  theme(plot.title.position = \"plot\") +\n  geom_hline(yintercept = log10(1500),\n             linetype = \"dashed\",\n             size = 0.9,\n             alpha = 0.5)\n\n\n\n\n\nHow to address all these things? With some feature engineering! Firstly, let’s add some recipe steps to balance classes & normalize continuous variables.\nBut before I get into that, I’ll save the resample metrics so that we can compare models!\n\n\nCode\nmetrics <- collect_metrics(rs01) %>% mutate(model = \"model01\")\n\nmetrics\n\n\n# A tibble: 2 × 7\n  .metric .estimator   mean     n std_err .config              model  \n  <chr>   <chr>       <dbl> <int>   <dbl> <chr>                <chr>  \n1 rmse    standard   0.0793    10 0.00557 Preprocessor1_Model1 model01\n2 rsq     standard   0.966     10 0.00494 Preprocessor1_Model1 model01\n\n\n\n\nCode\n# spec will be the same as model01\nmod02 <- mod01\n\n# recipe!\nrec02 <- \n  recipe(price ~ ., data = diamonds_train) %>%\n  step_other(cut, color, clarity) %>% \n  step_dummy(all_nominal_predictors(), -cut) %>%\n  \n  # use smote resampling to balance classes\n  themis::step_smote(cut) %>% \n    \n  # normalize continuous vars\n  bestNormalize::step_best_normalize(carat, depth, table, x, y, z)\n\n\nLet’s bake our recipe to verify that everything looks up-to-snuff in the preprocessed dataset.\n\n\nCode\nbaked_rec02 <- \n  rec02 %>%\n  prep() %>%\n  bake(new_data = NULL)\n\nbaked_rec02\n\n\n# A tibble: 80,495 × 20\n     carat cut        depth  table       x       y      z price color_E color_F\n     <dbl> <fct>      <dbl>  <dbl>   <dbl>   <dbl>  <dbl> <dbl>   <dbl>   <dbl>\n 1 -0.706  Premium    0.138 -0.760 -0.709  -0.738  -0.695  3.01       0       1\n 2  0.356  Very Good  0.570  0.835  0.342   0.251   0.344  3.63       0       0\n 3  0.214  Premium   -0.308  0.835  0.293   0.263   0.166  3.58       0       0\n 4 -1.08   other      1.04  -0.310 -1.30   -1.40   -0.995  2.70       0       0\n 5 -0.641  Ideal     -0.602 -0.760 -0.595  -0.560  -0.622  2.97       0       0\n 6 -0.0759 Premium   -0.602  0.494 -0.0349 -0.0460 -0.114  3.38       0       0\n 7 -0.149  Premium   -1.16   0.103 -0.0565 -0.0842 -0.246  3.44       1       0\n 8  0.170  Very Good -0.371  0.494  0.178   0.313   0.130  3.56       0       1\n 9 -0.736  Ideal     -0.110 -0.760 -0.709  -0.738  -0.723  3.09       0       0\n10  0.782  Ideal     -0.602 -0.310  0.819   0.846   0.732  4.02       0       0\n# … with 80,485 more rows, and 10 more variables: color_G <dbl>, color_H <dbl>,\n#   color_I <dbl>, color_J <dbl>, clarity_SI2 <dbl>, clarity_VS1 <dbl>,\n#   clarity_VS2 <dbl>, clarity_VVS1 <dbl>, clarity_VVS2 <dbl>,\n#   clarity_other <dbl>\n\n\n\n\nCode\nbaked_rec02 %>%\n  count(cut) %>%\n  ggplot(aes(x = cut,\n             y = n)) +\n  geom_col()\n\n\n\n\n\nCode\nbaked_rec02 %>%\n  ggplot(aes(x = carat)) +\n  geom_histogram()\n\n\n\n\n\nCode\nbaked_rec02 %>%\n  ggplot(aes(x = depth)) +\n  geom_histogram()\n\n\n\n\n\nCode\nbaked_rec02 %>%\n  ggplot(aes(x = table)) +\n  geom_histogram()\n\n\n\n\n\nCode\nbaked_rec02 %>%\n  ggplot(aes(x = x)) +\n  geom_histogram()\n\n\n\n\n\nCode\nbaked_rec02 %>%\n  ggplot(aes(x = y)) +\n  geom_histogram() \n\n\n\n\n\nCode\nbaked_rec02 %>%\n  ggplot(aes(x = z)) +\n  geom_histogram()\n\n\n\n\n\nEverything looks alright with the exception of the table predictor. I wonder if there are a lot of repeated values in the table variable - that may be why we’re seeing a “chunky” histogram. Let’s check\n\n\nCode\nbaked_rec02 %>%\n  count(table) %>%\n  arrange(desc(n))\n\n\n# A tibble: 10,406 × 2\n    table     n\n    <dbl> <int>\n 1  0.103 12167\n 2 -0.310 11408\n 3 -0.760 11031\n 4  0.494  9406\n 5 -1.28   6726\n 6  0.835  6165\n 7  1.15   3810\n 8 -1.85   2789\n 9  1.42   2182\n10  1.64    972\n# … with 10,396 more rows\n\n\nOoh - okay yeah that’s definitely the issue! I’m not quite sure how to deal with it, so we’re just going to ignore for now! Let’s add a new model & see how it compares against the baseline transformed model.\n\n\nCode\nwf02 <-\n  workflow() %>%\n  add_model(mod02) %>%\n  add_recipe(rec02)\n\n# stop parallel to avoid error!\n# need to replace with PSOCK clusters\n# see github issue here: https://github.com/tidymodels/recipes/issues/847\nforeach::registerDoSEQ()\n\nset.seed(666) # spoopy\nrs02 <-\n  fit_resamples(\n    wf02,\n    diamonds_folds,\n    control = ctrl_preds\n  )\n\ncollect_metrics(rs02)\n\n\n# A tibble: 2 × 6\n  .metric .estimator  mean     n std_err .config             \n  <chr>   <chr>      <dbl> <int>   <dbl> <chr>               \n1 rmse    standard   0.115    10 0.00143 Preprocessor1_Model1\n2 rsq     standard   0.932    10 0.00161 Preprocessor1_Model1\n\n\nOof - that’s actually slightly worse than our baseline model!\n\n\nCode\nrs02 %>%\n  augment() %>%\n  ggplot(aes(x = price,\n             y = .pred)) +\n  geom_point(alpha = 0.01) +\n  geom_abline(linetype = \"dashed\",\n              size = 0.1,\n              alpha = 0.5) \n\n\n\n\n\nIt looks like we’ve introduced structure into the residual plot!\n\n\nCode\nrs02 %>%\n  augment() %>%\n  ggplot(aes(x = price,\n             y = .resid)) +\n  geom_point(alpha = 0.01) +\n  geom_hline(yintercept = 0,\n             linetype = \"dashed\",\n             size = 0.1,\n             alpha = 0.5)\n\n\n\n\n\nYeah that’s fairly wonky! I’m wondering if it’s due to the SMOTE upsampling method we introduced? To counteract, I’ll build & train new models after each set of recipe steps (e.g., resampling, normalizing, interactions) to buil up a better performing model one step at a time.\n\n\nCode\nmetrics <- \n  metrics %>%\n  bind_rows(collect_metrics(rs02) %>% mutate(model = \"model02\"))\n\n\n\n\nCode\n# same model spec\nmod03 <- mod02\n\n# rebuild rec+wf & retrain\nrec03 <- \n  recipe(price ~ ., data = diamonds_train) %>%\n  step_other(cut, color, clarity) %>%\n  step_dummy(all_nominal_predictors(), -cut) %>%\n  themis::step_smote(cut)\n\nwf03 <- \n  workflow() %>%\n  add_model(mod03) %>%\n  add_recipe(rec03)\n\n# do paralllel\ndoParallel::registerDoParallel()\n\n# refit!\nset.seed(123)\nrs03 <-\n  fit_resamples(\n    wf03,\n    diamonds_folds,\n    control = ctrl_preds\n  )\n\ncollect_metrics(rs03)\n\n\n# A tibble: 2 × 6\n  .metric .estimator   mean     n std_err .config             \n  <chr>   <chr>       <dbl> <int>   <dbl> <chr>               \n1 rmse    standard   0.0918    10 0.00502 Preprocessor1_Model1\n2 rsq     standard   0.956     10 0.00502 Preprocessor1_Model1\n\n\nInteresting! Improved relative to rs02, but still not as good as our first model! Let’s try using step_downsample() to balance classes & see how we fare.\n\n\nCode\n# cleanup some large-ish items eating up memory\nrm(mod01, mod02, rec01, rec02, wf01, wf02, rs01, rs02)\n\n# save metrics\nmetrics <- \n  metrics %>%\n  bind_rows(collect_metrics(rs03) %>% mutate(model = \"model03\"))\n\n# new mod\nmod04 <- mod03\n\n# new rec\nrec04 <-\n  recipe(price ~ ., data = diamonds_train) %>%\n  step_other(cut, color, clarity) %>%\n  step_dummy(all_nominal_predictors(), -cut) %>%\n  themis::step_downsample(cut)\n\nwf04 <-\n  workflow() %>%\n  add_model(mod04) %>%\n  add_recipe(rec04) \n\nset.seed(456) \nrs04 <-\n  fit_resamples(\n    wf04,\n    diamonds_folds,\n    control = ctrl_preds\n  )\n\ncollect_metrics(rs04)\n\n\n# A tibble: 2 × 6\n  .metric .estimator  mean     n std_err .config             \n  <chr>   <chr>      <dbl> <int>   <dbl> <chr>               \n1 rmse    standard   0.113    10  0.0120 Preprocessor1_Model1\n2 rsq     standard   0.930    10  0.0153 Preprocessor1_Model1\n\n\nWow - still a bit worse! I’ll try upsampling & if there is no improvement, we’ll move on without resampling!\n\n\nCode\nmetrics <-\n  metrics %>%\n  bind_rows(collect_metrics(rs04) %>% mutate(model = \"model04\"))\n\nmod05 <- mod04\n\nrec05 <-\n  recipe(price ~ ., data = diamonds_train) %>%\n  step_other(cut, color, clarity) %>%\n  step_dummy(all_nominal_predictors(), -cut) %>%\n  themis::step_upsample(cut)\n\nwf05 <- \n  workflow() %>%\n  add_model(mod05) %>%\n  add_recipe(rec05) \n\nset.seed(789)\nrs05 <-\n  fit_resamples(\n    wf05,\n    diamonds_folds,\n    control = ctrl_preds\n  )\n\ncollect_metrics(rs05)\n\n\n# A tibble: 2 × 6\n  .metric .estimator  mean     n std_err .config             \n  <chr>   <chr>      <dbl> <int>   <dbl> <chr>               \n1 rmse    standard   0.101    10 0.00486 Preprocessor1_Model1\n2 rsq     standard   0.946    10 0.00527 Preprocessor1_Model1\n\n\nOkay - resampling gets stricken off our list of recipe steps! Let’s look at how the models compare so far\n\n\nCode\nmetrics <-\n  metrics %>%\n  bind_rows(collect_metrics(rs05) %>% mutate(model = \"model05\"))\n\nmetrics %>%\n  ggplot(aes(x = model)) +\n  geom_point(aes(y = mean)) +\n  geom_errorbar(aes(ymin = mean - std_err,\n                    ymax = mean + std_err)) +\n  facet_wrap(~.metric, scales = \"free_y\")\n\n\n\n\n\nThe first simple linear model was the best as measured by both metrics! Let’s see if we can improve with some normalization of the continuous vars.\n\n\nCode\nrm(mod03, mod04, rec03, rec04, rs03, rs04, wf03, wf04)\n\nmod06 <- mod05\n\nrec06 <-\n  recipe(price ~ ., data = diamonds_train) %>%\n  step_other(cut, color, clarity) %>%\n  bestNormalize::step_best_normalize(all_numeric_predictors()) %>%\n  step_dummy(all_nominal_predictors())\n\nwf06 <-\n  workflow() %>%\n  add_model(mod06) %>%\n  add_recipe(rec06)\n\nforeach::registerDoSEQ()\nset.seed(101112)\nrs06 <-\n  fit_resamples(\n    wf06,\n    diamonds_folds,\n    control = ctrl_preds\n  )\n\ncollect_metrics(rs06)\n\n\n# A tibble: 2 × 6\n  .metric .estimator  mean     n std_err .config             \n  <chr>   <chr>      <dbl> <int>   <dbl> <chr>               \n1 rmse    standard   0.127    10 0.00115 Preprocessor1_Model1\n2 rsq     standard   0.916    10 0.00136 Preprocessor1_Model1\n\n\nWell - that was quite a bit for no improvement! I guess that normalizing the continuous vars in this case isn’t helping. Moving on to adding some interactions - first let’s explore potential interactions a bit.\n\n\nCode\nmetrics <-\n  metrics %>% \n  bind_rows(collect_metrics(rs06) %>% mutate(model = \"model06\"))\n\ndiamonds_train %>%\n  ggplot(aes(x = carat,\n             y = price,\n             color = cut)) +\n  geom_point(alpha = 0.05) + \n  geom_smooth(method = \"lm\", se = FALSE)\n\n\n\n\n\n\n\nCode\nlibrary(splines)\ndiamonds_train %>%\n  ggplot(aes(x = carat,\n             y = price,\n             color = cut)) +\n  geom_point(alpha = 0.05) +\n  geom_smooth(method = lm,\n              formula = y ~ ns(x, df = 5),\n              se = FALSE) +\n  facet_wrap(~cut, scales = \"free\")\n\n\n\n\n\n5 spline terms might not be sufficient here - capturing the lower bound well but really not doing well with the higher carat diamonds.\n\n\nCode\ndiamonds_train %>%\n  ggplot(aes(x = carat,\n             y = price,\n             color = cut)) +\n  geom_point(alpha = 0.05) +\n  geom_smooth(method = lm,\n              formula = y ~ ns(x, df = 10),\n              se = FALSE) +\n  facet_wrap(~cut, scales = \"free\")\n\n\n\n\n\nHmmmm, 10 might be too many. It looks lie we’ll just lose a bit of confidence for the Premium & Very Good diamonds at higher carats. Relative to the total number, I’m not too concerned.\n\n\nCode\ndiamonds_train %>%\n  ggplot(aes(x = carat,\n             y = price,\n             color = cut)) +\n  geom_point(alpha = 0.05) +\n  geom_smooth(method = lm,\n              formula = y ~ ns(x, df = 7),\n              se = FALSE) +\n  facet_wrap(~cut, scales = \"free\")\n\n\n\n\n\n7 terms feels like the best we’re going to do here - I think this is tuneable, but we’ll leave as is (now & in the final model).\nNext, we’ll look at creating interactions between the color and carat variables:\n\n\nCode\ndiamonds_train %>%\n  ggplot(aes(x = carat, \n             y = price,\n             color = color)) +\n  geom_point(alpha = 0.05) +\n  geom_smooth(method = lm, \n              formula = y ~ ns(x, df = 15),\n              se = FALSE) +\n  facet_wrap(~color)\n\n\n\n\n\nAdding interactive spline terms with df of 15 seems to add some useful information!\nWe have three shape parameters, x, y, and z - I wonder if creating a stand-in for volume by multiplying them all together will provide any useful information?\n\n\nCode\ndiamonds_train %>%\n  mutate(volume_param = x * y * z) %>%\n  ggplot(aes(x = volume_param,\n             y = price)) +\n  geom_point(alpha = 0.05)\n\n\n\n\n\nOoh, looks like we’re getting some good info here, but we may want to use log10 to scale this back.\n\n\nCode\ndiamonds_train %>%\n  mutate(volume_param = log10(x * y * z)) %>%\n  ggplot(aes(x = volume_param, \n             y = price)) +\n  geom_point(alpha = 0.05)\n\n\n\n\n\nLet’s see if this ought to interact with any other paramaters:\n\n\nCode\ndiamonds_train %>%\n  mutate(volume_param = log10(x * y * z)) %>%\n  ggplot(aes(x = volume_param, \n             y = price,\n             color = cut)) +\n  geom_point(alpha = 0.05) +\n  geom_smooth(method = \"lm\", se = FALSE)\n\n\n\n\n\nCode\ndiamonds_train %>%\n  mutate(volume_param = log10(x * y * z)) %>%\n  ggplot(aes(x = volume_param, \n             y = price,\n             color = color)) +\n  geom_point(alpha = 0.05) +\n  geom_smooth(method = \"lm\", se = FALSE)\n\n\n\n\n\nCode\ndiamonds_train %>%\n  mutate(volume_param = log10(x * y * z)) %>%\n  ggplot(aes(x = volume_param, \n             y = price,\n             color = clarity)) +\n  geom_point(alpha = 0.05) +\n  geom_smooth(method = \"lm\", se = FALSE)\n\n\n\n\n\nHmm, it doesn’t really look like we’re capturing too great of interactions, so I’ll leave out for now. It looks like the size of the rock is more important than anything else! I could continue to dig further, but I’ll stop there. I’m likely getting diminishing returns, & I’d like to get back into modeling!\n\n\nCode\nmod07 <- mod06\n\nrec07 <-\n  recipe(price ~ ., data = diamonds_train) %>%\n  step_other(cut, color, clarity) %>%\n  step_dummy(all_nominal_predictors()) %>%\n  step_interact(~carat:starts_with(\"cut_\")) %>%\n  step_interact(~carat:starts_with(\"color_\")) %>%\n  step_mutate_at(c(x, y, z),\n                 fn = ~if_else(.x == 0, mean(.x), .x)) %>%\n  step_mutate(volume_param = log10(x * y * z)) %>%\n  step_ns(starts_with(\"carat_x_cut\"), deg_free = 7) %>%\n  step_ns(starts_with(\"carat_x_color\"), deg_free = 15) \n\nrec07\n\n\nRecipe\n\nInputs:\n\n      role #variables\n   outcome          1\n predictor          9\n\nOperations:\n\nCollapsing factor levels for cut, color, clarity\nDummy variables from all_nominal_predictors()\nInteractions with carat:starts_with(\"cut_\")\nInteractions with carat:starts_with(\"color_\")\nVariable mutation for c(x, y, z)\nVariable mutation for log10(x * y * z)\nNatural splines on starts_with(\"carat_x_cut\")\nNatural splines on starts_with(\"carat_x_color\")\n\n\nCode\nwf07 <-\n  workflow() %>%\n  add_model(mod07) %>%\n  add_recipe(rec07)\n\ndoParallel::registerDoParallel()\nset.seed(9876)\nrs07 <-\n  fit_resamples(\n    wf07,\n    diamonds_folds,\n    control = ctrl_preds\n  )\n\n\nThis is definitely going to way overfit our data:\n\n\nCode\nrs07 %>%\n  collect_metrics()\n\n\n# A tibble: 2 × 6\n  .metric .estimator   mean     n std_err .config             \n  <chr>   <chr>       <dbl> <int>   <dbl> <chr>               \n1 rmse    standard   0.0750    10 0.00377 Preprocessor1_Model1\n2 rsq     standard   0.970     10 0.00342 Preprocessor1_Model1\n\n\nWell we (finally) made a modes improvement! Let’s see how the predictions/residuals plot:\n\n\nCode\nrs07 %>%\n  augment() %>%\n  ggplot(aes(x = price,\n             y = .pred)) +\n  geom_point(alpha = 0.05) +\n  geom_abline(linetype = \"dashed\",\n              alpha = 0.5,\n              size = 0.5)\n\n\n\n\n\nThat’s pretty good! We do have one value that’s way off, so let’s see if regulization can help. This will require setting a new baseline model, and we’ll tune our way to the best regularizaion parameters.\n\n\nCode\nmetrics <- \n  rs07 %>%\n  collect_metrics() %>%\n  mutate(model = \"model07\") %>%\n  bind_rows(metrics)\n\n# add normalization step\nrec08 <- \n  rec07 %>% \n  step_zv(all_numeric_predictors()) %>%\n  step_normalize(all_numeric_predictors(),\n                 -cut_Ideal, -cut_Premium, -cut_Very.Good, -cut_other,\n                 -color_E, -color_F, -color_G, -color_H, -color_I, -color_J,\n                 -clarity_SI2, -clarity_VS1, -clarity_VS2, -clarity_VVS1, -clarity_VVS2, -clarity_other)\n\nrm(mod05, mod06, mod07, rec05, rec06, rec07, wf05, wf06, wf07, rs05, rs06, rs07)\n\nmod08 <-\n  linear_reg(penalty = tune(), mixture = tune()) %>%\n  set_engine(\"glmnet\") %>%\n  set_mode(\"regression\") \n\nwf08 <-\n  workflow() %>%\n  add_model(mod08) %>%\n  add_recipe(rec08)\n\ndiamonds_grid <- \n  grid_regular(penalty(), mixture(), levels = 20)\n\ndoParallel::registerDoParallel()\nset.seed(5831)\nrs08 <-\n  tune_grid(\n    wf08,\n    resamples = diamonds_folds,\n    control = ctrl_preds,\n    grid = diamonds_grid\n  )\n\n\nSome notes but let’s explore our results…\n\n\nCode\nrs08 %>%\n  collect_metrics() %>%\n  ggplot(aes(x = penalty,\n             y = mean,\n             color = as.character(mixture))) +\n  geom_point() +\n  geom_line(alpha = 0.75) +\n  facet_wrap(~.metric, scales = \"free\") +\n  scale_x_log10()\n\n\n\n\n\nLooks like we were performing pretty well with the unregularized model, oddly enough! Let’s select the best and finalize our workflow.\n\n\nCode\nbest_metrics <- \n  rs08 %>%\n  select_best(\"rmse\")\n\nwf_final <- \n  finalize_workflow(wf08, best_metrics)\n\nrm(mod08, rec07, rec08, rs08, wf08)\n\nset.seed(333)\nfinal_fit <- \n  wf_final %>%\n  fit(diamonds_train)\n\nfinal_fit %>%\n  predict(diamonds_test) %>%\n  bind_cols(diamonds_test) %>%\n  select(price, .pred) %>%\n  ggplot(aes(x = price, \n             y = .pred)) +\n  geom_point(alpha = 0.05) + \n  geom_abline(alpha = 0.5,\n              linetype = \"dashed\",\n              size = 0.5)\n\n\n\n\n\nWhat are the most important variables in this regularized model?\n\n\nCode\nfinal_fit %>%\n  pull_workflow_fit() %>%\n  vi(lambda = best_metrics$penalty) %>%\n  mutate(Variable = fct_reorder(Variable, Importance)) %>%\n  ggplot(aes(x = Variable,\n             y = Importance, \n             fill = Sign)) +\n  geom_col() +\n  coord_flip()\n\n\n\n\n\nAs expected, most of our terms get regularized away, which is what we want! Our chart is a little unreadable; let’s plot just the most important variables in a few ways:\n\n\nCode\nfinal_fit %>%\n  pull_workflow_fit() %>%\n  vi(lambda = best_metrics$penalty) %>%\n  arrange(desc(Importance)) %>%\n  slice_head(n = 10) %>%\n  mutate(Variable = fct_reorder(Variable, Importance)) %>%\n  ggplot(aes(x = Variable,\n             y = Importance,\n             fill = Sign)) +\n  geom_col() +\n  coord_flip()\n\n\n\n\n\n\n\nCode\nfinal_fit %>%\n  pull_workflow_fit() %>%\n  vi(lambda = best_metrics$penalty) %>%\n  arrange(desc(Importance)) %>% \n  slice_head(n = 10) %>%\n  mutate(Importance = if_else(Sign == \"NEG\", -Importance, Importance),\n         Variable = fct_reorder(Variable, Importance)) %>%\n  ggplot(aes(x = Variable,\n             y = Importance,\n             fill = Sign)) + \n  geom_col() +\n  coord_flip()\n\n\n\n\n\nAnd look at that! Our most important variable was one that came from feature engineering! The size of the rock had the biggest impact on price.\nWe’ve gone through a lot of steps, so it may be good to look back on what was done:\n\nExplored our dataset via some simple exploratory data analysis;\nFit a simple linear model to predict the log-transform of price;\nAttempted (and failed) to improve upon the simple model with fancier normalization and resampling techniques;\nExplored the dataset further to find meaningful interactions and potential new features;\nFit a new model with feature engineering;\nTuned regularization parameters on our model with feature engineering to arrive at the final model.\n\nOur models’ performances, ranked from best to worst, show that the final tuned model did indeed perform the best on the test dataset!\n\n\nCode\nfinal_preds <-\n  final_fit %>%\n  predict(diamonds_train) %>%\n  bind_cols(diamonds_train) %>%\n  select(price, .pred)\n\nbind_rows(final_preds %>% rmse(price, .pred),\n          final_preds %>% rsq(price, .pred)) %>%\n  rename(mean = .estimate) %>%\n  select(-.estimator) %>%\n  mutate(model = \"model_final\") %>%\n  bind_rows(metrics %>% select(.metric, mean, model)) %>%\n  pivot_wider(names_from = .metric,\n              values_from = mean) %>%\n  mutate(model = fct_reorder(model, desc(rmse))) %>%\n  pivot_longer(rmse:rsq,\n               names_to = \"metric\",\n               values_to = \"value\") %>%\n  ggplot(aes(x = model,\n             y = value)) +\n  geom_point() +\n  facet_wrap(~metric, scales = \"free\") +\n  coord_flip()\n\n\n\n\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {Diamonds Are {Forever}},\n  date = {2021-11-14},\n  url = {https://www.thedatadiary.net/posts/2021-11-14-diamonds-are-forever-feature-engineering-with-the-diamonds-dataset},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “Diamonds Are Forever.” November 14,\n2021. https://www.thedatadiary.net/posts/2021-11-14-diamonds-are-forever-feature-engineering-with-the-diamonds-dataset."
  },
  {
    "objectID": "posts/2021-11-28-technical-books/index.html",
    "href": "posts/2021-11-28-technical-books/index.html",
    "title": "Technical Books!",
    "section": "",
    "text": "Happy (belated) Thanksgiving! This year, my family drove down to Houston for the holiday & I hosted Thanksgiving for the first time. We played lots of games and ate well - my fridge is still stocked full of leftovers. Knowing we’d be busy with hosting, I planned ahead and scheduled a lighter post - this week, I thought I’d highlight some technical books that I’ve either referenced for modeling work, have been recommended to me, or I’ve heard about and would like to read:\n\nThe Elements of Statistical Learning is referenced as the Bible of Machine Learning by Josh Starmer and provides a robust and deeply technical foundation for a wide array of machine learning models. It’s considered a must-have among both machine learning theorists, who look for new model structures, and practitioners (like myself!).\nAn Introduction to Statistical Learning with Applications in R is a companion to The Elements of Statistical Learning. An Introduction to Statistical Learning arose as a broader and less technical treatment of the key topics discussed in The Elements of Statistical Learning. Each section also includes learning-lab lessons walking through the implementation of the statistical learning method from that chapter (Emil Hvitfeldt is also working on a companion site for completing the labs with tidymodels).\nTidy Modeling with R is a guide to using the tidymodel framework and has been an excellent reference in both personal and professional projects.\nText Mining with R: a Tidy Approach serves as an introduction to text mining and other methods for dealing with unstructured, non-rectangular data. In my current role as a Consumer Experience Analyst, I have to interact with unstructured data (in the form of patient comments) daily - this book, along with the tidytext package, have been incredibly useful for analyzing and visualizing text data.\nSupervised Machine Learning for Text Analysis in R picks up where Text Mining with R left off by exploring (as the title suggests) supervised machine learning methods with text data. While I haven’t done extensive text modeling, this is one area that I’d like to explore further in 2022.\nFeature Engineering and Selection: A Practical Approach for Predictive Models is a guidebook offering methods for feature engineering (transforming and creating new predictor variables to improve predictive model performance). While I’ve utilized some basic feature engineering in some of my work, I’m interested in adding more robust tools to my feature-engineering toolkit!\nIntroduction to Empirical Bayes is David Robinson’s book coalescing a series of blog posts on Bayesian estimation, credible intervals, A/B testing, mixed models, and a host of other methods, all through the example of baseball batting averages.\nBuild a Career in Data Science is, as the name suggests, a book about building a career in data science. I generally feel that most career-help books are too broad to be useful or offer non-novel information for those in the industry the book is written for. Given, however, that I don’t have an academic or professional background in the field and that I’d like to eventually move from analytics to data science, I’d like to add this to the collection to pick up on some best practices.\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {Technical {Books!}},\n  date = {2021-11-28},\n  url = {https://www.thedatadiary.net/posts/2021-11-28-technical-books},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “Technical Books!” November 28, 2021. https://www.thedatadiary.net/posts/2021-11-28-technical-books."
  },
  {
    "objectID": "posts/2021-12-14-do-voters-want-democrats-or-republicans-in-congress/index.html",
    "href": "posts/2021-12-14-do-voters-want-democrats-or-republicans-in-congress/index.html",
    "title": "Do Voters Want Democrats or Republicans in Congress?",
    "section": "",
    "text": "The 2022 midterms are still quite a ways away, however, in order to have a forecast ready in time, I need to start working on the model well in advance! One of the features I plan on using in the House Forecast is the generic congressional ballot average. Generic ballot polls ask respondents whether they intend to vote for either the Republican or Democratic candidate for the U.S. House of Representatives in their district. FiveThirtyEight provides a daily updating polling average, but in order to project beyond their current day’s average, I needed to build my own poll aggregator! Thankfully, they also are kind enough to provide the underlying polling data as well.\nIn this post, I’ll walk through the steps taken to build the generic ballot aggregator and explore the results.\n\nThe Gameplan\nFiveThirtyEight’s data only goes back for two election cycles, which doesn’t provide enough data to build a poll aggregator from scratch. However, because they also provide their historical trendline, I can build a poll aggregator that fits the polling results to their historical trend.\nIn addition to the topline result, each poll in FiveThirtyEight’s repository includes quite a bit of additional meta-information about the poll: the pollster, sample size, survey methodology, and recipient population. Some pollsters, methodologies, and populations tend to be more accurate than others, so I’d be remiss to not include these features in the polling model. To incorporate all of this information, each feature will be weighted according to how well it fits FiveThirtyEight’s historical average. I’m sweeping a lot of programmatic detail under the rug here, but in general, features that fit FiveThirtyEight’s trendline well will have a higher weight and features that don’t fit the trendline so well will have a lower weight. Finally, since we know that some pollsters tend to favor one party, we’ll also create a “pollster offset” feature to shift each poll slightly and account for this partisan lean.\nBefore digging any further, it may be beneficial to explore the polling repository a bit. Here’s a sample of the polling data used for the aggregator:\n\n\nCode\nlibrary(tidyverse)\nlibrary(riekelib)\nlibrary(lubridate)\n\nset.seed(123)\nread_csv(\"https://github.com/markjrieke/electiondata/raw/main/data/polls/src/fte/generic_ballot_polls_historical.csv\") %>%\n  mutate(end_date = as_date(end_date)) %>%\n  filter(end_date < ymd(\"2021-01-01\")) %>%\n  select(cycle, display_name, sample_size, population, methodology, end_date, dem, rep) %>%\n  slice_sample(n = 10) %>%\n  rename(pollster = display_name) %>%\n  knitr::kable()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncycle\npollster\nsample_size\npopulation\nmethodology\nend_date\ndem\nrep\n\n\n\n\n2018\nHarrisX\n3861\nlv\nOnline\n2011-02-18\n48.0\n42.0\n\n\n2018\nSurveyMonkey\n9532\na\nOnline\n2010-07-18\n43.0\n42.0\n\n\n2020\nYouGov\n1200\nrv\nOnline\n2012-03-19\n47.0\n41.0\n\n\n2018\nIpsos\n731\nlv\nOnline\n2009-06-18\n49.9\n38.6\n\n\n2020\nHarrisX\n3000\nrv\nOnline\n2010-07-19\n43.0\n36.0\n\n\n2018\nIpsos\n2383\na\nOnline\n2009-01-17\n36.8\n31.3\n\n\n2018\nIpsos\n663\nlv\nOnline\n2006-05-17\n38.7\n32.6\n\n\n2018\nMorning Consult\n1992\nrv\nOnline\n2005-05-18\n42.0\n35.0\n\n\n2018\nIpsos\n1689\nrv\nOnline\n2007-03-18\n41.4\n36.5\n\n\n2018\nIpsos\n1907\na\nOnline\n2004-02-18\n38.0\n30.3\n\n\n\n\n\nThe following pollsters conducted enough polls to warrant their own category - all other pollsters will be lumped together under the banner of “Other Pollster:”\n\n\nCode\nread_csv(\"https://github.com/markjrieke/electiondata/raw/main/data/polls/src/fte/generic_ballot_polls_historical.csv\") %>%\n  mutate(end_date = as_date(end_date)) %>%\n  select(display_name) %>%\n  rename(pollster = display_name) %>%\n  percent(pollster, .keep_n = TRUE) %>%\n  filter(pct > 0.01) %>%\n  arrange(desc(pct)) %>%\n  select(-pct) %>%\n  knitr::kable()\n\n\n\n\n\npollster\nn\n\n\n\n\nIpsos\n1239\n\n\nHarrisX\n426\n\n\nMorning Consult\n305\n\n\nYouGov\n195\n\n\nUSC Dornsife\n71\n\n\nThe Winston Group\n44\n\n\nMcLaughlin & Associates\n34\n\n\nFirehouse Strategies/Øptimus\n32\n\n\nRasmussen Reports/Pulse Opinion Research\n30\n\n\nQuinnipiac University\n28\n\n\n\n\n\nHere is a bit of expanded detail on the survey population categories:\n\n\nCode\nread_csv(\"https://github.com/markjrieke/electiondata/raw/main/data/polls/src/fte/generic_ballot_polls_historical.csv\") %>%\n  select(population) %>%\n  percent(population, .keep_n = TRUE) %>%\n  arrange(desc(pct)) %>%\n  select(-pct) %>%\n  bind_cols(tibble(population_full = c(\"Registered Voters\",\n                                       \"Likely Voters\",\n                                       \"Adults\", \n                                       \"Voters\"))) %>%\n  relocate(population_full, .after = population) %>%\n  knitr::kable()\n\n\n\n\n\npopulation\npopulation_full\nn\n\n\n\n\nrv\nRegistered Voters\n1510\n\n\nlv\nLikely Voters\n619\n\n\na\nAdults\n602\n\n\nv\nVoters\n2\n\n\n\n\n\nFinally, the top survey methodologies considered are shown below. Similar to pollsters, methodologies that are not used enough are lumped into an “Other Methodology” category:\n\n\nCode\nread_csv(\"https://github.com/markjrieke/electiondata/raw/main/data/polls/src/fte/generic_ballot_polls_historical.csv\") %>%\n  select(methodology) %>%\n  percent(methodology, .keep_n = TRUE) %>%\n  filter(pct > 0.01) %>%\n  mutate(methodology = replace_na(methodology, \"Unknown\")) %>%\n  arrange(desc(pct)) %>%\n  select(-pct) %>%\n  knitr::kable()\n\n\n\n\n\nmethodology\nn\n\n\n\n\nOnline\n2425\n\n\nLive Phone\n194\n\n\nUnknown\n62\n\n\nIVR/Online\n44\n\n\n\n\n\nThe general plan of attack was to fit the polls to the trendline, measure the error, update the weights and offsets slightly, and repeat until the error is below an acceptable threshold. As time progresses, we make smaller and smaller updates to the weights and offsets we hone in on optimal values for minimizing error.\n\n\nExploring the Results\nFirst and foremost, I’m pleased to report that the model fit the historical data fairly well. The model’s trendline (in blue) reasonably matches FiveThirtyEight’s historical trendline (in red):\n\nAs expected, as the model trains the weights and offsets, the rmse continues to shrink, and levels off just after 150 training rounds:\n\nSome pollsters are better at fitting the trendline: YouGov polls end up with the highest weight in the model whereas Morning Consult polls are downweighted.\n\nWhat are the partisan leanings of each pollster? Each pollster offset is shown below - pollsters at the top are generally more conservative leaning pollsters near the bottom are generally more liberal leaning. Or rather, pollsters near the top fit the trend better when we adjust their results to favor democrats, and pollsters near the bottom fit better when adjusted in favor of republicans.\n\nSome pollsters have fairly significant offsets! It’s reassuring to note, however, that these pollsters are downweighted and don’t make up the majority of polls recorded. The five pollsters with the most number of generic ballot polls conducted tend to fall fairly close to 0-offset.\n\nAlthough live phone polling has become more and more difficult in recent years, it still ended up being the top-weighted method for the generic ballot poll.\n\nFinally, surveying a population of registered voters turned out to be best for matching polls to the trendline, whereas the “voters” population was filtered away entirely (though that may be because there were only two polls conducted with this population).\n\n\n\nFitting to New 2022 Data\nThis exploration of how the model fits to the training data is useful, but how well does this model fit to new data? As it turns out, fairly well! When fit to data it wasn’t trained on, the model’s trendline (in blue) closely follows the target trendline (in red).\n\nThis also gives us the ability to project beyond the current average! As we get further and further away from the current day, our confidence interval around the current average widens out.\n\nThis behavior looks great! One area of concern, however, is the area on the left - on days where we already have data, we’re way too confident in our estimate! On some days, the confidence interval only spans 0.5%, which simply isn’t realistic.\nTo deal with this, we’ll create a new feature, downweight, that we can train to widen our confidence interval to something more credible.\n\n\nOne More Round of Training\nSimilar to training the generic ballot average, we can train the downweight feature to match the model’s confidence interval to FiveThirtyEight’s confidence interval. The trained result isn’t a perfect fit, but this does give us a mathematically sound, consistent way to construct a more realistic confidence interval. Here’s how the model’s confidence interval compares to the training set:\n\nOn new data, the model similarly provides an okay-enough fit for our purposes. The model may find it difficult to recreate FiveThirtyEight’s confidence interval due to differences in model construction. According to FiveThirtyEight’s documentation on other polling averages, it looks like they use an ensemble of LOESS models, whereas I generate a single beta distribution. Without getting too far into the weeds, the stack of LOESS models results in a confidence interval that is less prone to quick growth.\n\n\n\nWrapping It All Up\nNow that we’ve defined a model, we can finally answer the question in the title: do voters want Democrats or Republicans in congress? According to this model, voters are as even split as you can get!\n\nEven if there was a leader in the polls, the generic ballot’s predictive power this far out from the house elections is, to a first approximation, effectively useless. As we get closer to the election day, however, the polling model will become more and more useful. Additionally, the methods I used to generate the polling average can be replicated (with slight modifications) for other polling averages that will feed into the model, so stay tuned for more!\n\n\nSome Programming Notes\nI’ve skipped over quite a bit of programming detail. If you’re so inclined, you can read through the script to build the model and generate plots. There’s a lot going on there, but I’d like to highlight a few packages that were instrumental for putting this together:\n\ndoParallel: I frequently use doParallel, which uses multiple cores running in parallel to speed up processes. Most of the time, loading doParallel is just done for convenience’s sake, but it was absolutely necessary for this project — even with parallel processing, each round of model training was lengthy.\nfurrr: the goal of furrr is to combine purrr’s family of mapping functions with future’s parallel processing capabilities. Replacing my purrr::map() functions with furrr::future_map() functions literally cut training time in half.\nshadowtext: shadowtext is a small, niche package that allows you to add colored borders to geom_text() objects in a ggplot. It’s not visible in today’s chart because there’s 100% overlap between democrats & republicans, but there’s a white border around the text in front of the trendline that just looks nice.\n\n\n\n\n\nCitationBibTeX citation:@online{rieke2021,\n  author = {Mark Rieke},\n  title = {Do {Voters} {Want} {Democrats} or {Republicans} in\n    {Congress?}},\n  date = {2021-12-14},\n  url = {https://www.thedatadiary.net/posts/2021-12-14-do-voters-want-democrats-or-republicans-in-congress},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2021. “Do Voters Want Democrats or Republicans in\nCongress?” December 14, 2021. https://www.thedatadiary.net/posts/2021-12-14-do-voters-want-democrats-or-republicans-in-congress."
  },
  {
    "objectID": "posts/2022-01-12-the-data-diary-year-in-review/index.html",
    "href": "posts/2022-01-12-the-data-diary-year-in-review/index.html",
    "title": "The Data Diary: Year in Review",
    "section": "",
    "text": "In the year since I started this blog, there’s been a lot that’s happened: I learned to use R, picked up the basics of machine learning, and moved into a new job/industry. I spend a lot of time thinking about what’s coming down the pipeline and how much further I have to go on projects that I have planned, but it’s worthwhile every now and then to take a look back and see just how far I’ve come."
  },
  {
    "objectID": "posts/2022-01-12-the-data-diary-year-in-review/index.html#learning-r",
    "href": "posts/2022-01-12-the-data-diary-year-in-review/index.html#learning-r",
    "title": "The Data Diary: Year in Review",
    "section": "Learning R",
    "text": "Learning R\nA year ago, I couldn’t write a lick of R code — I lived and breathed Excel, and was a bit afraid of the transition from a GUI to an IDE. Now, I’d consider myself pretty well-versed in the language and am so glad I made the switch. Having moved to R, I realized how restrictive Excel was — R (or any other analytics-focused programming language) allows for the freedom of expression needed for any sort of serious analysis. This talk by Hadley Wickham was instrumental in pushing me to pick up R and is well worth a watch if you have the time."
  },
  {
    "objectID": "posts/2022-01-12-the-data-diary-year-in-review/index.html#completing-stanfords-machine-learning-course",
    "href": "posts/2022-01-12-the-data-diary-year-in-review/index.html#completing-stanfords-machine-learning-course",
    "title": "The Data Diary: Year in Review",
    "section": "Completing Stanford’s Machine Learning course",
    "text": "Completing Stanford’s Machine Learning course\nWhen I started learning R, I was most interested in getting to the point where I’d be able to implement machine learning models (this specifically came from reading the documentation for The Economist’s POTUS model and wanting to understand what was going on under-the-hood). Stanford’s online Machine Learning course was a thorough, technical introduction to the basics of machine learning. It doesn’t cover every model type, but gives a great foundation for how to understand new models by requiring that you write the models yourself (this was very useful and practical, but you won’t catch me using MATLAB anytime soon!)."
  },
  {
    "objectID": "posts/2022-01-12-the-data-diary-year-in-review/index.html#committing-to-ropensci",
    "href": "posts/2022-01-12-the-data-diary-year-in-review/index.html#committing-to-ropensci",
    "title": "The Data Diary: Year in Review",
    "section": "Committing to rOpenSci",
    "text": "Committing to rOpenSci\nrOpenSci is a non-profit initiative committed to creating and maintaining a variety of open-source R packages. For work, I use one of their packages, the qualtRics package, almost daily for extracting survey responses from Qualtrics’ API. I added a small function, fetch_id(), that allows you to pull in survey responses based on the survey’s name, rather than looking up the miscellaneous string of numbers that constitute the survey_id. It’s a small helper function, but working on it taught me a lot about documentation, testing, package development, and contributing to open-source software.\n\n\nCode\nlibrary(dplyr)\nlibrary(qualtRics)\n\nall_surveys() %>% \n  fetch_id(\"Mark's Example Survey\") %>%\n  fetch_survey() %>%\n  knitr::kable()\n\n\n\n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStartDate\nEndDate\nStatus\nIPAddress\nProgress\nDuration (in seconds)\nFinished\nRecordedDate\nResponseId\nRecipientLastName\nRecipientFirstName\nRecipientEmail\nExternalReference\nLocationLatitude\nLocationLongitude\nDistributionChannel\nUserLanguage\nQ1\n\n\n\n\n2022-01-12 09:20:31\n2022-01-12 09:20:38\nSurvey Preview\nNA\n100\n7\nTRUE\n2022-01-12 09:20:40\nR_XFVjzAh4MalrLmF\nNA\nNA\nNA\nNA\n29.73351\n-95.5564\npreview\nEN\nStrongly agree"
  },
  {
    "objectID": "posts/2022-01-12-the-data-diary-year-in-review/index.html#putting-together-a-developer-package",
    "href": "posts/2022-01-12-the-data-diary-year-in-review/index.html#putting-together-a-developer-package",
    "title": "The Data Diary: Year in Review",
    "section": "Putting together a developer package",
    "text": "Putting together a developer package\nAt some point this past year, I found myself either re-writing the same chunks of code repeatedly or re-defining functions across every project. After a lengthy period of hesitation, I finally picked up the R Packages book by Hadley Wickham and Jenny Bryan and put together my own personal package, {riekelib}. It’s just a collection of small helper functions that I use regularly for both personal and professional projects, but it’s really helped speed up workflows, since I can just load the library rather than re-write code or functions! Here are a few examples:\n\n\nCode\nlibrary(riekelib)\n\n# beta_interval() gives lower & upper bounds of a beta distribution's confidence interval \ntibble::tibble(alpha = c(85, 100),\n               beta = c(15, 500)) %>%\n  beta_interval(alpha, beta) %>%\n  knitr::kable()\n\n\n\n\n\nalpha\nbeta\nci_lower\nci_upper\n\n\n\n\n85\n15\n0.7741265\n0.9126452\n\n\n100\n500\n0.1379480\n0.1974895\n\n\n\n\n\nCode\n# percent() returns the percentage each value or combination of values appear in a tibble\niris %>%\n  tibble::as_tibble() %>%\n  percent(Species) %>%\n  knitr::kable()\n\n\n\n\n\nSpecies\npct\n\n\n\n\nsetosa\n0.3333333\n\n\nversicolor\n0.3333333\n\n\nvirginica\n0.3333333"
  },
  {
    "objectID": "posts/2022-01-12-the-data-diary-year-in-review/index.html#baby-steps",
    "href": "posts/2022-01-12-the-data-diary-year-in-review/index.html#baby-steps",
    "title": "The Data Diary: Year in Review",
    "section": "Baby Steps",
    "text": "Baby Steps\nThe first plot I ever created in R, made with base R’s plot() function, compares speed & distance from the cars dataset. There’s not really anything visually compelling here, but it gives the starting point."
  },
  {
    "objectID": "posts/2022-01-12-the-data-diary-year-in-review/index.html#r-ggplot2-and-plotly",
    "href": "posts/2022-01-12-the-data-diary-year-in-review/index.html#r-ggplot2-and-plotly",
    "title": "The Data Diary: Year in Review",
    "section": "R, ggplot2, and plotly",
    "text": "R, ggplot2, and plotly\nThis next plot shows my first attempt at creating a ggplot. I remember struggling a lot with this when trying to learn the ins and outs of putting together and formatting the plot, but that struggle was well worth it. I learned not only the basics of how to put together a plot with ggplot, but also, more importantly, how to search and troubleshoot issues. I also like that I was able to explore a topic visually with this plot: while the winner of the presidential election overperforms in the electoral college relative to the popular vote, republican candidates consistently have a slightly stronger electoral college overperformance due to small-state bias."
  },
  {
    "objectID": "posts/2022-01-12-the-data-diary-year-in-review/index.html#kind-of-projecting-the-2020-election",
    "href": "posts/2022-01-12-the-data-diary-year-in-review/index.html#kind-of-projecting-the-2020-election",
    "title": "The Data Diary: Year in Review",
    "section": "(Kind of) Projecting the 2020 Election",
    "text": "(Kind of) Projecting the 2020 Election\nI started playing around with custom themes, and even setup my own theme elements so that I could reference them easily. This was the first time I broke away from the default theme for ggplot. Additionally, this was the first time I used any sort of statistical methods to make a projection. The projection itself is pretty bad/underconfident, but the methodology was sound."
  },
  {
    "objectID": "posts/2022-01-12-the-data-diary-year-in-review/index.html#doug-collins-saved-raphael-warnocks-senate-bid",
    "href": "posts/2022-01-12-the-data-diary-year-in-review/index.html#doug-collins-saved-raphael-warnocks-senate-bid",
    "title": "The Data Diary: Year in Review",
    "section": "Doug Collins Saved Raphael Warnock’s Senate Bid",
    "text": "Doug Collins Saved Raphael Warnock’s Senate Bid\nOf all the posts I wrote in 2021, this may be the one I’m most proud of. Firstly, I learned a lot of new techniques needed to create maps and animations in R, but I also made a data-backed point: Raphael Warnock, one of the current Democratic senators from Georgia, likely won his election because Republican voters split their ticket between Kelly Loeffler and Doug Collins."
  },
  {
    "objectID": "posts/2022-01-12-the-data-diary-year-in-review/index.html#artwork",
    "href": "posts/2022-01-12-the-data-diary-year-in-review/index.html#artwork",
    "title": "The Data Diary: Year in Review",
    "section": "aRtwork!",
    "text": "aRtwork!\nThis next one is just fun, but I used R to make some artwork! I liked it so much, that I ended up making this my site header."
  },
  {
    "objectID": "posts/2022-01-12-the-data-diary-year-in-review/index.html#tidymodels-and-the-titanic",
    "href": "posts/2022-01-12-the-data-diary-year-in-review/index.html#tidymodels-and-the-titanic",
    "title": "The Data Diary: Year in Review",
    "section": "Tidymodels and the Titanic",
    "text": "Tidymodels and the Titanic\nI spent a lot of time this past year learning how to implement machine learning methods, but eventually got to the point where I feel confident building and troubleshooting models with the tidymodel framework. I had an “aha” moment when working on a classifier for everyone’s favorite dataset, the Titanic survival dataset, and everything finally clicked. The model wasn’t great, but being able to quickly build and iterate was game-changing."
  },
  {
    "objectID": "posts/2022-01-12-the-data-diary-year-in-review/index.html#diamonds-are-forever-feature-engineering-with-the-diamonds-dataset",
    "href": "posts/2022-01-12-the-data-diary-year-in-review/index.html#diamonds-are-forever-feature-engineering-with-the-diamonds-dataset",
    "title": "The Data Diary: Year in Review",
    "section": "Diamonds are Forever: Feature Engineering with the Diamonds Dataset",
    "text": "Diamonds are Forever: Feature Engineering with the Diamonds Dataset\nWith some machine learning under my belt, I spent some time practicing feature engineering with the diamonds dataset. From the variable importance plot, I found that some of the engineered features were among the most important for predicting a diamond’s price!"
  },
  {
    "objectID": "posts/2022-01-12-the-data-diary-year-in-review/index.html#do-voters-want-democrats-or-republicans-in-congress",
    "href": "posts/2022-01-12-the-data-diary-year-in-review/index.html#do-voters-want-democrats-or-republicans-in-congress",
    "title": "The Data Diary: Year in Review",
    "section": "Do Voters Want Democrats or Republicans in Congress?",
    "text": "Do Voters Want Democrats or Republicans in Congress?\nMost recently, I created a congressional ballot aggregator that weights polls by pollster, recency, sample size, and methodology. This was a huge effort to create a custom regression methodology, and I’m very happy with how it turned out! As of today, voters are just about even-split between Democrats and Republicans in the upcoming 2022 midterms."
  },
  {
    "objectID": "posts/2022-01-26-how-popular-is-joe-biden/index.html",
    "href": "posts/2022-01-26-how-popular-is-joe-biden/index.html",
    "title": "How Popular is Joe Biden?",
    "section": "",
    "text": "While the sitting president’s party tends to House lose seats in the midterm elections, the president’s approval rating can help inform us of the magnitude of that loss. In general, the more unpopular the president, the more seats his party tends to lose. As a part of my long-term goal of building a midterm election model, I put together a model for estimating Biden’s approval, disapproval, and net approval based on polls collected by FiveThirtyEight.\nThe methodology to build the approval model is very similar to the Generic Congressional Ballot model — both weight polls by recency, sample size, methodology, pollster, and survey population — so I won’t rehash the details again. If you’re so inclined, you can read the methodology from the previous post or explore the script, but we’ll keep this short and sweet and just explore the results!\n\n\nAs of today, Joe Biden’s job approval is fairly underwater — and history says it’s unlikely to improve as the midterms approach. Interestingly, the generic congressional ballot still shows that the country is about even-split on who they’d like to see in congress. As with the president’s approval, however, historical precedent implies a continuous slide away from the president’s party.\n\nDespite this precedent, politics today are far more polarized than previous midterm cycles, and modeling that adjusts for this partisanship may imply a lesser midterm shellacking than history would otherwise suggest. While Biden would certainly prefer for his approval to be higher, it may not necessarily spell doom for democrats in the midterms (though, to be sure, the strong prior still that they will lose ground this cycle — the question now is how much).\n\n\n\nCitationBibTeX citation:@online{rieke2022,\n  author = {Mark Rieke},\n  title = {How {Popular} Is {Joe} {Biden?}},\n  date = {2022-01-26},\n  url = {https://www.thedatadiary.net/posts/2022-01-26-how-popular-is-joe-biden},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2022. “How Popular Is Joe Biden?” January 26,\n2022. https://www.thedatadiary.net/posts/2022-01-26-how-popular-is-joe-biden."
  },
  {
    "objectID": "posts/2022-02-08-pull-yourself-up-by-your-bootstraps/index.html",
    "href": "posts/2022-02-08-pull-yourself-up-by-your-bootstraps/index.html",
    "title": "Pull Yourself Up by Your Bootstraps",
    "section": "",
    "text": "Code\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(MetBrewer)\n\nextrafont::loadfonts(device = \"win\")\n\ntheme_set(theme_minimal(base_family = \"Roboto Slab\") +\n            theme(plot.background = element_rect(fill = \"white\", color = \"white\")))\n\n\n\nNote (3/14/22): This article was written prior to the release of the {workboots} package. Since the release of that package, I’ve discovered some errors with the methodology described here and would recommend instead referencing the post associated with the release.\n\nStatistical modeling sometimes presents conflicting goals. Oftentimes, building a model involves a mix of objectives that don’t necessarily mesh well together: super-accurate point predictions, explainability, fast performance, or an expression of confidence in the prediction. In my work as an analyst, I generally am focused on how explainable the model is while being able to express a confidence interval around each prediction. For that, simple linear models do the trick. If, however, I want to regularize via {glmnet} (which — with good reason — doesn’t provide confidence intervals) or use a non-linear model like {xgboost}, I have to drop the confidence interval around predictions. Or so I had previously thought! As it turns out, building a series of models from bootstrap resamples provides an alternative method of generating a confidence interval around a prediction.\n\nSetting a baseline with penguins\nFirst, let’s build out a baseline linear model with the Palmer Penguins dataset. This dataset contains information on 344 penguins across three species types and three islands. For this example, we’ll use the penguin information to predict body_mass_g.\n\n\nCode\n# load the data in from the tidytuesdayR package\npenguins_src <- tidytuesdayR::tt_load(2020, week = 31)\n\n\n\n    Downloading file 1 of 2: `penguins.csv`\n    Downloading file 2 of 2: `penguins_raw.csv`\n\n\nCode\n# extract out the penguins dataset\npenguins <- penguins_src$penguins\nrm(penguins_src)\n\npenguins\n\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n   <chr>   <chr>              <dbl>         <dbl>      <dbl>   <dbl> <chr> <dbl>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema…  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema…  2007\n 4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n 5 Adelie  Torgersen           36.7          19.3        193    3450 fema…  2007\n 6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 7 Adelie  Torgersen           38.9          17.8        181    3625 fema…  2007\n 8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n# … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n\n\nWe’ll need to do some lite preprocessing before we start modeling — it looks like there are some NAs in body_mass_g and in sex. If I were creating a more serious model, I might keep the rows with NAs for sex, but since there are so few and this is an explainer, I’ll just filter them out.\n\n\nCode\n# remove NA from body_mass_g and sex\npenguins <- \n  penguins %>%\n  filter(!is.na(body_mass_g),\n         !is.na(sex))\n\npenguins\n\n\n# A tibble: 333 × 8\n   species island    bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n   <chr>   <chr>              <dbl>         <dbl>      <dbl>   <dbl> <chr> <dbl>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema…  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema…  2007\n 4 Adelie  Torgersen           36.7          19.3        193    3450 fema…  2007\n 5 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 6 Adelie  Torgersen           38.9          17.8        181    3625 fema…  2007\n 7 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 8 Adelie  Torgersen           41.1          17.6        182    3200 fema…  2007\n 9 Adelie  Torgersen           38.6          21.2        191    3800 male   2007\n10 Adelie  Torgersen           34.6          21.1        198    4400 male   2007\n# … with 323 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n\n\nIt’s always good practice to explore the dataset prior to fitting a model, so let’s jump into some good ol’ fashioned EDA.\n\n\nCode\n# how are species/island related to body mass?\npenguins %>%\n  ggplot(aes(x = species,\n             y = body_mass_g,\n             color = species)) +\n  geom_boxplot() +\n  geom_point(alpha = 0.25,\n             position = position_jitter()) +\n  facet_wrap(~island)\n\n\n\nInteresting! It looks like the Gentoo and Chinstrap species are only found on the Biscoe and Dream islands, respectively, whereas the Adelie species can be found on all three islands. At first glance, there’s not a meaningful difference that Island has on the weight of the Adelie penguins, so I think we’re safe to toss out the island feature and just keep species.\n\n\nCode\n# how does sex relate to body mass?\npenguins %>%\n  ggplot(aes(x = sex,\n             y = body_mass_g,\n             color = sex)) +\n  geom_boxplot() +\n  geom_point(alpha = 0.25,\n             position = position_jitter())\n\n\n\nUnsurprisingly, male penguins are typically heavier than female penguins.\n\n\nCode\n# are penguins getting heavier or lighter as years progress?\npenguins %>%\n  mutate(year = as.character(year)) %>%\n  ggplot(aes(x = year,\n             y = body_mass_g)) +\n  geom_boxplot() +\n  geom_point(alpha = 0.25,\n             position = position_jitter())\n\n\n\nIt doesn’t look like there is significant signal being drawn from year, so we’ll toss that out as well.\n\n\nCode\n# how do other body measurements compare with the total body mass?\npenguins %>%\n  select(bill_length_mm:body_mass_g) %>%\n  pivot_longer(ends_with(\"mm\"),\n               names_to = \"measurement\",\n               values_to = \"value\") %>%\n  ggplot(aes(x = value,\n             y = body_mass_g,\n             color = measurement)) +\n  geom_point(alpha = 0.5) + \n  facet_wrap(~measurement, scales = \"free_x\") +\n  geom_smooth(method = \"lm\",\n              se = FALSE)\n\n\n\nFor bill and flipper length, there’s a pretty clear relationship, but it looks like bill depth has a classic case of Simpson’s paradox. Let’s explore that further to find a meaningful interaction to apply.\n\n\nCode\n# which feature interacts with bill depth to produce simpson's pardox?\npenguins %>%\n  ggplot(aes(x = bill_depth_mm,\n             y = body_mass_g,\n             color = species)) +\n  geom_point(alpha = 0.5) +\n  geom_smooth(method = \"lm\",\n              se = FALSE)\n\n\n\nSo, very clearly, the Gentoo species has a very different relationship between bill depth and body mass than the Adelie/Chinstrap species. We’ll add this as an interactive feature to the model.\nWith all that completed, let’s (finally) setup and build the baseline linear model with confidence intervals around the prediction!\n\n\nCode\n# remove features\npenguins <- \n  penguins %>%\n  select(-island, -year)\n\n# split into testing and training datasets\nset.seed(123)\npenguins_split <- initial_split(penguins)\npenguins_test <- testing(penguins_split)\npenguins_train <- training(penguins_split)\n\n# setup a pre-processing recipe\npenguins_rec <- \n  recipe(body_mass_g ~ ., data = penguins_train) %>%\n  step_dummy(all_nominal()) %>% \n  step_interact(~starts_with(\"species\"):bill_depth_mm)\n\n# fit a workflow\npenguins_lm <- \n  workflow() %>%\n  add_recipe(penguins_rec) %>%\n  add_model(linear_reg() %>% set_engine(\"lm\")) %>%\n  fit(penguins_train)\n\n\n\n\nCode\n# predict on training data with confidence intervals\nbind_cols(penguins_lm %>% predict(penguins_train),\n          penguins_lm %>% predict(penguins_train, type = \"conf_int\", level = 0.95),\n          penguins_train) %>%\n  ggplot(aes(x = body_mass_g,\n             y = .pred)) +\n  geom_point(alpha = 0.5) +\n  geom_segment(aes(x = body_mass_g,\n                   xend = body_mass_g,\n                   y = .pred_lower,\n                   yend = .pred_upper),\n               alpha = 0.25) +\n  labs(title = \"Predicting the Palmer Penguins - Training\",\n       subtitle = \"Linear model predicting a penguin's weight in grams\",\n       x = \"Actual weight (g)\",\n       y = \"Predicted weight (g)\",\n       caption = \"Errorbars represent the a 95% confidence interval\") +\n  theme(plot.title.position = \"plot\")\n\n\n\nThis model does generally okay, but the confidence interval around each prediction is pretty clearly too confident! Let’s solve this with bootstrapping.\n\n\nWhat’s a bootstrap?\nBefore progressing any further, it’s probably important to define what exactly a bootstrap is/what bootstrapping is. Bootstrapping is a resampling method that lets us take one dataset and turn it into many datasets. Bootstrapping accomplishes this by repeatedly pulling a random row from the source dataset and, importantly, bootstrapping allows for rows to be repeated! Let’s look at an example for a bit more clarity.\n\n\n\n\n\nrowid\nx1\nx2\n\n\n\n\n1\n0.8\n104\n\n\n2\n0.7\n102\n\n\n3\n0.9\n88\n\n\n4\n0.4\n124\n\n\n5\n0.3\n79\n\n\n\n\n\nLet’s say we want to make bootstrap resamples of this dataset. We’ll draw five random rows from the dataset and, sometimes, we’ll have the same row show up in our new bootstrapped dataset multiple times:\n\n\n\n\n\nrowid\nx1\nx2\n\n\n\n\n1\n0.8\n104\n\n\n3\n0.9\n88\n\n\n4\n0.4\n124\n\n\n4\n0.4\n124\n\n\n2\n0.7\n102\n\n\n\n\n\nAnother bootstrap dataset might look like this:\n\n\n\n\n\nrowid\nx1\nx2\n\n\n\n\n2\n0.7\n102\n\n\n3\n0.9\n88\n\n\n5\n0.3\n79\n\n\n3\n0.9\n88\n\n\n5\n0.3\n79\n\n\n\n\n\nBootstrap datasets allow us to create many datasets from the original dataset and evaluate models across these bootstraps. Models that are well informed will give similar outputs across each dataset, despite of the randomness within each dataset, whereas less confident models will have a wider variation across the bootstrapped datasets.\n\n\nGenerating some confident penguins\nLet’s say we want to use {xgboost} to predict penguin weight and we’ll use bootstrapping to generate a confidence interval. Firstly, we’ll create the bootstrap datasets from our training set.\n\n\nCode\npenguins_boot <- penguins_train %>% bootstraps()\n\npenguins_boot\n\n\n# Bootstrap sampling \n# A tibble: 25 × 2\n   splits           id         \n   <list>           <chr>      \n 1 <split [249/92]> Bootstrap01\n 2 <split [249/90]> Bootstrap02\n 3 <split [249/91]> Bootstrap03\n 4 <split [249/87]> Bootstrap04\n 5 <split [249/98]> Bootstrap05\n 6 <split [249/84]> Bootstrap06\n 7 <split [249/91]> Bootstrap07\n 8 <split [249/95]> Bootstrap08\n 9 <split [249/94]> Bootstrap09\n10 <split [249/86]> Bootstrap10\n# … with 15 more rows\n\n\nBy default, the bootstraps() function will create 25 bootstrap datasets, but we could theoretically create as many as we want. Now that we have our bootstraps, let’s create a function that will fit a model to each of the bootstraps and save to disk. We’ll use the default parameters for our {xgboost} model.\n\n\nCode\n# define a basic xgboost model\npenguins_xgb <-\n  boost_tree() %>%\n  set_mode(\"regression\") %>%\n  set_engine(\"xgboost\")\n\n# function that will fit a model and save to a folder\nfit_bootstrap <- function(index) {\n  \n  # pull out individual bootstrap to fit\n  xgb_boot <- penguins_boot$splits[[index]] %>% training()\n  \n  # fit to a workflow\n  workflow() %>%\n    add_recipe(penguins_rec) %>%\n    add_model(penguins_xgb) %>%\n    fit(xgb_boot) %>%\n    write_rds(paste0(\"models/model_\", index, \".rds\"))\n  \n}\n\n\nThis function will create a new model for each bootstrap, so we’ll end up with 25 separate models. Let’s fit!\n\n\nCode\n# fit to 25 bootstrapped datasets\nfor (i in 1:25) {\n  \n  fit_bootstrap(i)\n  \n}\n\n\nNow let’s define a function that will predict based on these 25 bootstrapped models, then predict on our training data.\n\n\nCode\npredict_bootstrap <- function(new_data, index){\n  \n  read_rds(paste0(\"models/model_\", index, \".rds\")) %>%\n    predict(new_data) %>%\n    rename(!!sym(paste0(\"pred_\", index)) := .pred)\n  \n}\n\n# predict!\ntraining_preds <- \n  seq(1, 25) %>%\n  map_dfc(~predict_bootstrap(penguins_train, .x))\n\ntraining_preds\n\n\n# A tibble: 249 × 25\n   pred_1 pred_2 pred_3 pred_4 pred_5 pred_6 pred_7 pred_8 pred_9 pred_10\n    <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>   <dbl>\n 1  5552.  5638.  5555.  5703.  5726.  5783.  5404.  5566.  5493.   5547.\n 2  3470.  3340.  3334.  3350.  3311.  3303.  3315.  3421.  3692.   3436.\n 3  5309.  5274.  5241.  5286.  5206.  5084.  5506.  5531.  5274.   5309.\n 4  4160.  4013.  3988.  4111.  4075.  4073.  4284.  4050.  4033.   4033.\n 5  4003.  3931.  4096.  3968.  4008.  3918.  3941.  4093.  3941.   3880.\n 6  3967.  4039.  4095.  4047.  4021.  4055.  3980.  4115.  4067.   4084.\n 7  4647.  4551.  4750.  4555.  4690.  4396.  4235.  4686.  4764.   4659.\n 8  5240.  5288.  5291.  5276.  5308.  5508.  5570.  5375.  5340.   5268.\n 9  4138.  4111.  4106.  4236.  4135.  4219.  4218.  4211.  4160.   4071.\n10  4728.  4723.  4715.  4823.  4765.  4727.  4836.  4777.  4765.   4633.\n# … with 239 more rows, and 15 more variables: pred_11 <dbl>, pred_12 <dbl>,\n#   pred_13 <dbl>, pred_14 <dbl>, pred_15 <dbl>, pred_16 <dbl>, pred_17 <dbl>,\n#   pred_18 <dbl>, pred_19 <dbl>, pred_20 <dbl>, pred_21 <dbl>, pred_22 <dbl>,\n#   pred_23 <dbl>, pred_24 <dbl>, pred_25 <dbl>\n\n\nNow we have a column of predictions for each model — we can summarise our point prediction for each row with the average across all models and set the confidence interval based on the standard deviation of the predictions.\n\n\nCode\ntraining_preds %>%\n  bind_cols(penguins_train) %>%\n  rowid_to_column() %>%\n  pivot_longer(starts_with(\"pred_\"),\n               names_to = \"model\",\n               values_to = \".pred\") %>%\n  group_by(rowid) %>%\n  summarise(body_mass_g = max(body_mass_g),\n            .pred_mean = mean(.pred),\n            std_dev = sd(.pred)) %>%\n  riekelib::normal_interval(.pred_mean, std_dev) %>%\n  ggplot(aes(x = body_mass_g,\n             y = .pred_mean)) +\n  geom_point(alpha = 0.5) +\n  geom_segment(aes(x = body_mass_g, \n                   xend = body_mass_g,\n                   y = ci_lower,\n                   yend = ci_upper),\n               alpha = 0.25) +\n  labs(title = \"Predicting the Palmer Penguins - Training\",\n       subtitle = \"XGBoost model predicting a penguin's weight in grams\",\n       x = \"Actual weight (g)\",\n       y = \"Predicted weight (g)\",\n       caption = \"Errorbars represent the a 95% confidence interval\") +\n  theme(plot.title.position = \"plot\")\n\n\n\nAnd just like that, we’ve trained a series of models with {xgboost} that let us apply a confidence interval around a point prediction! Now that we’ve done so on the training set, let’s look at performance on the test set.\n\n\nCode\nseq(1, 25) %>%\n  map_dfc(~predict_bootstrap(penguins_test, .x)) %>%\n  bind_cols(penguins_test) %>%\n  rowid_to_column() %>%\n  pivot_longer(starts_with(\"pred_\"),\n               names_to = \"model\",\n               values_to = \".pred\") %>%\n  group_by(rowid) %>%\n  summarise(body_mass_g = max(body_mass_g),\n            .pred_mean = mean(.pred),\n            std_dev = sd(.pred)) %>%\n  riekelib::normal_interval(.pred_mean, std_dev) %>%\n  ggplot(aes(x = body_mass_g,\n             y = .pred_mean)) +\n  geom_point(alpha = 0.5) +\n  geom_segment(aes(x = body_mass_g, \n                   xend = body_mass_g,\n                   y = ci_lower,\n                   yend = ci_upper),\n               alpha = 0.25) +\n  labs(title = \"Predicting the Palmer Penguins - Testing\",\n       subtitle = \"XGBoost model predicting a penguin's weight in grams\",\n       x = \"Actual weight (g)\",\n       y = \"Predicted weight (g)\",\n       caption = \"Errorbars represent the a 95% confidence interval\") +\n  theme(plot.title.position = \"plot\")\n\n\n\nThe performance on the test data is slightly less accurate than on the training data, but that is to be expected. Importantly, we’ve used bootstrap resampling to generate a confidence interval from a model that otherwise normally returns a simple point prediction.\n\n\nSome noteworthy caveats\nThe prediction interval above is all well and good, but it comes with some hefty caveats. Firstly, the confidence interval in the Testing plot is generated from the mean and standard deviation from each prediction. This assumes that the predictions are distributed normally, which may not necessarily be the case.\n\n\nCode\ntraining_preds %>%\n  slice_head(n = 1) %>%\n  pivot_longer(starts_with(\"pred\")) %>%\n  ggplot(aes(x = value)) +\n  geom_density()\n\n\n\nThis density plot for one of the predictions shows that there’s definitely some non-normal behavior! There’s a few ways of addressing this.\n\nCreate many, many, more bootstraps and models so that the prediction distribution approaches normality (with only 25 points, we really shouldn’t even expect normality from this example).\nReport out the actual values of the percentiles in the distribution (e.g., the 2.5% percentile is below X, 97.5% is above Y, and the mean is at Z).\nReport out the actual distribution as the result.\n\nIdeally, you should do all three.\nThe second major caveat is that this is not one model, but a whole host of models and these take up a large amount of disk space. In this example, our 25 models take up 25 times more space than our original model and it takes some time to read in, fit, and wrangle the results. We can trade disk space for computation time by writing a function that fits and predicts without saving a model, but again, that’s a tradeoff between speed and space. For linear models, it may be a better route to have STAN simulate thousands of results via {rstanarm} or {brms}, but for non-linear models, boostrapping is the best way to go for now!\n\n\nPolling Bites\nCurrently, the Generic Ballot is holding steady with a slight sliver more Americans wanting Republicans in Congress than Democrats (50.7% to 49.3%, respectively). Joe Biden’s net approval continues to slide, currently sitting at -11.4% (41.8% approve, 53.1% disapprove).\n\n\n\n\n\n\n\nCitationBibTeX citation:@online{rieke2022,\n  author = {Mark Rieke},\n  title = {Pull {Yourself} {Up} by {Your} {Bootstraps}},\n  date = {2022-02-08},\n  url = {https://www.thedatadiary.net/posts/2022-02-08-pull-yourself-up-by-your-bootstraps},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2022. “Pull Yourself Up by Your Bootstraps.”\nFebruary 8, 2022. https://www.thedatadiary.net/posts/2022-02-08-pull-yourself-up-by-your-bootstraps."
  },
  {
    "objectID": "posts/2022-02-22-the-data-science-hierarchy-of-needs/index.html",
    "href": "posts/2022-02-22-the-data-science-hierarchy-of-needs/index.html",
    "title": "The Data Science Hierarchy of Needs",
    "section": "",
    "text": "I’ve never built a house (shocking, I know), but from far too much time spent watching HGTV, I understand the basic gist of it. You lay a foundation, setup framing and walls, route mechanical and electrical, then work on final touches like painting and decorating (to be sure, I’m hand-waiving a lot of detail away here). There’s a bit of wiggle room in the order you go about things — you can paint the living room walls before the ones in the bathroom or vice versa — but some steps definitely need to happen before others — you can’t paint either rooms until the walls themselves are actually up!\nThe same logic applies for data science — there are certain activities that are exceptionally hard to do without the proper infrastructure in place. Sometimes, we’re asked to chase after ~shiny objects~ without the support system to do so, when doing so may actually make our job more difficult in the future!\nI recently stumbled across an article that summarized this really succinctly with the following graphic: The Data Science Hierarchy of Needs.\n\n\nCollect\nAt a baseline, to do any sort of data work you need to actually have data on hand to work with! Whether there’s a formal process for collecting data or you need to gather data from disparate public sources, getting raw data out of the wild and into your system is the first step to being able to do any sort of analysis. In my case, as an analyst with a hospital’s patient satisfaction group, we need to actually send patients surveys.\n\n\nMove/Store\nOnce you know where your data is coming from, setting up a reliable data flow from the source to your environment is needed. This is where a lot of headache can come from. Gathering data can be difficult but if the data is going to be used once for a one-off analysis, you don’t need to worry too much about repeatability, edge cases, or computing speed. Once you need to gather new data, thinking about infrastructure around new data gathering becomes much more important. A good chunk of the last eight months of my job has been working with our new survey vendor on this piece of the puzzle: standardizing data layouts, catching bugs in the pipeline, and setting up standards for access.\n\n\nExplore/Transform\nWith a reliable flow of new/updated data streaming in, you now need to make sure the data is appropriate for general use. Automated anomaly/fraud/bot detection, light wrangling, and removing errant responses can all be considered a part of this single stage. This is necessary to ensure that any analyses you do or models you build are based on what you expect from the underlying data.\n\n\nAggregate/Label\nI can’t recall the source, but the following quote about data science has stuck with me: “99% of data science work is counting — sometimes dividing.” A significant portion of my day-to-day work involves the tried-and-trusted group_by() %>% summarise() pipeline. Making counts, percentages, running totals, etc. accessible to stakeholders via a dashboard can likely answer ~80% of the questions an analyst would have to field otherwise. It’s so, so important, however, to have the collection, storage, and preparation stages setup prior to ensure that stakeholders can trust that the data they’re seeing is accurate.\n\n\nLearn/Optimize\nIf 80% of questions asked can be solved with grouped summaries and 20% require a model, it’s likely that 80% of that remaining 20% can be solved by a simple linear model. For example, “What effect does patient age have on their overall satisfaction?” can be answered with lm(satisfaction_score ~ age). As relationships become more complex, you can add more terms to the model, or switch model architectures, but — in my own experience — the majority of modeling in practice can be represented by linear models (and, by extension, regularized models via {glmnet}).\n\n\nComplex Models\nFinally, a small subset of problems may require a more complex or powerful model type. But before you spin your wheels building a neural net or some other wacky architecture, you should first check if something simpler gets you what you need.\n\n\nSome Closing Thoughts\nThis post is partially meant to be able to share some useful info and partially a reminder to me to look for the simple solution! I have a tendency to start off with something complex then realize that I could save a lot of work if I just switch to something simpler. The three baseline layers upstream of my domain are super important and definitely need oversight from someone with an eye for data engineering.\n\n\nPolling Bites\nThe generic congressional ballot is starting to show some movement away from even split as Republicans have slowly climbed to 51.2% in the polls and Democrats have fallen to 48.8%.\n\nBiden’s net approval hasn’t shifted significantly since the last post — currently sitting at 10.9% underwater with 41.8% approval and 52.7% disapproval.\n\n\n(p.s., I’ve updated the color palettes here with the {MetBrewer} package, which provides colorblind friendly palettes based on artwork in hte Metropolitan Museum of Art in New York).\n\n\n\n\nCitationBibTeX citation:@online{rieke2022,\n  author = {Mark Rieke},\n  title = {The {Data} {Science} {Hierarchy} of {Needs}},\n  date = {2022-02-22},\n  url = {https://www.thedatadiary.net/posts/2022-02-22-the-data-science-hierarchy-of-needs},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2022. “The Data Science Hierarchy of Needs.”\nFebruary 22, 2022. https://www.thedatadiary.net/posts/2022-02-22-the-data-science-hierarchy-of-needs."
  },
  {
    "objectID": "posts/2022-03-14-introducing-workboots/index.html",
    "href": "posts/2022-03-14-introducing-workboots/index.html",
    "title": "Introducing {workboots}",
    "section": "",
    "text": "Code\n# setup themes\nextrafont::loadfonts(device = \"win\")\nggplot2::theme_set(\n  ggplot2::theme_minimal(base_family = \"Roboto Slab\", \n                         base_size = 14) +\n    ggplot2::theme(plot.title.position = \"plot\",\n                   plot.background = ggplot2::element_rect(fill = \"white\", color = \"white\"))\n)\nSometimes, we want a model that generates a range of possible outcomes around each prediction and may opt for a model that can generate a prediction interval, like a linear model. Other times, we just care about point predictions and may opt to use a more powerful model like XGBoost. But what if we want the best of both worlds: getting a range of predictions while still using a powerful model? That’s where {workboots} comes to the rescue! {workboots} uses bootstrap resampling to train many models which can be used to generate a range of outcomes — regardless of model type."
  },
  {
    "objectID": "posts/2022-03-14-introducing-workboots/index.html#estimating-a-prediction-interval",
    "href": "posts/2022-03-14-introducing-workboots/index.html#estimating-a-prediction-interval",
    "title": "Introducing {workboots}",
    "section": "Estimating a prediction interval",
    "text": "Estimating a prediction interval\nLet’s get started with a model we know can generate a prediction interval: a basic linear model. In this example, we’ll use the Ames housing dataset to predict a home’s price based on its square footage.\n\n\nCode\nlibrary(tidymodels)\n\n# setup our data\ndata(\"ames\")\names_mod <- ames %>% select(First_Flr_SF, Sale_Price)\n\n\n\n\nCode\n# relationship between square footage and price\names_mod %>%\n  ggplot(aes(x = First_Flr_SF, y = Sale_Price)) +\n  geom_point(alpha = 0.25) +\n  scale_y_continuous(labels = scales::dollar_format(), trans = \"log10\") +\n  scale_x_continuous(labels = scales::comma_format(), trans = \"log10\") +\n  labs(title = \"Relationship between Square Feet and Sale Price\",\n       subtitle = \"Linear relationship between the log transforms of square footage and price\",\n       x = NULL,\n       y = NULL)\n\n\n\nWe can use a linear model to predict the log transform of Sale_Price based on the log transform of First_Flr_SF. In this example, we’ll train a linear model then plot our predictions against a holdout set with a prediction interval.\n\n\nCode\n# log transform\names_mod <- \n  ames_mod %>%\n  mutate(across(everything(), log10))\n\n# split into train/test data\nset.seed(918)\names_split <- initial_split(ames_mod)\names_train <- training(ames_split)\names_test <- testing(ames_split)\n\n\n\n\nCode\n# train a linear model\nset.seed(314)\nmod <- lm(Sale_Price ~ First_Flr_SF, data = ames_train)\n\n# predict on new data with a prediction interval\names_preds <-\n  mod %>%\n  predict(ames_test, interval = \"predict\") %>%\n  as_tibble()\n\n\n\n\nCode\n# plot!\names_preds %>%\n  \n  # re-scale predictions to match the original dataset's scale\n  bind_cols(ames_test) %>%\n  mutate(across(everything(), ~10^.x)) %>%\n  \n  # add geoms\n  ggplot(aes(x = First_Flr_SF)) +\n  geom_point(aes(y = Sale_Price),\n             alpha = 0.25) +\n  geom_line(aes(y = fit),\n            size = 1) +\n  geom_ribbon(aes(ymin = lwr,\n                  ymax = upr),\n              alpha = 0.25) +\n  scale_y_continuous(labels = scales::dollar_format(), trans = \"log10\") +\n  scale_x_continuous(labels = scales::comma_format(), trans = \"log10\") +\n  labs(title = \"Linear Model of Sale Price predicted by Square Footage\",\n       subtitle = \"Shaded area represents the 95% prediction interval\",\n       x = NULL,\n       y = NULL) \n\n\n With {workboots}, we can approximate the linear model’s prediction interval by passing a workflow built on a linear model to the function predict_boots().\n\n\nCode\nlibrary(tidymodels)\nlibrary(workboots)\n\n# setup a workflow with a linear model\names_wf <-\n  workflow() %>%\n  add_recipe(recipe(Sale_Price ~ First_Flr_SF, data = ames_train)) %>%\n  add_model(linear_reg())\n\n# generate bootstrap predictions on ames_test\nset.seed(713)\names_preds_boot <-\n  ames_wf %>%\n  predict_boots(\n    n = 2000,\n    training_data = ames_train,\n    new_data = ames_test\n  )\n\n\npredict_boots() works by creating 2000 bootstrap resamples of the training data, fitting a linear model to each resample, then generating 2000 predictions for each home’s price in the holdout set. We can then use summarise_predictions() to generate upper and lower intervals for each prediction.\n\n\nCode\names_preds_boot %>%\n  summarise_predictions()\n\n\n# A tibble: 733 × 5\n   rowid .preds               .pred .pred_lower .pred_upper\n   <int> <list>               <dbl>       <dbl>       <dbl>\n 1     1 <tibble [2,000 × 2]>  5.44        5.17        5.71\n 2     2 <tibble [2,000 × 2]>  5.27        4.98        5.55\n 3     3 <tibble [2,000 × 2]>  5.25        4.97        5.52\n 4     4 <tibble [2,000 × 2]>  5.40        5.11        5.67\n 5     5 <tibble [2,000 × 2]>  5.44        5.15        5.71\n 6     6 <tibble [2,000 × 2]>  5.21        4.93        5.49\n 7     7 <tibble [2,000 × 2]>  4.94        4.67        5.22\n 8     8 <tibble [2,000 × 2]>  5.13        4.85        5.40\n 9     9 <tibble [2,000 × 2]>  5.14        4.87        5.42\n10    10 <tibble [2,000 × 2]>  5.41        5.13        5.69\n# … with 723 more rows\n\n\nBy overlaying the intervals on top of one another, we can see that the prediction interval generated by predict_boots() is a good approximation of the theoretical interval generated by lm().\n\n\nCode\names_preds_boot %>%\n  summarise_predictions() %>%\n  bind_cols(ames_preds) %>%\n  bind_cols(ames_test) %>%\n  mutate(across(c(.pred:Sale_Price), ~10^.x)) %>%\n  ggplot(aes(x = First_Flr_SF)) +\n  geom_point(aes(y = Sale_Price),\n             alpha = 0.25) +\n  geom_line(aes(y = fit),\n            size = 1) +\n  geom_ribbon(aes(ymin = lwr,\n                  ymax = upr),\n              alpha = 0.25) +\n  geom_point(aes(y = .pred),\n             color = \"blue\",\n             alpha = 0.25) +\n  geom_errorbar(aes(ymin = .pred_lower,\n                    ymax = .pred_upper),\n                color = \"blue\",\n                alpha = 0.25,\n                width = 0.0125) +\n  scale_y_continuous(labels = scales::dollar_format(), trans = \"log10\") +\n  scale_x_continuous(labels = scales::comma_format(), trans = \"log10\") +\n  labs(title = \"Linear Model of Sale Price predicted by Square Footage\",\n       subtitle = \"Bootstrap prediction interval closely matches theoretical prediction interval\",\n       x = NULL,\n       y = NULL)\n\n\n\nBoth lm() and summarise_predictions() use a 95% prediction interval by default but we can generate other intervals by passing different values to the parameter conf:\n\n\nCode\names_preds_boot %>%\n  \n  # generate 95% prediction interval\n  summarise_predictions(conf = 0.95) %>%\n  rename(.pred_lower_95 = .pred_lower,\n         .pred_upper_95 = .pred_upper) %>%\n  select(-.pred) %>%\n  \n  # generate 80% prediction interval\n  summarise_predictions(conf = 0.80) %>%\n  rename(.pred_lower_80 = .pred_lower,\n         .pred_upper_80 = .pred_upper) %>%\n  bind_cols(ames_test) %>%\n  mutate(across(c(.pred_lower_95:Sale_Price), ~10^.x)) %>%\n  \n  # plot!\n  ggplot(aes(x = First_Flr_SF)) +\n  geom_point(aes(y = Sale_Price),\n             alpha = 0.25) +\n  geom_line(aes(y = .pred),\n            size = 1,\n            color = \"blue\") +\n  geom_ribbon(aes(ymin = .pred_lower_95,\n                  ymax = .pred_upper_95),\n              alpha = 0.25,\n              fill = \"blue\") +\n  geom_ribbon(aes(ymin = .pred_lower_80,\n                  ymax = .pred_upper_80),\n              alpha = 0.25,\n              fill = \"blue\") +\n  scale_y_continuous(labels = scales::dollar_format(), trans = \"log10\") +\n  scale_x_continuous(labels = scales::comma_format(), trans = \"log10\") +\n  labs(title = \"Linear Model of Sale Price predicted by Square Footage\",\n       subtitle = \"Predictions alongside 95% and 80% bootstrap prediction interval\",\n       x = NULL,\n       y = NULL)\n\n\n\nAs this example shows, {workboots} can approximate linear prediction intervals pretty well! But this isn’t very useful, since we can just generate a linear prediction interval from a linear model directly. The real benefit of {workboots} comes from generating prediction intervals from any model!"
  },
  {
    "objectID": "posts/2022-03-14-introducing-workboots/index.html#bootstrap-prediction-intervals-with-non-linear-models",
    "href": "posts/2022-03-14-introducing-workboots/index.html#bootstrap-prediction-intervals-with-non-linear-models",
    "title": "Introducing {workboots}",
    "section": "Bootstrap prediction intervals with non-linear models",
    "text": "Bootstrap prediction intervals with non-linear models\nXGBoost is one of my favorite models. Up until now, however, in situations that require a prediction interval, I’ve had to opt for a simpler model. With {workboots}, that’s no longer an issue! In this example, we’ll use XGBoost and {workboots} to generate predictions of a penguins weight from the Palmer Penguins dataset.\nTo get started, let’s build a workflow and train an individual model.\n\n\nCode\n# load and prep data\ndata(\"penguins\")\n\npenguins <-\n  penguins %>%\n  drop_na()\n\n# split data into training and testing sets\nset.seed(123)\npenguins_split <- initial_split(penguins)\npenguins_test <- testing(penguins_split)\npenguins_train <- training(penguins_split)\n\n\n\n\nCode\n# create a workflow\npenguins_wf <-\n  workflow() %>%\n  \n  # add preprocessing steps\n  add_recipe(\n    recipe(body_mass_g ~ ., data = penguins_train) %>%\n      step_dummy(all_nominal_predictors()) \n  ) %>%\n  \n  # add xgboost model spec\n  add_model(\n    boost_tree(\"regression\")\n  )\n\n# fit to training data & predict on test data\nset.seed(234)\npenguins_preds <-\n  penguins_wf %>%\n  fit(penguins_train) %>%\n  predict(penguins_test)\n\n\nAs mentioned above, XGBoost models can only generate point predictions.\n\n\nCode\npenguins_preds %>%\n  bind_cols(penguins_test) %>%\n  ggplot(aes(x = body_mass_g,\n             y = .pred)) +\n  geom_point() +\n  geom_abline(linetype = \"dashed\",\n              color = \"gray\") +\n  labs(title = \"XGBoost Model of Penguin Weight\",\n       subtitle = \"Individual model can only output individual predictions\")\n\n\n\nWith {workboots}, however, we can generate a prediction interval from our XGBoost model for each penguin’s weight!\n\n\nCode\n# create 2000 models from bootstrap resamples and make predictions on the test set\nset.seed(345)\npenguins_preds_boot <-\n  penguins_wf %>%\n  predict_boots(\n    n = 2000,\n    training_data = penguins_train,\n    new_data = penguins_test\n  )\n\npenguins_preds_boot %>%\n  summarise_predictions()\n\n\nHow does our bootstrap model perform?\n\n\nCode\npenguins_preds_boot %>%\n  summarise_predictions() %>%\n  bind_cols(penguins_test) %>%\n  ggplot(aes(x = body_mass_g,\n             y = .pred,\n             ymin = .pred_lower,\n             ymax = .pred_upper)) +\n  geom_abline(linetype = \"dashed\",\n              color = \"gray\") +\n  geom_errorbar(alpha = 0.5,\n                color = \"blue\") +\n  geom_point(alpha = 0.5,\n             color = \"blue\") +\n  labs(title = \"XGBoost Model of Penguin Weight\",\n       subtitle = \"Bootstrap models can generate prediction intervals\")\n\n\n\nThis particular model may be in need of some tuning for better performance, but the important takeaway is that we were able to generate a prediction distribution for the model! This method works with other regression models as well — just create a workflow then let {workboots} take care of the rest!"
  },
  {
    "objectID": "posts/2022-04-06-impeachment-republicans-and-democracy/index.html",
    "href": "posts/2022-04-06-impeachment-republicans-and-democracy/index.html",
    "title": "Impeachment Republicans and Democracy",
    "section": "",
    "text": "Code\nlibrary(tidyverse)\n\n# setup themes\nextrafont::loadfonts(device = \"win\")\ntheme_set(\n  theme_minimal(base_family = \"Roboto Slab\",\n                base_size = 13) +\n    theme(plot.title.position = \"plot\",\n          plot.background = element_rect(fill = \"#F9F9FC\", color = \"#F9F9FC\"),\n          plot.title = ggtext::element_markdown(),\n          plot.subtitle = ggtext::element_markdown())\n)\n\n\nA few months ago, Harrison Lavelle wrote a piece for Split Ticket reviewing the electoral challenges faced by house republicans who voted to impeach Donald Trump for his role in the assault on the capitol. Examining the voting records of these republicans who broke with their colleagues shows, unsurprisingly, that they tend to be more supportive of bills protecting democratic (note — small “d”) norms.\nFiveThirtyEight developed a democracy index to evaluate how members of congress vote to protect democratic basics and create a more inclusive democracy (higher scores indicate that the congressman/woman is more supportive of bills protecting/expanding democracy). The linked article is well worth reading and walks through the caveats and limitations of the metric, but, notably, house republicans who voted to impeach Donald Trump are on average more supportive of pro-democracy bills than their colleagues who voted to acquit (on bills through September 1st of last year, the day the article was published).\n\n\nCode\n# read in democracy scores\ncomparisons <- \n  read_csv(\"data/democracy_votes.csv\")\n\n# impeachment republicans\nimpeachment_republicans <-\n  c(\"Liz Cheney\", \n    \"Anthony Gonzalez\",\n    \"Jaime Herrera Beutler\",\n    \"John Katko\",\n    \"Adam Kinzinger\",\n    \"Peter Meijer\",\n    \"Dan Newhouse\",\n    \"Tom Rice\",\n    \"Fred Upton\",\n    \"David G. Valadao\")\n\n# plot comparisons\ncomparisons %>%\n  rename_with(str_to_lower) %>%\n  filter(chamber == \"House\",\n         party == \"Rep.\") %>%\n  select(legislator, \n         democracy_score = `more expansive`) %>%\n  mutate(impeach_vote = if_else(legislator %in% impeachment_republicans, \"Impeach\", \"Acquit\")) %>% \n  ggplot(aes(x = impeach_vote,\n             y = democracy_score,\n             color = impeach_vote)) +\n  geom_boxplot(size = 1) +\n  geom_point(alpha = 0.25, \n             size = 4,\n             position = position_jitter(width = 0.15)) +\n  scale_color_manual(values = c(\"#A97684\", \"#76A99B\")) +\n  coord_flip() +\n  theme(legend.position = \"none\") +\n  shadowtext::geom_shadowtext(x = 1.85,\n                              y = 15.7,\n                              label = \"Tom Rice\",\n                              size = 5,\n                              family = \"Roboto Slab\",\n                              color = \"#76A99B\",\n                              bg.color = \"white\") +\n  shadowtext::geom_shadowtext(x = 1.2,\n                              y = 66,\n                              label = \"Brian\\nFitzpatrick\",\n                              size = 5,\n                              family = \"Roboto Slab\",\n                              color = \"#A97684\",\n                              bg.color = \"white\") +\n  shadowtext::geom_shadowtext(x = 0.85,\n                              y = 57.9,\n                              label = \"Tom Reed\",\n                              size = 5,\n                              family = \"Roboto Slab\",\n                              color = \"#A97684\",\n                              bg.color = \"white\") +\n  labs(title = paste(\"How do House Republicans who voted to\",\n                     \"<span style=color:'#76A99B'>**impeach**</span>\",\n                     \"or\",\n                     \"<span style=color:'#A97684'>**acquit**</span>\",\n                     \"Donald Trump differ?\"),\n       subtitle = \"Comparing how often representatives take the more inclusive position on voting rights bills\",\n       x = NULL,\n       y = NULL,\n       caption = paste(\"Plot by @markjrieke\\n\",\n                       \"Data courtesy of @FiveThirtyEight\"))\n\n\n\nThere are some outliers: Tom Rice (SC-7) voted to impeach Trump but his votes on (small d) democratic bills are in line with the rest of house republicans whereas Brian Fitzpatrick (PA-1) and Tom Reed (NY-23) voted to acquit but have the highest pro-democracy scores by this ranking (there are other republicans who voted to acquit that have democracy scores similar to their colleagues who voted to impeach, but to avoid cluttering the plot, only the mathematical outliers are shown).\n\nPolling bites\nThere has been very little movement in the generic congressional ballot — republicans are still slightly favored by ~2 points. Biden’s presidential approval rating received a slight bump at the onset of Russia’s invasion of Ukraine, but the marginal gains since then have faded away and he currently sits at a -12.6% net approval.\n\n\n\n\n\n\n\nCitationBibTeX citation:@online{rieke2022,\n  author = {Mark Rieke},\n  title = {Impeachment {Republicans} and {Democracy}},\n  date = {2022-04-06},\n  url = {https://www.thedatadiary.net/posts/2022-04-06-impeachment-republicans-and-democracy},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2022. “Impeachment Republicans and Democracy.”\nApril 6, 2022. https://www.thedatadiary.net/posts/2022-04-06-impeachment-republicans-and-democracy."
  },
  {
    "objectID": "posts/2022-04-28-30-is-not-statistical/index.html",
    "href": "posts/2022-04-28-30-is-not-statistical/index.html",
    "title": "“30 is not Statistical”",
    "section": "",
    "text": "Code\nlibrary(tidyverse)\n\n# setup themes\ntheme_set(\n  theme_minimal(base_family = \"Roboto Slab\",\n                base_size = 13) +\n    theme(plot.title.position = \"plot\",\n          plot.background = element_rect(fill = \"#F9F9FC\", color = \"#F9F9FC\"),\n          plot.title = ggtext::element_markdown(),\n          plot.subtitle = ggtext::element_markdown())\n)\nIn my role as an analyst, my team and I are required to put together reports that summarize each hospital’s patient satisfaction performance in a table. These are reviewed by our system’s executive leadership team and the hospital directors in monthly operational reviews (MORs). The format I inherited, loosely recreated below with fake data, color codes each month’s performance against the hospital’s goal: green when outperforming and red when underperforming.\n“But wait!” you may ask, “what do the gray cells mean?” That, dear reader, has been the source of most of my organizational frustration in this role. When the number of surveys returned is less than 30 for a given month, we simply gray-out that cell under the guise of the phrase, “30 is not statistical.”\nI don’t think this practice (or something similar) is unique to my organization — I’ve seen similar outputs from previous employers and in other companies’ published reports. While this isn’t the best use of the underlying data, I understand why this sort of method gets adapted into so many organizational lexicons: companies want their decisions to be based on data and their understanding, albeit incorrect, is that a sample size less than 30 doesn’t provide meaningful info. For this reason, I think it’s important to explore where this sentiment came from, what the problems with this data-presentation style are, what I think would be a better way of presenting the data, and ultimately why companies may be hesitant to update their methodology."
  },
  {
    "objectID": "posts/2022-04-28-30-is-not-statistical/index.html#where-does-this-come-from",
    "href": "posts/2022-04-28-30-is-not-statistical/index.html#where-does-this-come-from",
    "title": "“30 is not Statistical”",
    "section": "Where does this come from?",
    "text": "Where does this come from?\nAt first glance, 30 is a pretty arbitrary number to use as a cutoff. In this case, this cutoff can cause downstream issues with interpreting the data because the difference between n = 30 and n = 31 is so visually distinct! In our case, the cutoff of 30 was passed down from one of our previous survey vendors, but I believe that the wider root of why this value appears has to do with the central limit theorem.\nThe central limit theorem states that as a sample size increases, the probability distribution of the sample mean approaches a normal distribution, regardless of the source distribution! As a rule of thumb, this theorem holds true when the sample size is at least 30. In practice, this means that when there are at least 30 samples, we can generally approximate the distribution as normal. The central limit theorem is incredibly useful and an important foundation for a wide array of statistical techniques. Stating that the data doesn’t meet the criteria for the central limit theorem to hold, however, is very different from saying that data is worthless when the sample size is less than 30!"
  },
  {
    "objectID": "posts/2022-04-28-30-is-not-statistical/index.html#problems-with-this-approach",
    "href": "posts/2022-04-28-30-is-not-statistical/index.html#problems-with-this-approach",
    "title": "“30 is not Statistical”",
    "section": "Problems with this approach",
    "text": "Problems with this approach\n\nSometimes, the source distribution is known, and whether or not the central limit theorem holds is irrelevant! In my particular case, I am often dealing with patient satisfaction data that lies on a 0-100% scale. This is the perfect use case for modeling the sample with the beta distribution (which is bound by 0 and 1).\nAs mentioned above, graying-out samples where the sample size is less than 30 visually communicates that some months can be ignored. This is a waste of valuable data! While it is true that a larger sample size implies greater confidence in the score, the confidence interval widths for n = 30 and n = 31 are not so different and we can still estimate the uncertainty with the smaller sample.\nTabular data is incredibly difficult to parse at-a-glance! Research shows that spatial encoding (e.g., length, position) is the most interpretable mode of data presentation. Intuitively, it makes sense — there’s a lot less mental overhead involved in looking at a set of points and comparing positions collectively than stringing together several comparisons of individual pairs of numbers in your head."
  },
  {
    "objectID": "posts/2022-04-28-30-is-not-statistical/index.html#a-better-approach",
    "href": "posts/2022-04-28-30-is-not-statistical/index.html#a-better-approach",
    "title": "“30 is not Statistical”",
    "section": "A better approach",
    "text": "A better approach\nWhen the underlying distribution is known, a better approach would be to display the data in a plot, regardless of n-size, and use a confidence interval to indicate uncertainty. In this case, we can plot each survey’s scores over time with a line and use a shaded area for the confidence interval.\n\n\nCode\n# copied via datapasta\nresponses <- \n  tibble::tribble(\n    ~survey, ~goal, ~month, ~score, ~n,\n    \"Survey A\", 60L, \"Jul\", 65.8,   277,\n    \"Survey A\", 60L, \"Aug\", 66.5,   264,\n    \"Survey A\", 60L, \"Sep\", 50.2,   279,\n    \"Survey A\", 60L, \"Oct\", 57.4,   287,\n    \"Survey A\", 60L, \"Nov\", 63.9,   265,\n    \"Survey A\", 60L, \"Dec\", 60.7,   270,\n    \"Survey A\", 60L, \"Jan\",   60,   263,\n    \"Survey A\", 60L, \"Feb\", 57.1,   281,\n    \"Survey A\", 60L, \"Mar\", 49.6,   267,\n    \"Survey B\", 75L, \"Jul\", 74.5,    35,\n    \"Survey B\", 75L, \"Aug\", 82.9,    32,\n    \"Survey B\", 75L, \"Sep\", 73.7,    39,\n    \"Survey B\", 75L, \"Oct\", 86.2,    27,\n    \"Survey B\", 75L, \"Nov\",   79,    31,\n    \"Survey B\", 75L, \"Dec\",   79,    26,\n    \"Survey B\", 75L, \"Jan\", 73.9,    29,\n    \"Survey B\", 75L, \"Feb\", 71.9,    20,\n    \"Survey B\", 75L, \"Mar\", 47.3,    26,\n    \"Survey C\", 55L, \"Jul\", 52.7,    73,\n    \"Survey C\", 55L, \"Aug\", 53.7,    96,\n    \"Survey C\", 55L, \"Sep\",   53,    81,\n    \"Survey C\", 55L, \"Oct\", 54.2,    99,\n    \"Survey C\", 55L, \"Nov\", 50.6,    85,\n    \"Survey C\", 55L, \"Dec\", 61.8,    83,\n    \"Survey C\", 55L, \"Jan\", 55.4,    97,\n    \"Survey C\", 55L, \"Feb\", 58.3,    82,\n    \"Survey C\", 55L, \"Mar\", 62.9,    83,\n    \"Survey D\", 70L, \"Jul\", 53.7,    29,\n    \"Survey D\", 70L, \"Aug\", 66.2,    38,\n    \"Survey D\", 70L, \"Sep\", 85.9,    36,\n    \"Survey D\", 70L, \"Oct\", 78.8,    28,\n    \"Survey D\", 70L, \"Nov\", 71.2,    32,\n    \"Survey D\", 70L, \"Dec\", 71.6,    38,\n    \"Survey D\", 70L, \"Jan\", 68.7,    39,\n    \"Survey D\", 70L, \"Feb\", 76.1,    37,\n    \"Survey D\", 70L, \"Mar\", 74.9,    36\n  )\n\nresponses %>%\n  mutate(month = paste(month, \"1st, 2022\"),\n         month = lubridate::mdy(month),\n         month = lubridate::month(month),\n         month = case_when(month < 7 ~ paste(\"2022\", month, \"1\", sep = \"-\"), \n                           month > 6 ~ paste(\"2021\", month, \"1\", sep = \"-\")),\n         month = lubridate::ymd(month),\n         score = score/100,\n         alpha = score * n,\n         beta = n - alpha) %>%\n  riekelib::beta_interval(alpha, beta) %>%\n  ggplot(aes(x = month,\n             y = score,\n             ymin = ci_lower,\n             ymax = ci_upper,\n             color = survey,\n             fill = survey)) +\n  geom_ribbon(alpha = 0.25,\n              color = NA) +\n  geom_line(size = 1) +\n  geom_hline(aes(yintercept = goal/100),\n             linetype = \"dashed\") +\n  facet_wrap(~survey) +\n  labs(title = \"Monthly Patient Satisfaction Scores at **Hospital ABCD**\",\n       subtitle = \"Dashed line shows survey goal; shaded area represents 95% conidence interval\",\n       x = NULL,\n       y = NULL,\n       caption = \"*Fake data that I made up for this example.\") + \n  scale_y_continuous(labels = scales::label_percent()) +\n  MetBrewer::scale_color_met_d(\"Egypt\") +\n  MetBrewer::scale_fill_met_d(\"Egypt\") +\n  theme(legend.position = \"none\")\n\n\n\n\n\nThis, I believe, has a few benefits.\n\nThis is simply more visually appealing than the table. I (along with most people, I’d assume) prefer the look of a well formatted plot over a well formatted table (even if well formatted, a table is still a big block of text).\nIt is far easier to discern the overall trend. Instead of reading and trying to compare values, we can simply see which direction the line is moving!\nMost imortantly, we do not throw out valuable data because of sample size. We actually end up encoding more information — n-size, which was missing from the table, is encoded in the width of the confidence interval (a smaller confidence interval indicates a larger sample). In this toy example, surveys B and D included a few months with fewer than 30 returns — can you tell which months they were without looking at the table?\n\nThe tradeoff is that we can no longer explicitly see each month’s score and it is a bit harder to tell if a hospital is meeting the goal when the score is close. In my experience, however, this is not how formatted tables are used — executives that I interact with typically try to determine overall trends from tabular data!"
  },
  {
    "objectID": "posts/2022-04-28-30-is-not-statistical/index.html#organizational-resistance",
    "href": "posts/2022-04-28-30-is-not-statistical/index.html#organizational-resistance",
    "title": "“30 is not Statistical”",
    "section": "Organizational resistance",
    "text": "Organizational resistance\nWhile the changes suggested here have clear benefits over the table, I’ve thus far been unsuccessful in any attempts to change the reporting methodology and I suspect that similar efforts at other companies would encounter similar organizational resistance. Much of what’s stated below is anec-data, but I assume will ring true to anyone who has struggled with getting their proposed operational changes implemented.\nAs companies scale, it becomes more & more difficult to implement change. On top of that, some industries (including Healthcare, the one I work in) are similarly inertial on an industry level. In this particular case, changing a report’s format may seem small in the grand scheme of things, but this is the same format the executive team has been seeing since 2017! The system executives and individual hospital leaders have a rapport and vernacular built around these monthly reports in this format — updating the format similarly requires that the executives and leaders update their long-held understanding and language built around tabular data.\nTabular data in general shows up in reports across industries. My hunch is that the main driver of this is the widespread integration of Microsoft Excel as the workhorse for most analysts’ tasks. Excel get wide use as a calculator, a data storage system (eek!), and a presentation tool. Most analysts are incredibly comfortable working in Excel and while it is possible to create plots that show both the score and confidence interval, it is far simpler to apply a bit of conditional formatting and submit the raw data as the report itself.\nThis is not to say that tabular reports have no use — when individual values are important, tabular reports are preferred! If, however, the goal is to understand trends over time or relationships between values, plots are a far better option!"
  },
  {
    "objectID": "posts/2022-05-31-practical-data-vizualization-tips-for-excel-users/index.html",
    "href": "posts/2022-05-31-practical-data-vizualization-tips-for-excel-users/index.html",
    "title": "Practical Data Visualization Tips for Excel Users",
    "section": "",
    "text": "I am an avid R user and will always advocate that others use R (or another programming language) for generating reproducible visualizations. In just about every organization, however, Excel plays an important role in an analyst’s toolkit. In this post, I’ll share some visualization design practices that I picked up while learning R but are ubiquitous and transferable to Excel (most of these suggestions are ripped directly from Will Chase’s “Glamour of Graphics” talk from rstudio::conf(2020), which has heavily informed how I think about visualization design)."
  },
  {
    "objectID": "posts/2022-05-31-practical-data-vizualization-tips-for-excel-users/index.html#a-motivating-example",
    "href": "posts/2022-05-31-practical-data-vizualization-tips-for-excel-users/index.html#a-motivating-example",
    "title": "Practical Data Visualization Tips for Excel Users",
    "section": "A motivating example",
    "text": "A motivating example\nFor the purposes of this exercise, let’s use fake patient satisfaction data from the Sesame Street Health System, which includes several hospitals and campuses. Let’s say that our system-wide patient satisfaction for the current fiscal year looks like this:\n\nMost of the hospitals have pretty high satisfaction scores — generally greater than 75%! The overall system score, however, sits at 65%. Concerned that there may be an error in the data pipeline or dashboard, your boss asks that you investigate what’s going on and provide an update at the next team meeting.\nAt first glance, it may be pretty obvious what’s going on — Big Bird Emergency has a pretty low satisfaction score and you know from experience that it’s a larger hospital that generates a lot of survey returns, which may be driving the score down. Since you’re presenting, however, it’s best to use a visualization to communicate this."
  },
  {
    "objectID": "posts/2022-05-31-practical-data-vizualization-tips-for-excel-users/index.html#putting-together-a-bad-plot",
    "href": "posts/2022-05-31-practical-data-vizualization-tips-for-excel-users/index.html#putting-together-a-bad-plot",
    "title": "Practical Data Visualization Tips for Excel Users",
    "section": "Putting together a bad plot",
    "text": "Putting together a bad plot\nDownloading the hospital data and opening in Excel confirms that Big Bird Emergency has far more survey returns than other hospitals.\n\nA quick plot that technically includes all the information needed may look something like this:\n\nWhile this does answer the question originally asked, the answer is not clearly communicated by a quick glance. Viewers who know what was originally asked have to do some extra mental work to decode the plot, and viewers who see this without the original context may not find anything useful. Our goal should be to provide a visualization that:\n\nClearly communicates the message we want to convey.\nIs able to stand alone in other contexts and still communicate the same message.\nIs visually appealing.\n\nLet’s get started!"
  },
  {
    "objectID": "posts/2022-05-31-practical-data-vizualization-tips-for-excel-users/index.html#putting-together-a-good-plot",
    "href": "posts/2022-05-31-practical-data-vizualization-tips-for-excel-users/index.html#putting-together-a-good-plot",
    "title": "Practical Data Visualization Tips for Excel Users",
    "section": "Putting together a good plot",
    "text": "Putting together a good plot\n\nChanging to a bar plot\n\nThe first order of business is to convert the plot from a pie chart to a bar plot. Pie charts are loved by executives but loathed by visualization practitioners, since information is encoded in each slice’s angle and differences in angle are difficult for the human eye to detect. Bar plots encode the same information with relative position on a scale, which is the most effective method for showing differences. This also has the added benefit in Excel of automatically converting each hospital to the same color, which reduces a lot of the visual noise that was in the original plot.\n\n\nFlipping axes\n\nIn order to read the hospital names in the previous plot, viewers need to crane their necks to align with the axis text. The angled text also takes up a lot of whitespace and makes the important part — the actual data — look a bit squished. Changing to a horizontal bar plot alleviates both of these issues (horizontal bar plots are preferred over vertical ones in general for this reason).\n\n\nOrdering the data\n\nUnordered categories in a plot can be messy and visually confusing — the viewer’s eye needs to dart around to determine which values are greater than other ones. Ordering the categories reduces this cognitive load and allows the viewer to simply read through the list. In this case (and in most cases), we don’t care about the exact values (just the relative difference between values), so we can also remove the data labels.\nTo order a plot in Excel, we don’t actually need to do anything to the plot itself — simply turn the raw data into a table then arrange the rows by survey_returns:\n\n\n\nGiving the plot a narrative\n\nThe original title, “FYTD Surveys”, while technically informative, is uninspiring. We’re putting together this plot to answer the specific question, why is the system satisfaction score 65% when most hospitals have a higher score? A good visualization will directly answer this without needing additional context from the analyst — the title is a great place to state that Big Bird Emergency is driving the system score down.\nAlso note that there are no axis labels on this plot. Axis labels are often unnecessary — they take up valuable whitespace with information that is either readily apparent (I don’t need a label to know that the y-axis refers to each hospital!) or encoded elsewhere. When possible, remove axis labels and describe the necessary detail elsewhere (i.e., the title or subtitle).\n\n\nHighlighting the important bits\n\nColor can be a great way to draw our attention to a particular portion of a plot. In this case, not all of the hospitals are equally important in this plot’s narrative — we’re making a distinct point regarding Big Bird Emergency. Highlighting the text and bar for Big Bird Emergency in yellow (Big Bird is, after all, a big yellow bird) while graying out the other bars visually communicates to the viewer this is the hospital deserving the most attention in this plot.\n\n\nRealigning the plot\n\nIn the vast majority of cases, a left-aligned the title/subtitle is strongly preferred over center-aligned one. In western countries, we tend to naturally orient our attention in the top-left corner of plots when we first view them, then migrate our gaze downwards and leftwards (eye-tracking studies confirm this, however I can’t seem to find the source I heard this from, so you’ll just have to take my word for it here). By aligning the title to the left, we reduce how much the viewer needs to dart their eyes around the plot to understand it.\n\n\nAdding the final touches\n\nAdding some final formatting touches to polish up the visualization not only improves the quality of the plot but also shows the viewer that you’re serious about your craft and willing to go the extra mile to really make a visualization shine. In this case, applying comma-formatting to the x-axis, changing the font, and updating the background to an off-white are all minor edits, but their effects have a big impact on the visualization’s overall presentation."
  },
  {
    "objectID": "posts/2022-06-12-estimate-your-uncertainty/index.html",
    "href": "posts/2022-06-12-estimate-your-uncertainty/index.html",
    "title": "Estimate your uncertainty",
    "section": "",
    "text": "Code\nlibrary(tidyverse)\n\n# setup themes\ntheme_set(\n  theme_minimal(base_family = \"Roboto Slab\",\n                base_size = 15) +\n    theme(plot.title.position = \"plot\",\n          plot.background = element_rect(fill = \"#F9F9FC\", color = \"#F9F9FC\"),\n          plot.title = ggtext::element_markdown(),\n          plot.subtitle = ggtext::element_markdown())\n)\nI recently picked up David Robinson’s book, Introduction to Empirical Bayes. It’s available online for a price of your own choosing (operating under a “pay-what-you-want” model), so you can technically pick it up for free, but it’s well worth the suggested price of $9.95. The book has a particular focus on practical steps for implementing Bayesian methods with code, which I appreciate. I’ve made it through Part I (of four), which makes for a good stopping point to practice what I’ve read.\nThe first section is highly focused on modeling the probability of success/failure of some binary outcome using a beta distribution. This is highly relevant to my work as an analyst, where whether or not a patient responded positively to a particular question on a survey can be modeled with this method. Thus far, however, I’ve taken the frequentist approach to analyses, which assumes we know nothing about what the data ought to look like prior to analyzing it. This is largely because I didn’t know of a robust way to estimate a prior for a Bayesian analysis.\nThankfully, however, the book walks through examples of exactly how to do this! We can use a maximum likelihood estimator to estimate a reasonable prior given the current data. That’s quite a bit of statistical mumbo-jumbo — in this post I’ll walk through an example that spells it out a bit more clearly using fake hospital satisfaction data (N.B.; this is largely a recreation of the steps taken in the book — practice makes perfect!)."
  },
  {
    "objectID": "posts/2022-06-12-estimate-your-uncertainty/index.html#setting-up-the-data",
    "href": "posts/2022-06-12-estimate-your-uncertainty/index.html#setting-up-the-data",
    "title": "Estimate your uncertainty",
    "section": "Setting up the data",
    "text": "Setting up the data\nFirst, let’s simulate responses to patient satisfaction surveys. I tend to look at patient satisfaction scores across individual hospital units (e.g., ED, ICU, IMU, etc.). Units can have varying numbers of discharges, so we’ll use a log-normal distribution to estimate the number of responses for each unit.\n\n\nCode\n# simulate 1,500 hospital units with an average of 150 survey returns per unit\nset.seed(123)\nsurvey_data <- \n  rlnorm(1500, log(150), 1.5) %>%\n  as_tibble() %>%\n  rename(n = value)\n\nsurvey_data %>%\n  ggplot(aes(x = n)) +\n  geom_histogram() +\n  scale_x_log10(labels = scales::comma_format()) +\n  labs(title = \"Simulation of hospital satisfaction data\",\n       subtitle = \"Distribution of the number of survey returns per hospital unit\",\n       x = NULL,\n       y = NULL) \n\n\n\n\n\nThe spectrum of responses is incredibly broad — some units have a massive number of returns (in the tens of thousands!) while others have just a handful. This is fairly consistent with the real-world data that I’ve seen (though the units on the high-side are a bit over-represented here).\nNext, let’s assume that there is some true satisfaction rate that is associated with each unit. If each unit had an infinite number of survey returns, the satisfaction rate from the survey returns would approach this true value. In this case, we’ll set the true satisfaction for each unit randomly but have it hover around 66%.\n\n\nCode\n# set the true satisfaction to be different for each unit, but hover around 66%\nset.seed(234)\nsurvey_data <- \n  survey_data %>%\n  rowwise() %>%\n  mutate(true_satisfaction = rbeta(1, 66, 34))\n\n\nAlthough there is a true satisfaction associated with each unit, we wouldn’t expect that the reported survey scores would match this exactly. This is especially true when there are few responses — if a unit has a true satisfaction rate of 75% but only 3 responses, it’s impossible for the reported score to match the underlying true rate!\nWe can simulate the number of patients who responded positively (in survey terms, the number of “topbox” responses) by generating n responses for each unit using a binomial distribution.\n\n\nCode\n# simulate the number of patients responding with the topbox value\n# we *know* the true value, but the actual score may vary!\nset.seed(345)\nsurvey_data <-\n  survey_data %>%\n  mutate(n = round(n),\n         topbox = rbinom(1, n, true_satisfaction)) %>%\n  ungroup() %>%\n  \n  # name each unit\n  rowid_to_column() %>%\n  mutate(unit = paste(\"Unit\", rowid)) %>%\n  relocate(unit) %>%\n  \n  # remove the true satisfaction so we don't know what it is!\n  select(-rowid, -true_satisfaction)\n\n# find patient satisfaction scores\nsurvey_data <- \n  survey_data %>%\n  mutate(score = topbox/n)\n\nsurvey_data %>%\n  ggplot(aes(x = score)) +\n  geom_histogram() +\n  scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +\n  labs(title = \"Simulation of hospital satisfaction data\",\n       subtitle = \"Distribution of patient satisfaction scores per hospital unit\",\n       x = NULL,\n       y = NULL)\n\n\n\n\n\nAs expected, most of our simulated data hovers around a score of 66%. However, there are a few scores at the extremes of 0% and 100% — given how we simulated the data, it is unlikely that these units are really performing so poorly/so well and it’s likelier that they just have few returns.\n\n\nCode\n# which units have the highest scores?\nsurvey_data %>%\n  arrange(desc(score)) %>%\n  slice_head(n = 10) %>%\n  knitr::kable()\n\n\n\n\n\nunit\nn\ntopbox\nscore\n\n\n\n\nUnit 26\n12\n12\n1.0000000\n\n\nUnit 591\n2\n2\n1.0000000\n\n\nUnit 616\n3\n3\n1.0000000\n\n\nUnit 811\n3\n3\n1.0000000\n\n\nUnit 943\n12\n12\n1.0000000\n\n\nUnit 1217\n6\n6\n1.0000000\n\n\nUnit 1435\n3\n3\n1.0000000\n\n\nUnit 1437\n6\n6\n1.0000000\n\n\nUnit 863\n19\n18\n0.9473684\n\n\nUnit 372\n13\n12\n0.9230769\n\n\n\n\n\n\n\nCode\n# which units have the lowest scores?\nsurvey_data %>%\n  arrange(score) %>%\n  slice_head(n = 10) %>%\n  knitr::kable()\n\n\n\n\n\nunit\nn\ntopbox\nscore\n\n\n\n\nUnit 1092\n4\n0\n0.0000000\n\n\nUnit 248\n20\n5\n0.2500000\n\n\nUnit 1120\n7\n2\n0.2857143\n\n\nUnit 416\n3\n1\n0.3333333\n\n\nUnit 456\n3\n1\n0.3333333\n\n\nUnit 972\n6\n2\n0.3333333\n\n\nUnit 113\n13\n5\n0.3846154\n\n\nUnit 260\n15\n6\n0.4000000\n\n\nUnit 695\n15\n6\n0.4000000\n\n\nUnit 1352\n17\n7\n0.4117647\n\n\n\n\n\nAs expected, the units on either end of the spectrum aren’t necessarily outperforming/underperforming — they simply don’t have a lot of survey responses! We can use Bayesian inference to estimate the true satisfaction rate by specifying and updating a prior!"
  },
  {
    "objectID": "posts/2022-06-12-estimate-your-uncertainty/index.html#generating-a-prior-distribution",
    "href": "posts/2022-06-12-estimate-your-uncertainty/index.html#generating-a-prior-distribution",
    "title": "Estimate your uncertainty",
    "section": "Generating a prior distribution",
    "text": "Generating a prior distribution\nWhen looking at the entire dataset, the distribution of scores is thrown off a bit by the units with few responses. If we restrict the dataset to only the units that have more than 30 responses (which, as I’ve written about before, isn’t necessarily a data-driven cutoff for analysis) we can get a clearer idea of the distribution of the scores.\n\n\nCode\nsurvey_data_filtered <-\n  survey_data %>%\n  filter(n > 30)\n\nsurvey_data_filtered %>%\n  ggplot(aes(x = score)) +\n  geom_histogram() +\n  scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +\n  labs(title = \"Simulation of hospital satisfaction data\",\n       subtitle = \"Distribution of patient satisfaction scores for units with more than 30 responses\",\n       x = NULL,\n       y = NULL)\n\n\n\n\n\nAlternatively, we can represent this distribution with a density plot:\n\n\nCode\nsurvey_data_filtered %>%\n  ggplot(aes(x = score)) +\n  geom_density(size = 1) +\n  scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +\n  labs(title = \"Simulation of hospital satisfaction data\",\n       subtitle = \"Distribution of patient satisfaction scores for units with more than 30 responses\",\n       x = NULL,\n       y = NULL)\n\n\n\n\n\nThis looks suspiciously like a beta distribution! A beta distribution’s shape can be defined by two parameters — alpha and beta. Varying these parameters lets us adjust the center and width to match any possible beta distribution.\n\nWhat may make sense would be to use this distribution as our prior. I.e., if we have no responses for a unit, we can probably guess that their score would be somewhere around 66% with some healthy room on either side for variability. To do so, we need to estimate an appropriate alpha and beta — rather than guess the values using trial and error we can pass the work off to our computer to find parameters that maximize the likelihood that our estimated distribution matches the true distribution (hence the name, maximum likelihood estimator).\n\n\nCode\nlibrary(stats4)\n\n# log-likelihood function\nlog_likelihood <- function(alpha, beta) {\n  -sum(dbeta(survey_data_filtered$score, alpha, beta, log = TRUE))\n}\n\n# pass various alphas & betas to `log_likelihood` \n# to find combination that maximizes the likelihood!\nparams <- \n  mle(\n    log_likelihood, \n    start = list(alpha = 50, beta = 50),\n    lower = c(1, 1)\n  )\n\n# extract alpha & beta\nparams <- coef(params)\nalpha0 <- params[1]\nbeta0 <- params[2]\n\nprint(paste(\"alpha:\", round(alpha0, 1), \"beta:\", round(beta0, 1)))\n\n\n[1] \"alpha: 39.7 beta: 20.5\"\n\n\nHow well does a beta distribution defined by these parameters match our actual data?\n\n\nCode\nsurvey_data_filtered %>%\n  mutate(density = dbeta(score, alpha0, beta0)) %>%\n  ggplot(aes(x = score)) +\n  geom_density(size = 1) +\n  geom_line(aes(y = density),\n            size = 1,\n            color = \"#BD43BF\") +\n  scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +\n  labs(title = \"Simulation of hospital satisfaction data\",\n       subtitle = glue::glue(\"**Actual distribution of scores** and the **{riekelib::color_text('distribution estimated by maximum likelihood', '#BD43BF')}**\"),\n       x = NULL,\n       y = NULL)\n\n\n\n\n\nThis is a pretty good representation of our initial data! When we have no survey responses, we can use a beta distribution with the initial parameters as specified by the maximum likelihood estimation. As a unit gets more responses, we can update our estimation to rely more heavily on the data rather than the prior:\n\n\nCode\n# update alpha & beta as new responses come in!\nalpha_new <- alpha0 + n_topbox\nbeta_new <- beta0 + n - n_topbox"
  },
  {
    "objectID": "posts/2022-06-12-estimate-your-uncertainty/index.html#updating-our-priors",
    "href": "posts/2022-06-12-estimate-your-uncertainty/index.html#updating-our-priors",
    "title": "Estimate your uncertainty",
    "section": "Updating our priors",
    "text": "Updating our priors\nWith a prior distribution defined by alpha0 and beta0, we can upgrade our frequentest estimation of each unit’s score to a Bayesian estimation!\n\n\nCode\n# empirical bayes estimation of satisfaction score\nsurvey_eb <-\n  survey_data %>%\n  mutate(eb_estimate = (topbox + alpha0) / (n + alpha0 + beta0))\n\n\nWhat are the top and bottom performing units by this new Bayesian estimation?\n\n\nCode\n# which units have the highest estimated scores?\nsurvey_eb %>%\n  arrange(desc(eb_estimate)) %>%\n  slice_head(n = 10) %>%\n  knitr::kable()\n\n\n\n\n\nunit\nn\ntopbox\nscore\neb_estimate\n\n\n\n\nUnit 133\n160\n133\n0.8312500\n0.7841640\n\n\nUnit 1004\n123\n103\n0.8373984\n0.7787827\n\n\nUnit 172\n165\n133\n0.8060606\n0.7667547\n\n\nUnit 1042\n372\n291\n0.7822581\n0.7650930\n\n\nUnit 1294\n1409\n1083\n0.7686302\n0.7641391\n\n\nUnit 892\n349\n273\n0.7822350\n0.7641085\n\n\nUnit 306\n247\n195\n0.7894737\n0.7639102\n\n\nUnit 1249\n1234\n943\n0.7641815\n0.7592901\n\n\nUnit 427\n5469\n4151\n0.7590053\n0.7579168\n\n\nUnit 920\n1637\n1243\n0.7593158\n0.7557585\n\n\n\n\n\n\n\nCode\n# which units have the lowest estimated scores?\nsurvey_eb %>%\n  arrange(eb_estimate) %>%\n  slice_head(n = 10) %>%\n  knitr::kable()\n\n\n\n\n\nunit\nn\ntopbox\nscore\neb_estimate\n\n\n\n\nUnit 613\n1886\n932\n0.4941676\n0.4992689\n\n\nUnit 760\n112\n49\n0.4375000\n0.5149645\n\n\nUnit 363\n226\n112\n0.4955752\n0.5299674\n\n\nUnit 316\n431\n224\n0.5197216\n0.5368008\n\n\nUnit 1032\n235\n119\n0.5063830\n0.5375222\n\n\nUnit 1093\n354\n183\n0.5169492\n0.5376064\n\n\nUnit 749\n5286\n2839\n0.5370791\n0.5384528\n\n\nUnit 291\n865\n460\n0.5317919\n0.5400741\n\n\nUnit 515\n60\n26\n0.4333333\n0.5463929\n\n\nUnit 622\n242\n127\n0.5247934\n0.5515432\n\n\n\n\n\nThere are a few things that are worth noting with these estimates:\n\nThe estimated score is not the same as the actual reported score! As more responses come in, however, the estimated score converges to the actual.\nThe prior pulls estimated scores towards the prior mean — low scores are pulled up a bit and high scores are pulled down a bit.\nThe top (and bottom) performing units are no longer dominated by units with few returns!\n\nWe can also estimate the uncertainty around the estimated score with a credible interval. Credible intervals are the Bayesian counterpart to a frequentist’s confidence interval — both estimate the region that the true value could fall in given a certain probability — credible intervals, however, are informed by the prior distribution.\n\n\nCode\nset.seed(777)\nsurvey_eb %>%\n  slice_sample(n = 10) %>%\n  mutate(alpha = alpha0 + topbox,\n         beta = beta0 + n - topbox) %>%\n  riekelib::beta_interval(alpha, beta) %>%\n  rename_with(.cols = starts_with(\"ci\"), .fn = ~paste0(\"bayes_\", .x)) %>%\n  riekelib::beta_interval(topbox, n - topbox) %>%\n  rename_with(.cols = starts_with(\"ci\"), .fn = ~paste0(\"freq_\", .x)) %>% \n  mutate(unit = paste0(unit, \" (n=\", n, \")\"),\n         unit = fct_reorder(unit, -n)) %>%\n  ggplot(aes(x = unit)) +\n  geom_point(aes(y = score),\n             color = \"#FF8655\",\n             alpha = 0.75,\n             size = 2.5) +\n  geom_errorbar(aes(ymin = freq_ci_lower,\n                    ymax = freq_ci_upper),\n                color = \"#FF8655\",\n                alpha = 0.75,\n                size = 1) +\n  geom_point(aes(y = eb_estimate),\n             color = \"#55CEFF\",\n             alpha = 0.75,\n             size = 2.5) +\n  geom_errorbar(aes(ymin = bayes_ci_lower,\n                    ymax = bayes_ci_upper),\n                color = \"#55CEFF\",\n                alpha = 0.75,\n                size = 1) +\n  coord_flip() +\n  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +\n  labs(title = \"Random sampling of hospital units\",\n       subtitle = glue::glue(\"Comparison of 95% **{riekelib::color_text('credible intervals', '#55CEFF')}** and **{riekelib::color_text('confidence intervals', '#Ff8655')}**\"),\n       x = NULL,\n       y = NULL)\n\n\n\n\n\nBecause credible intervals are informed in part by the prior, they are tighter than their confidence interval counterparts. Like with the estimated score, however, as n-size increases, the Bayesian and frequentist interval estimations converge. In the absence of larger swathes of data, Bayesian methods can offer additional insight into our data by means of a prior distribution."
  },
  {
    "objectID": "posts/2022-06-12-estimate-your-uncertainty/index.html#some-closing-thoughts",
    "href": "posts/2022-06-12-estimate-your-uncertainty/index.html#some-closing-thoughts",
    "title": "Estimate your uncertainty",
    "section": "Some closing thoughts",
    "text": "Some closing thoughts\nOverall, this has been a fairly glowing review of the methods laid out in the first section of Introduction to Empirical Bayes. That being said, Bayesian methods of inference are not inherently better than frequentist methods — while they can offer additional context via a prior, there are situations where frequentist methods are preferred. From a math perspective, the prior provides diminishing returns as sample size increases, so it may be better forgoe Bayesian analysis when sample sizes are large. From an organizational perspective, Bayesian inference may be difficult to explain. In my own work, it’s highly unlikely that I’ll use Bayesian inference in any critical projects any time soon — I can imagine a lengthy uphill battle trying to explain the difference between the reported score and the estimated score informed by a prior.\nFinally, there are a few things in this toy analysis that I am hoping to improve upon as I progress further through the book:\n\nAs I mentioned above and in previous writings, using n = 30 is a relatively arbitrary cutoff point for analysis. In this case, the prior distribution is fairly sensitive to the cutoff point selected — I am hoping that later sections in the book highilight more robust ways of partitioning data for setting priors.\nIn the above analysis we’re only examining one variable (univariate analysis) — I am looking forward to extending these methods to multivariate analyses and regressions.\nThe beta distribution is appropriate for modeling the probability distribution of binary outcomes. In this example, where the outcome is simply the proportion of patients that responded favorably to the survey, modeling the outcome with a beta distribution is appropriate (responses can either be in the “topbox” or not). When there are more than two possible outcomes — for example, when trying to model Net Promoter Score as the proportion of “promoters,” “passives,” and “detractors” — the more general Dirichlet distribution is more appropriate.\nI’m hoping also that the book covers methods for dealing with time-dependent data. For example, we’d expect that concerted efforts (or lack thereof) by the hospital units could significantly impact the underlying “true satisfaction” that we’re attempting to estimate via surveying. We expect that more recent survey responses should be more impactful in informing our posterior estimation, but I’ve yet to find any robust literature on how to weight the recency of responses. In the past, I’ve used exponentional decay to reduce the weight of old responses, but this feels a bit arbitrary.\n\nOverall, this has been a long way of saying that I’m happy with the book so far and I’m excited to see what comes next as I continue reading!"
  },
  {
    "objectID": "posts/2022-07-05-the-math-behind-workboots/index.html",
    "href": "posts/2022-07-05-the-math-behind-workboots/index.html",
    "title": "The Math Behind workboots",
    "section": "",
    "text": "Code\nggplot2::theme_set(\n  ggplot2::theme_minimal() +\n    ggplot2::theme(plot.title.position = \"plot\",\n                   plot.background = ggplot2::element_rect(fill = \"white\", color = \"white\"))\n)\n\n\nGenerating prediction intervals with workboots hinges on a few core concepts: bootstrap resampling, estimating prediction error for each resample, and aggregating the resampled prediction errors for each observation. The bootstraps() documentation from {rsample} gives a concise definition of bootstrap resampling:\n\nA bootstrap sample is a sample that is the same size as the original data set that is made using replacement. This results in analysis samples that have multiple replicates of some of the original rows of the data. The assessment set is defined as the rows of the original data that were not included in the bootstrap sample. This is often referred to as the “out-of-bag” (OOB) sample.\n\nThis vignette will walk through the details of estimating and aggregating prediction errors — additional resources can be found in Davison and Hinkley’s book, Bootstrap Methods and their Application, or Efron and Tibshirani’s paper, Improvements on Cross-Validation: The Bootstrap .632+ Method.\n\nThe Bootstrap .632+ Method\n\nWhat follows here is largely a summary of this explanation of the .632+ error rate by Benjamin Deonovic.\n\nWhen working with bootstrap resamples of a dataset, there are two error estimates we can work with: the bootstrap training error and the out-of-bag (oob) error. Using the Sacramento housing dataset, we can estimate the training and oob error for a single bootstrap.\n\n\nCode\nlibrary(tidymodels)\n# setup our data\ndata(\"Sacramento\")\n\nSacramento <-\n  Sacramento %>%\n  select(sqft, type, price) %>%\n  mutate(across(c(sqft, price), log10)) \n\nset.seed(987)\nsacramento_split <- initial_split(Sacramento)\nsacramento_train <- training(sacramento_split)\nsacramento_test <- testing(sacramento_split)\n\n# setup bootstrapped dataset for .632+ example\nsacramento_boots <- bootstraps(sacramento_train, times = 1)\n\nsacramento_boots\n\n\n# Bootstrap sampling \n# A tibble: 1 × 2\n  splits            id        \n  <list>            <chr>     \n1 <split [699/261]> Bootstrap1\n\n\nUsing a k-nearest-neighbor regression model and rmse as our error metric, we find that the training and oob error differ, with the training error lesser than the oob error.\n\n\nCode\n# setup a workflow to predict price using a knn regressor\nsacramento_recipe <-\n  recipe(price ~ ., data = sacramento_train) %>%\n  step_dummy(all_nominal())\n\nsacramento_spec <-\n  nearest_neighbor() %>%\n  set_mode(\"regression\")\n\nsacramento_wf <-\n  workflow() %>%\n  add_recipe(sacramento_recipe) %>%\n  add_model(sacramento_spec)\n\nset.seed(876)\nsacramento_fit <-\n  sacramento_wf %>%\n  fit(training(sacramento_boots$splits[[1]])) \n\n# get bootstrap training error\nsacramento_train_err <- \n  Metrics::rmse(\n    training(sacramento_boots$splits[[1]])$price,\n    sacramento_fit %>% predict(training(sacramento_boots$splits[[1]])) %>% pull(.pred)\n  )\n\n# get oob error\nsacramento_oob_err <-\n  Metrics::rmse(\n    testing(sacramento_boots$splits[[1]])$price,\n    sacramento_fit %>% predict(testing(sacramento_boots$splits[[1]])) %>% pull(.pred)\n  )\n\nsacramento_train_err\n\n\n[1] 0.08979873\n\n\nCode\nsacramento_oob_err\n\n\n[1] 0.1661675\n\n\nThe training error is overly optimistic in the model’s performance and likely to under-estimate the prediction error. We are interested in the model’s performance on new data. The oob error, on the other hand, is likely to over-estimate the prediction error! This is due to non-distinct observations in the bootstrap sample that results from sampling with replacement. Given that the average number of distinct observations in a bootstrap training set is about 0.632 * total_observations, Efron and Tibshirani proposed a blend of the training and oob error with the 0.632 estimate:\n\\[\n\\begin{align*}\nErr_{.632} & = 0.368 Err_{train} + 0.632 Err_{oob}\n\\end{align*}\n\\]\n\n\nCode\nsacramento_632 <- 0.368 * sacramento_train_err + 0.632 * sacramento_oob_err\nsacramento_632\n\n\n[1] 0.1380638\n\n\nIf, however, the model is highly overfit to the bootstrap training set, the training error will approach 0 and the 0.632 estimate will under estimate the prediction error.\nAn example from Applied Predictive Modeling shows that as model complexity increases, the reported resample accuracy by the 0.632 estimate continues to increase whereas other resampling strategies report diminishing returns:\n\nAs an alternative to the 0.632 estimate, Efron & Tibshirani also propose the 0.632+ estimate, which re-weights the blend of training and oob error based on the model overfit rate:\n\\[\n\\begin{align*}\nErr_{0.632+} & = (1 - w) Err_{train} + w Err_{oob} \\\\\n\\\\\nw & = \\frac{0.632}{1 - 0.368 R} \\\\\n\\\\\nR & = \\frac{Err_{oob} - Err_{train}}{\\gamma - Err_{train}}\n\\end{align*}\n\\]\nHere, \\(R\\) represents the overfit rate and \\(\\gamma\\) is the no-information error rate, estimated by evaulating all combinations of predictions and actual values in the bootstrap training set.\n\n\nCode\n# estimate the no-information error rate\npreds_train <- \n  predict(sacramento_fit, training(sacramento_boots$splits[[1]])) %>% \n  pull(.pred)\n\nactuals_train <- \n  training(sacramento_boots$splits[[1]]) %>% \n  pull(price)\n\nall_combinations <- \n  crossing(actuals_train, preds_train)\n\nrmse_ni <- \n  Metrics::rmse(all_combinations$actuals_train, all_combinations$preds_train)\n\n# estimate the overfit rate\noverfit <- \n  (sacramento_oob_err - sacramento_train_err)/(rmse_ni - sacramento_train_err)\n\n# estimate weight\nw <- 0.632 / (1 - 0.368 * overfit)\n\nsacramento_632_plus <- (1 - w) * sacramento_train_err + w * sacramento_oob_err\nsacramento_632_plus\n\n\n[1] 0.1450502\n\n\nWhen there is no overfitting (i.e., \\(R = 0\\)) the 0.632+ estimate will equal the 0.632 estimate. In this case, however, the model is overfitting the training set and the 0.632+ error estimate is pushed a bit closer to the oob error.\n\n\nPrediction intervals with many bootstraps\nFor an unbiased estimator, rmse is the standard deviation of the residuals. With this in mind, we can modify our predictions to include a sample from the residual distribution (for more information, see Algorithm 6.4 from Davison and Hinkley’s Bootstrap Methods and their Application):\n\n\nCode\nset.seed(999)\nresid_train_add <- rnorm(length(preds_train), 0, sacramento_632_plus)\npreds_train_mod <- preds_train + resid_train_add\n\n\nThus far, we’ve been working with a single bootstrap resample. When working with a single bootstrap resample, adding this residual term gives a pretty poor estimate for each observation:\n\n\nCode\nlibrary(ggplot2)\n\ntibble(.pred = preds_train_mod) %>%\n  bind_cols(training(sacramento_boots$splits[[1]])) %>%\n  mutate(across(c(.pred, price), ~10^.x)) %>%\n  ggplot(aes(x = .pred, y = price)) +\n  geom_point(alpha = 0.25,\n             size = 2.5,\n             color = \"midnightblue\") +\n  geom_abline(linetype = \"dashed\",\n              size = 1, \n              color = \"gray\") +\n  labs(title = \"Predicted sale price of home in Sacramento\",\n       subtitle = \"Adding a single error estimate produces poor predictions of price\",\n       x = \"Predicted price\",\n       y = \"Actual price\") +\n  scale_x_log10(labels = scales::label_dollar(scale_cut = cut_short_scale())) +\n  scale_y_log10(labels = scales::label_dollar(scale_cut = cut_short_scale())) \n\n\n\n\n\nWith workboots, however, we can repeat this process over many bootstrap datasets to generate a prediction distribution for each observation:\n\n\nCode\nlibrary(workboots)\n\n# fit and predict price in sacramento_test from 100 models\n# the default number of resamples is 2000 - dropping here to speed up knitting\nset.seed(555)\nsacramento_pred_int <-\n  sacramento_wf %>%\n  predict_boots(\n    n = 100,\n    training_data = sacramento_train,\n    new_data = sacramento_test\n  )\n\nsacramento_pred_int %>%\n  summarise_predictions() %>%\n  bind_cols(sacramento_test) %>%\n  mutate(across(c(.pred:.pred_upper, price), ~ 10^.x)) %>%\n  ggplot(aes(x = .pred,\n             y = price,\n             ymin = .pred_lower,\n             ymax = .pred_upper)) +\n  geom_point(alpha = 0.25,\n             size = 2.5,\n             color = \"midnightblue\") +\n  geom_errorbar(alpha = 0.25,\n                color = \"midnightblue\",\n                width = 0.0125) +\n  scale_x_log10(labels = scales::label_dollar(scale_cut = cut_short_scale())) +\n  scale_y_log10(labels = scales::label_dollar(scale_cut = cut_short_scale())) +\n  geom_abline(linetype = \"dashed\",\n              size = 1,\n              color = \"gray\") +\n  labs(title = \"Predicted sale price of home in Sacramento\",\n       subtitle = \"Using many resamples allows us to generate prediction intervals\",\n       x = \"Predicted price\",\n       y = \"Actual price\")\n\n\n\n\n\nThis methodology produces prediction distributions that are consistent with what we might expect from linear models while making no assumptions about model type (i.e., we can use a non-parametric model; in this case, a k-nearest neighbors regression).\n\n\n\n\nCitationBibTeX citation:@online{rieke2022,\n  author = {Mark Rieke},\n  title = {The {Math} {Behind} Workboots},\n  date = {2022-07-05},\n  url = {https://www.thedatadiary.net/posts/2022-07-05-the-math-behind-workboots},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2022. “The Math Behind Workboots.” July 5,\n2022. https://www.thedatadiary.net/posts/2022-07-05-the-math-behind-workboots."
  },
  {
    "objectID": "posts/2022-07-24-introducing-nplyr/index.html",
    "href": "posts/2022-07-24-introducing-nplyr/index.html",
    "title": "Introducing {nplyr}",
    "section": "",
    "text": "Data manipulation and transformation is a fundamental part of any analysis. There are excellent tools in the R ecosystem for manipulating data frames (dplyr, data.table, and arrow, to name a few). Sometimes, however, it is desirable to work with nested data frames, for which few tools are readily available.\nThis is where nplyr comes into play! nplyr is a grammar of nested data manipulation that allows users to perform dplyr-like manipulations on data frames nested within a list-col of another data frame. Most dplyr verbs have nested equivalents in nplyr. For example:\n\nnest_mutate() is the nested equivalent of mutate()\nnest_select() is the nested equivalent of select()\nnest_filter() is the nested equivalent of filter()\nnest_summarise() is the nested equivalent of summarise()\nnest_group_by() is the nested equivalent of group_by()\n\n\nInstallation\nnplyr 0.1.0 is available on CRAN. Alternatively, you can install the development version from github with the devtools or remotes package:\n\n\nCode\n# install from CRAN\ninstall.packages(\"nplyr\")\n\n# install from github\ndevtools::install_github(\"markjrieke/nplyr\")\n\n\n\n\nUsage\nTo get started, we’ll create a nested column for the country data within each continent from the gapminder dataset.\n\n\nCode\nlibrary(nplyr)\n\ngm_nest <-\n  gapminder::gapminder_unfiltered %>%\n  tidyr::nest(country_data = -continent)\n\ngm_nest\n\n\n#> # A tibble: 6 × 2\n#>   continent country_data        \n#>   <fct>     <list>              \n#> 1 Asia      <tibble [578 × 5]>  \n#> 2 Europe    <tibble [1,302 × 5]>\n#> 3 Africa    <tibble [637 × 5]>  \n#> 4 Americas  <tibble [470 × 5]>  \n#> 5 FSU       <tibble [139 × 5]>  \n#> 6 Oceania   <tibble [187 × 5]>\n\n\ndplyr can perform operations on the top-level data frame, but with nplyr, we can perform operations on the nested data frames:\n\n\nCode\ngm_nest_example <-\n  gm_nest %>%\n  nest_filter(country_data, year == max(year)) %>%\n  nest_mutate(country_data, pop_millions = pop/1000000)\n\n# each nested tibble is now filtered to the most recent year\ngm_nest_example\n\n\n#> # A tibble: 6 × 2\n#>   continent country_data     \n#>   <fct>     <list>           \n#> 1 Asia      <tibble [43 × 6]>\n#> 2 Europe    <tibble [34 × 6]>\n#> 3 Africa    <tibble [53 × 6]>\n#> 4 Americas  <tibble [33 × 6]>\n#> 5 FSU       <tibble [9 × 6]> \n#> 6 Oceania   <tibble [11 × 6]>\n\n\nCode\n# if we unnest, we can see that a new column for pop_millions has been created\ngm_nest_example %>%\n  slice_head(n = 1) %>%\n  tidyr::unnest(country_data)\n\n\n#> # A tibble: 43 × 7\n#>    continent country           year lifeExp        pop gdpPercap pop_millions\n#>    <fct>     <fct>            <int>   <dbl>      <int>     <dbl>        <dbl>\n#>  1 Asia      Afghanistan       2007    43.8   31889923      975.       31.9  \n#>  2 Asia      Azerbaijan        2007    67.5    8017309     7709.        8.02 \n#>  3 Asia      Bahrain           2007    75.6     708573    29796.        0.709\n#>  4 Asia      Bangladesh        2007    64.1  150448339     1391.      150.   \n#>  5 Asia      Bhutan            2007    65.6    2327849     4745.        2.33 \n#>  6 Asia      Brunei            2007    77.1     386511    48015.        0.387\n#>  7 Asia      Cambodia          2007    59.7   14131858     1714.       14.1  \n#>  8 Asia      China             2007    73.0 1318683096     4959.     1319.   \n#>  9 Asia      Hong Kong, China  2007    82.2    6980412    39725.        6.98 \n#> 10 Asia      India             2007    64.7 1110396331     2452.     1110.   \n#> # … with 33 more rows\n\n\nnplyr also supports grouped operations with nest_group_by():\n\n\nCode\ngm_nest_example <-\n  gm_nest %>%\n  nest_group_by(country_data, year) %>%\n  nest_summarise(\n    country_data,\n    n = n(),\n    lifeExp = median(lifeExp),\n    pop = median(pop),\n    gdpPercap = median(gdpPercap)\n  )\n\ngm_nest_example\n\n\n#> # A tibble: 6 × 2\n#>   continent country_data     \n#>   <fct>     <list>           \n#> 1 Asia      <tibble [58 × 5]>\n#> 2 Europe    <tibble [58 × 5]>\n#> 3 Africa    <tibble [13 × 5]>\n#> 4 Americas  <tibble [57 × 5]>\n#> 5 FSU       <tibble [44 × 5]>\n#> 6 Oceania   <tibble [56 × 5]>\n\n\nCode\n# unnesting shows summarised tibbles for each continent\ngm_nest_example %>%\n  slice(2) %>%\n  tidyr::unnest(country_data)\n\n\n#> # A tibble: 58 × 6\n#>    continent  year     n lifeExp      pop gdpPercap\n#>    <fct>     <int> <int>   <dbl>    <dbl>     <dbl>\n#>  1 Europe     1950    22    65.8 7408264      6343.\n#>  2 Europe     1951    18    65.7 7165515      6509.\n#>  3 Europe     1952    31    65.9 7124673      5210.\n#>  4 Europe     1953    17    67.3 7346100      6774.\n#>  5 Europe     1954    17    68.0 7423300      7046.\n#>  6 Europe     1955    17    68.5 7499400      7817.\n#>  7 Europe     1956    17    68.5 7575800      8224.\n#>  8 Europe     1957    31    67.5 7363802      6093.\n#>  9 Europe     1958    18    69.6 8308052.     8833.\n#> 10 Europe     1959    18    69.6 8379664.     9088.\n#> # … with 48 more rows\n\n\n\n\nOther use cases\nIn the previous set of examples, the output from nplyr’s nested operations could be obtained by unnesting and performing grouped dplyr operations.\n\n\nCode\n# we can use nplyr to perform operations on the nested data\ngm_nest %>%\n  nest_filter(country_data, year == max(year)) %>%\n  nest_mutate(country_data, pop_millions = pop/1000000) %>%\n  slice_head(n = 1) %>%\n  tidyr::unnest(country_data)\n\n\n#> # A tibble: 43 × 7\n#>    continent country           year lifeExp        pop gdpPercap pop_millions\n#>    <fct>     <fct>            <int>   <dbl>      <int>     <dbl>        <dbl>\n#>  1 Asia      Afghanistan       2007    43.8   31889923      975.       31.9  \n#>  2 Asia      Azerbaijan        2007    67.5    8017309     7709.        8.02 \n#>  3 Asia      Bahrain           2007    75.6     708573    29796.        0.709\n#>  4 Asia      Bangladesh        2007    64.1  150448339     1391.      150.   \n#>  5 Asia      Bhutan            2007    65.6    2327849     4745.        2.33 \n#>  6 Asia      Brunei            2007    77.1     386511    48015.        0.387\n#>  7 Asia      Cambodia          2007    59.7   14131858     1714.       14.1  \n#>  8 Asia      China             2007    73.0 1318683096     4959.     1319.   \n#>  9 Asia      Hong Kong, China  2007    82.2    6980412    39725.        6.98 \n#> 10 Asia      India             2007    64.7 1110396331     2452.     1110.   \n#> # … with 33 more rows\n\n\nCode\n# in this case, we could have obtained the same result with tidyr and dplyr\ngm_nest %>%\n  tidyr::unnest(country_data) %>%\n  group_by(continent) %>%\n  filter(year == max(year)) %>%\n  mutate(pop_millions = pop/1000000) %>%\n  ungroup() %>%\n  filter(continent == \"Asia\")\n\n\n#> # A tibble: 43 × 7\n#>    continent country           year lifeExp        pop gdpPercap pop_millions\n#>    <fct>     <fct>            <int>   <dbl>      <int>     <dbl>        <dbl>\n#>  1 Asia      Afghanistan       2007    43.8   31889923      975.       31.9  \n#>  2 Asia      Azerbaijan        2007    67.5    8017309     7709.        8.02 \n#>  3 Asia      Bahrain           2007    75.6     708573    29796.        0.709\n#>  4 Asia      Bangladesh        2007    64.1  150448339     1391.      150.   \n#>  5 Asia      Bhutan            2007    65.6    2327849     4745.        2.33 \n#>  6 Asia      Brunei            2007    77.1     386511    48015.        0.387\n#>  7 Asia      Cambodia          2007    59.7   14131858     1714.       14.1  \n#>  8 Asia      China             2007    73.0 1318683096     4959.     1319.   \n#>  9 Asia      Hong Kong, China  2007    82.2    6980412    39725.        6.98 \n#> 10 Asia      India             2007    64.7 1110396331     2452.     1110.   \n#> # … with 33 more rows\n\n\nWhy, then, might we need to use nplyr? Well, in other scenarios, it may be far more convenient to work with nested data frames or it may not even be possible to unnest!\nConsider a set of surveys that an organization might use to gather market data. It is common for organization to have separate surveys for separate purposes but to gather the same baseline set of data across all surveys (for example , a respondent’s age and gender may be recorded across all surveys, but each survey will have a different set of questions). Let’s use two fake surveys with the below questions for this example:\n\nSurvey 1: Job\n\nHow old are you? (multiple choice)\nWhat city do you live in? (multiple choice)\nWhat field do you work in? (multiple choice)\nOverall, how satisfied are you with your job? (multiple choice)\nWhat is your annual salary? (numeric entry)\n\n\n\nSurvey 2: Personal Life\n\nHow old are you? (multiple choice)\nWhat city do you live in? (multiple choice)\nWhat field do you work in? (mulitple choice)\nOverall, how satisfied are you with your personal life (multiple choice)\nPlease provide any additional detail (text entry)\n\nIn this scenario, both surveys are collecting demographic information — age, location, and industry — but differ in the remaining questions. A convenient way to get the response files into the environment would be to use purrr::map() to read each file to a nested data frame.\n\n\nCode\npath <- \"https://raw.githubusercontent.com/markjrieke/nplyr/main/data-raw/\"\n\nsurveys <- \n  tibble::tibble(survey_file = c(\"job_survey\", \"personal_survey\")) %>%\n  mutate(survey_data = purrr::map(survey_file, ~readr::read_csv(paste0(path, .x, \".csv\"))))\n\nsurveys\n\n\n#> # A tibble: 2 × 2\n#>   survey_file     survey_data         \n#>   <chr>           <list>              \n#> 1 job_survey      <spc_tbl_ [500 × 6]>\n#> 2 personal_survey <spc_tbl_ [750 × 6]>\n\n\ntidyr::unnest() can usually handle idiosyncracies in layout when unnesting, but in this case unnesting throws an error!\n\n\nCode\nsurveys %>%\n  tidyr::unnest(survey_data)\n\n\n#> Error in `list_unchop()`:\n#> ! Can't combine `x[[1]]$Q5` <double> and `x[[2]]$Q5` <character>.\n\n\nThis is because the surveys share column names but not necessarily column types! In this case, both data frames contain a column named Q5, but in job_survey it’s a double and in personal_survey it’s a character.\n\n\nCode\nsurveys %>%\n  slice(1) %>%\n  tidyr::unnest(survey_data) %>%\n  glimpse()\n\n\n#> Rows: 500\n#> Columns: 7\n#> $ survey_file <chr> \"job_survey\", \"job_survey\", \"job_survey\", \"job_survey\", \"j…\n#> $ survey_name <chr> \"job\", \"job\", \"job\", \"job\", \"job\", \"job\", \"job\", \"job\", \"j…\n#> $ Q1          <dbl> 100, 81, 51, 81, 80, 32, 65, 57, 43, 94, 25, 83, 61, 66, 8…\n#> $ Q2          <chr> \"Austin\", \"San Antonio\", \"Austin\", \"Austin\", \"Dallas\", \"Fo…\n#> $ Q3          <chr> \"Consulting\", \"Consulting\", \"Consulting\", \"Technology\", \"C…\n#> $ Q4          <chr> \"Somewhat dissatisfied\", \"Neither satisfied nor dissatisfi…\n#> $ Q5          <dbl> 163, 48, 190, 25, 143, 233, 43, 243, 158, 235, 245, 195, 2…\n\n\nCode\nsurveys %>%\n  slice(2) %>%\n  tidyr::unnest(survey_data) %>%\n  glimpse()\n\n\n#> Rows: 750\n#> Columns: 7\n#> $ survey_file <chr> \"personal_survey\", \"personal_survey\", \"personal_survey\", \"…\n#> $ survey_name <chr> \"personal\", \"personal\", \"personal\", \"personal\", \"personal\"…\n#> $ Q1          <dbl> 91, 32, 40, 23, 88, 69, 96, 40, 57, 40, 39, 70, 29, 38, 57…\n#> $ Q2          <chr> \"Austin\", \"San Antonio\", \"San Antonio\", \"Austin\", \"Dallas\"…\n#> $ Q3          <chr> \"Energy\", \"Healthcare\", \"Consulting\", \"Consulting\", \"Techn…\n#> $ Q4          <chr> \"Neither satisfied nor dissatisfied\", \"Extremely satisfied…\n#> $ Q5          <chr> \"Blandit eros! A, ligula facilisis imperdiet! Interdum pla…\n\n\nWe could potentially get around this issue with unnesting by reading in all columns as characters via readr::read_csv(x, col_types = cols(.default = \"c\")), but this presents its own challenges. Q5 would still be better represented as a double in job_survey and, from the survey question text, Q4 has similar, but distinctly different, meanings across the survey files.\nThis is where nplyr can assist! Rather than malign the data types or create separate objects for each survey file, we can use nplyr to perform operations directly on the nested data frames.\n\n\nCode\nsurveys <- \n  surveys %>%\n  nest_mutate(survey_data,\n              age_group = if_else(Q1 < 65, \"Adult\", \"Retirement Age\")) %>%\n  nest_group_by(survey_data, Q3) %>%\n  nest_add_count(survey_data, \n                 name = \"n_respondents_in_industry\") %>%\n  nest_mutate(survey_data, \n              median_industry_age = median(Q1)) %>%\n  nest_ungroup(survey_data)\n\nsurveys %>%\n  slice(1) %>%\n  tidyr::unnest(survey_data)\n\n\n#> # A tibble: 500 × 10\n#>    survey_file survey_name    Q1 Q2    Q3    Q4       Q5 age_g…¹ n_res…² media…³\n#>    <chr>       <chr>       <dbl> <chr> <chr> <chr> <dbl> <chr>     <int>   <dbl>\n#>  1 job_survey  job           100 Aust… Cons… Some…   163 Retire…     107    57  \n#>  2 job_survey  job            81 San … Cons… Neit…    48 Retire…     107    57  \n#>  3 job_survey  job            51 Aust… Cons… Extr…   190 Adult       107    57  \n#>  4 job_survey  job            81 Aust… Tech… Extr…    25 Retire…     108    61.5\n#>  5 job_survey  job            80 Dall… Cons… Extr…   143 Retire…     107    57  \n#>  6 job_survey  job            32 Fort… Ener… Some…   233 Adult        99    59  \n#>  7 job_survey  job            65 Dall… Cons… Some…    43 Retire…     107    57  \n#>  8 job_survey  job            57 Hous… Heal… Some…   243 Adult        75    65  \n#>  9 job_survey  job            43 Dall… Gove… Neit…   158 Adult       111    57  \n#> 10 job_survey  job            94 Fort… Heal… Extr…   235 Retire…      75    65  \n#> # … with 490 more rows, and abbreviated variable names ¹​age_group,\n#> #   ²​n_respondents_in_industry, ³​median_industry_age\n\n\nCode\nsurveys %>%\n  slice(2) %>%\n  tidyr::unnest(survey_data)\n\n\n#> # A tibble: 750 × 10\n#>    survey_file     surve…¹    Q1 Q2    Q3    Q4    Q5    age_g…² n_res…³ media…⁴\n#>    <chr>           <chr>   <dbl> <chr> <chr> <chr> <chr> <chr>     <int>   <dbl>\n#>  1 personal_survey person…    91 Aust… Ener… Neit… Blan… Retire…     145      61\n#>  2 personal_survey person…    32 San … Heal… Extr… Elem… Adult       131      62\n#>  3 personal_survey person…    40 San … Cons… Some… Eget… Adult       149      61\n#>  4 personal_survey person…    23 Aust… Cons… Extr… Scel… Adult       149      61\n#>  5 personal_survey person…    88 Dall… Tech… Neit… Aene… Retire…     150      61\n#>  6 personal_survey person…    69 Fort… Tech… Neit… Inte… Retire…     150      61\n#>  7 personal_survey person…    96 Hous… Heal… Extr… Blan… Retire…     131      62\n#>  8 personal_survey person…    40 Hous… Cons… Extr… Scel… Adult       149      61\n#>  9 personal_survey person…    57 Fort… Ener… Extr… Pede… Adult       145      61\n#> 10 personal_survey person…    40 Fort… Heal… Extr… Phar… Adult       131      62\n#> # … with 740 more rows, and abbreviated variable names ¹​survey_name,\n#> #   ²​age_group, ³​n_respondents_in_industry, ⁴​median_industry_age\n\n\n\n\n\n\n\nCitationBibTeX citation:@online{rieke2022,\n  author = {Mark Rieke},\n  title = {Introducing \\{Nplyr\\}},\n  date = {2022-07-24},\n  url = {https://www.thedatadiary.net/posts/2022-07-24-introducing-nplyr},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2022. “Introducing {Nplyr}.” July 24, 2022. https://www.thedatadiary.net/posts/2022-07-24-introducing-nplyr."
  },
  {
    "objectID": "posts/2022-08-20-finding-new-wedding-bops-with-tidyclust-and-spotifyr/index.html",
    "href": "posts/2022-08-20-finding-new-wedding-bops-with-tidyclust-and-spotifyr/index.html",
    "title": "Finding new wedding bops with {tidyclust} and {spotifyr}",
    "section": "",
    "text": "Code\nsysfonts::font_add_google(\"Roboto Slab\")\nshowtext::showtext_auto()\n\nggplot2::theme_set(\n  ggplot2::theme_minimal(base_family = \"Roboto Slab\", \n                         base_size = 14) +\n    ggplot2::theme(plot.title.position = \"plot\",\n                   plot.background = ggplot2::element_rect(fill = \"white\", color = \"white\"),\n                   plot.title = ggtext::element_markdown(),\n                   plot.subtitle = ggtext::element_markdown())\n)\nLast November, I (finally) popped the big question and proposed! Since then, my fiance and I have been diligently planning our wedding. While we have most of the big-ticket items checked off (venue, catering, photography, etc.), one area we still have more work to do is on the wedding playlist. We’ve started putting together a playlist on spotify, but it feels like it’s come to a bit of a stand-still. Currently, there’s a mix of zesty bops and tame songs on the playlist (we need to accommodate both our college friends and our grandparents!), but spotify’s track recommender only wants to suggest tamer songs right now. Our goal is to have a full dance floor the entire night — to achieve this, we can use spotifyr and the new tidyclust package to pull in the current playlist, cluster the songs based on their features, and find new songs based on the bop cluster.\nIf you’d like to follow along, I’d recommend installing the development versions of parsnip and workflows, as some of the functionality that interacts with tidyclust isn’t yet on CRAN."
  },
  {
    "objectID": "posts/2022-08-20-finding-new-wedding-bops-with-tidyclust-and-spotifyr/index.html#pulling-in-the-playlist",
    "href": "posts/2022-08-20-finding-new-wedding-bops-with-tidyclust-and-spotifyr/index.html#pulling-in-the-playlist",
    "title": "Finding new wedding bops with {tidyclust} and {spotifyr}",
    "section": "Pulling in the playlist",
    "text": "Pulling in the playlist\nspotifyr is an R interface to spotify’s web API and gives access to a host of track features (you can follow this tutorial to get it setup). I’ll use the functions get_user_playlists() and get_playlist_tracks() to pull in songs that are currently on our wedding playlist (appropriately named “Ding dong”).\n\n\nCode\n# get the songs that are currently on the wedding playlist\nding_dong <- \n  get_user_playlists(\"12130039175\") %>%\n  filter(name == \"Ding dong\") %>%\n  pull(id) %>%\n  get_playlist_tracks() %>% \n  as_tibble() %>%\n  select(track.id, track.name, track.popularity) %>%\n  rename_with(~stringr::str_replace(.x, \"\\\\.\", \"_\"))\n\nding_dong %>%\n  slice_head(n = 10) %>%\n  knitr::kable()\n\n\n\n\n\n\n\n\n\n\ntrack_id\ntrack_name\ntrack_popularity\n\n\n\n\n5jkFvD4UJrmdoezzT1FRoP\nRasputin\n61\n\n\n1D066zixBwqFYqBhKgdPzp\nFergalicious\n66\n\n\n12jjuxN1gxlm29cqL5M6MW\nI Got You\n62\n\n\n2grjqo0Frpf2okIBiifQKs\nSeptember\n78\n\n\n2RlgNHKcydI9sayD2Df2xp\nMr. Blue Sky\n76\n\n\n6x4tKaOzfNJpEJHySoiJcs\nMambo No. 5 (a Little Bit of…)\n72\n\n\n3n3Ppam7vgaVa1iaRUc9Lp\nMr. Brightside\n62\n\n\n7Cp69rNBwU0gaFT8zxExlE\nYmca\n45\n\n\n3Gf5nttwcX9aaSQXRWidEZ\nRide Wit Me\n72\n\n\n3wMUvT6eIw2L5cZFG1yH9j\nCountry Grammar (Hot Shit)\n65\n\n\n\n\n\nSpotify estimates quite a few features for each song in their catalog: speechiness (the presence of words on a track), acousticness (whether or not a song includes acoustic instruments), liveness (estimates whether or not the track is live or studio-recorded), etc. We can use get_track_audio_features() to get the features for each song based on its track_id.\n\n\nCode\n# pull in track features of songs on the playlist\ntrack_features <- \n  ding_dong %>%\n  pull(track_id) %>%\n  get_track_audio_features()\n\n# join together\nding_dong <- \n  ding_dong %>%\n  left_join(track_features, by = c(\"track_id\" = \"id\"))\n\n\nIn my case, I’m interested in the energy and valence (positivity) of each song, so I’ll select these variables to use in the cluster analysis.\n\n\nCode\nding_dong %>%\n  select(track_name, valence, energy) %>%\n  slice_head(n = 10) %>%\n  knitr::kable()\n\n\n\n\n\ntrack_name\nvalence\nenergy\n\n\n\n\nRasputin\n0.966\n0.893\n\n\nFergalicious\n0.829\n0.583\n\n\nI Got You\n0.544\n0.399\n\n\nSeptember\n0.979\n0.832\n\n\nMr. Blue Sky\n0.478\n0.338\n\n\nMambo No. 5 (a Little Bit of…)\n0.892\n0.807\n\n\nMr. Brightside\n0.240\n0.918\n\n\nYmca\n0.671\n0.951\n\n\nRide Wit Me\n0.722\n0.700\n\n\nCountry Grammar (Hot Shit)\n0.565\n0.664"
  },
  {
    "objectID": "posts/2022-08-20-finding-new-wedding-bops-with-tidyclust-and-spotifyr/index.html#clustering-with-tidyclust",
    "href": "posts/2022-08-20-finding-new-wedding-bops-with-tidyclust-and-spotifyr/index.html#clustering-with-tidyclust",
    "title": "Finding new wedding bops with {tidyclust} and {spotifyr}",
    "section": "Clustering with tidyclust",
    "text": "Clustering with tidyclust\nCurrently, the playlist covers a wide spectrum of songs. For new songs on the playlist, I’m really just interested in songs similar to others in the top right corner of the below chart with high energy and valence.\n\n\nCode\n# how are valence/energy related?\nobj <- \n  ding_dong %>%\n  ggplot(aes(x = valence,\n             y = energy,\n             tooltip = track_name)) + \n  ggiraph::geom_point_interactive(size = 3.5, alpha = 0.5) +\n  scale_x_continuous(labels = scales::label_percent(accuracy = 1)) +\n  scale_y_continuous(labels = scales::label_percent(accuracy = 1)) +\n  labs(title = \"The current wedding playlist\",\n       subtitle = \"Hover over each point to see the song's name!\")\n\nggiraph::girafe(\n  ggobj = obj,\n  options = list(\n    ggiraph::opts_tooltip(opacity = 0.8,\n                          css = \"background-color:gray;color:white;padding:2px;border-radius:2px;font-family:Roboto Slab;\"),\n    ggiraph::opts_hover(css = \"fill:#1279BF;stroke:#1279BF;cursor:pointer;\")\n  )\n)\n\n\n\n\n\n\nBroadly, there are three generic categories that the songs on the current playlist fall into: high energy and valence, low energy, or low valence (songs with low energy and valence will fall into one of the “low” categories). Rather than manually assign categories, we can use tidyclust to cluster the songs into three groups using the kmeans algorithm.\nThere’s some great documentation on the tidyclust site, but to get started, we’ll categorize the songs on the current playlist by “fitting” a kmeans model (using the stats engine under the hood).\n\n\nCode\n# create a clustering obj\nset.seed(918)\nding_dong_clusters <- \n  k_means(num_clusters = 3) %>%\n  fit(~ valence + energy,\n      data = ding_dong) \n\n\n\n\nCode\npal <- MetBrewer::MetPalettes$Egypt[[1]]\n\nobj <- \n  ding_dong_clusters %>%\n  augment(ding_dong) %>%\n  ggplot(aes(x = valence,\n             y = energy,\n             color = .pred_cluster,\n             tooltip = track_name)) +\n  ggiraph::geom_point_interactive(size = 3.5, alpha = 0.75) +\n  scale_x_continuous(labels = scales::label_percent(accuracy = 1)) +\n  scale_y_continuous(labels = scales::label_percent(accuarcy = 1)) +\n  theme(legend.position = \"none\") +\n  labs(title = \"Clusters in the current playlist\",\n       subtitle = glue::glue(\"Clustered into\",\n                             \"**{riekelib::color_text('zesty bops',pal[1])}**,\",\n                             \"**{riekelib::color_text('angsty bangers', pal[3])}**,\",\n                             \"and\",\n                             \"**{riekelib::color_text('mellow jams', pal[2])}**\",\n                             .sep = \" \")) +\n  MetBrewer::scale_color_met_d(\"Egypt\")\n\nggiraph::girafe(\n  ggobj = obj,\n  options = list(\n    ggiraph::opts_tooltip(opacity = 0.8,\n                          use_fill = TRUE,\n                          css = \"color:white;padding:2px;border-radius:2px;font-family:Roboto Slab;\"),\n    ggiraph::opts_hover(css = \"fill:#1279BF;stroke:#1279BF;cursor:pointer;\")\n  )\n)\n\n\n\n\n\n\nAs expected, the majority of songs in the current playlist fall into the bop cluster. Let’s explore this cluster using in more detail with the custom metric vibe.\n\n\nCode\n# assign to clusters\nding_dong_vibes <- \n  ding_dong_clusters %>%\n  augment(ding_dong) %>%\n  select(track_name,\n         valence, \n         energy, \n         .pred_cluster) %>%\n  mutate(vibe = valence + energy)\n\n# what are songs with the biggest vibe?\nding_dong_vibes %>%\n  arrange(desc(vibe)) %>%\n  slice_head(n = 10) %>%\n  knitr::kable()\n\n\n\n\n\n\n\n\n\n\n\n\ntrack_name\nvalence\nenergy\n.pred_cluster\nvibe\n\n\n\n\nHey Ya!\n0.965\n0.974\nCluster_1\n1.939\n\n\nRasputin\n0.966\n0.893\nCluster_1\n1.859\n\n\nSeptember\n0.979\n0.832\nCluster_1\n1.811\n\n\nShe Bangs - English Version\n0.858\n0.950\nCluster_1\n1.808\n\n\nTake on Me\n0.876\n0.902\nCluster_1\n1.778\n\n\nThe Legend of Chavo Guerrero\n0.913\n0.858\nCluster_1\n1.771\n\n\nCan’t Hold Us (feat. Ray Dalton)\n0.847\n0.922\nCluster_1\n1.769\n\n\nToxic\n0.924\n0.838\nCluster_1\n1.762\n\n\nTimber (feat. Ke$ha)\n0.788\n0.963\nCluster_1\n1.751\n\n\nShake It Off\n0.942\n0.800\nCluster_1\n1.742\n\n\n\n\n\nAs expected, when arranging by vibe, the top songs are all a part of the first cluster. And they are, indeed, a vibe:\n\nCompare that with the second cluster, which are generally lower energy (I’d personally disagree with spotify ranking Mr. Blue Sky and Single Ladies as “low energy,” but most others make sense).\n\n\nCode\nding_dong_vibes %>%\n  filter(.pred_cluster == \"Cluster_2\") %>%\n  arrange(vibe) %>%\n  slice_head(n = 10) %>%\n  knitr::kable()\n\n\n\n\n\n\n\n\n\n\n\n\ntrack_name\nvalence\nenergy\n.pred_cluster\nvibe\n\n\n\n\nMr. Blue Sky\n0.478\n0.338\nCluster_2\n0.816\n\n\nSingle Ladies (Put a Ring on It)\n0.272\n0.584\nCluster_2\n0.856\n\n\nLow (feat. T-Pain)\n0.304\n0.609\nCluster_2\n0.913\n\n\nI Got You\n0.544\n0.399\nCluster_2\n0.943\n\n\nWake Up in the Sky\n0.367\n0.578\nCluster_2\n0.945\n\n\nSummer, Highland Falls - Live at the Bayou, Washington, D.C. - July 1980\n0.452\n0.544\nCluster_2\n0.996\n\n\nGimme! Gimme! Gimme! (A Man After Midnight)\n0.536\n0.491\nCluster_2\n1.027\n\n\nWagon Wheel\n0.634\n0.403\nCluster_2\n1.037\n\n\nHung Up\n0.405\n0.647\nCluster_2\n1.052\n\n\nTake Me Out\n0.527\n0.663\nCluster_2\n1.190\n\n\n\n\n\n\nFinally, the third cluster mostly contains songs with low valence but relatively high energy.\n\n\nCode\nding_dong_vibes %>%\n  filter(.pred_cluster == \"Cluster_3\") %>%\n  arrange(vibe) %>%\n  slice_head(n = 10) %>%\n  knitr::kable()\n\n\n\n\n\ntrack_name\nvalence\nenergy\n.pred_cluster\nvibe\n\n\n\n\nClarity\n0.176\n0.781\nCluster_3\n0.957\n\n\nLove Story\n0.296\n0.741\nCluster_3\n1.037\n\n\nTitanium (feat. Sia)\n0.301\n0.787\nCluster_3\n1.088\n\n\nMr. Brightside\n0.240\n0.918\nCluster_3\n1.158\n\n\nAll Night (feat. Knox Fortune)\n0.392\n0.777\nCluster_3\n1.169\n\n\nTurn to Stone\n0.458\n0.720\nCluster_3\n1.178\n\n\nBody\n0.469\n0.732\nCluster_3\n1.201\n\n\nForever\n0.445\n0.819\nCluster_3\n1.264\n\n\nShout, Pts. 1 & 2\n0.416\n0.866\nCluster_3\n1.282\n\n\nThe Spins\n0.550\n0.766\nCluster_3\n1.316\n\n\n\n\n\n\nNow that I have the songs in the current playlist sorted by cluster, let’s pull in some new songs and assign them to the appropriate cluster!"
  },
  {
    "objectID": "posts/2022-08-20-finding-new-wedding-bops-with-tidyclust-and-spotifyr/index.html#adding-new-songs",
    "href": "posts/2022-08-20-finding-new-wedding-bops-with-tidyclust-and-spotifyr/index.html#adding-new-songs",
    "title": "Finding new wedding bops with {tidyclust} and {spotifyr}",
    "section": "Adding new songs",
    "text": "Adding new songs\nTo go searching for new songs, we’ll start by casting a wide net then narrow the search with some of the get_*() functions from spotifyr. I’ll start by using get_categories() to explore the categories available in spotify.\n\n\nCode\nget_categories() %>%\n  as_tibble() %>%\n  select(id, name) %>%\n  slice_head(n = 10) %>%\n  knitr::kable()\n\n\n\n\n\nid\nname\n\n\n\n\ntoplists\nTop Lists\n\n\n0JQ5DAqbMKFQ00XGBls6ym\nHip-Hop\n\n\n0JQ5DAqbMKFEC4WFtoNRpw\nPop\n\n\n0JQ5DAqbMKFKLfwjuJMoNC\nCountry\n\n\n0JQ5DAqbMKFxXaXKP7zcDp\nLatin\n\n\n0JQ5DAqbMKFDXXwE9BDJAr\nRock\n\n\n0JQ5DAqbMKFLVaM30PMBm4\nSummer\n\n\n0JQ5DAqbMKFAXlCG6QvYQ4\nWorkout\n\n\n0JQ5DAqbMKFEZPnFQSFB1T\nR&B\n\n\n0JQ5DAqbMKFHOzuVTgTizF\nDance/Electronic\n\n\n\n\n\nI don’t really want to play country music or R&B during the wedding, so I’ll filter to a few categories before using get_category_playlists() to pull in the featured playlists available in each category.\n\n\nCode\n# pull in playlist ids\nplaylists <- \n  get_categories() %>%\n  as_tibble() %>%\n  filter(id %in% c(\"toplists\", \"hiphop\", \"pop\", \"rock\", \"summer\")) %>%\n  pull(id) %>%\n  map_dfr(get_category_playlists) %>%\n  as_tibble() %>%\n  select(id, name, description) %>%\n  distinct(id, .keep_all = TRUE)\n\nplaylists %>%\n  slice_head(n = 10) %>%\n  knitr::kable()\n\n\n\n\n\n\n\n\n\n\nid\nname\ndescription\n\n\n\n\n37i9dQZF1DXcBWIGoYBM5M\nToday’s Top Hits\nThe Kid LAROI is on top of the Hottest 50!\n\n\n37i9dQZF1DX0XUsuxWHRQd\nRapCaviar\nNew music from GloRilla and NLE Choppa.\n\n\n37i9dQZF1DXcF6B6QPhFDv\nRock This\nYONAKA along with the biggest Rock songs you need to hear today!\n\n\n37i9dQZF1DX4dyzvuaRJ0n\nmint\nThe world’s biggest dance hits. Cover: Young Marco\n\n\n37i9dQZF1DX1lVhptIYRda\nHot Country\nToday’s top country hits of the week, worldwide! Cover: Elle King\n\n\n37i9dQZF1DX10zKzsJ2jva\nViva Latino\nToday’s top Latin hits, elevando nuestra música. Cover: KAROL G & Romeo Santos\n\n\n37i9dQZF1DX4SBhb3fqCJd\nAre & Be\nThe pulse of R&B music today. Cover: Ella Mai\n\n\n37i9dQZEVXbLRQDuF5jeBp\nTop 50 - USA\nYour daily update of the most played tracks right now - USA.\n\n\n37i9dQZEVXbMDoHDwVN2tF\nTop 50 - Global\nYour daily update of the most played tracks right now - Global.\n\n\n37i9dQZEVXbLiRSasKsNU9\nViral 50 - Global\nYour daily update of the most viral tracks right now - Global.\n\n\n\n\n\nThere’s a lot of playlists in playlists, so I’ve gone through and selected a few that I’m interested in exploring further.\n\n\nCode\nselected_playlists <-\n  c(\"Today's Top Hits\",\n    \"mint\",\n    \"Top 50 - US\",\n    \"Top 50 - Global\",\n    \"Viral 50 - US\",\n    \"Viral 50 - Global\",\n    \"New Music Friday\",\n    \"Most Necessary\",\n    \"Internet People\",\n    \"Gold School\",\n    \"Hot Hits USA\",\n    \"Pop Rising\",\n    \"teen beats\",\n    \"big on the internet\",\n    \"Party Hits\",\n    \"Mega Hit Mix\",\n    \"Pumped Pop\",\n    \"Hit Rewind\",\n    \"The Ultimate Hit Mix\",\n    \"00s Rock Anthems\",\n    \"Summer Hits\",\n    \"Barack Obama's Summer 2022 Playlist\",\n    \"Summer Hits of the 10s\",\n    \"Family Road Trip\")\n\n\nWith this shorter list of playlists, I can pull in the all the songs that appear on each with get_playlist_tracks(). Some songs may appear on multiple playlists, so we’ll only look at unique songs by track_id. I’ve already pulled in features for songs currently on the playlist, so we can filter those out as well. Finally, get_track_audio_features() limits queries to a maximum of 100 songs, so we’ll select the top 100 most popular songs within the sample.\n\n\nCode\nnew_songs <- \n  playlists %>%\n  filter(name %in% selected_playlists) %>%\n  pull(id) %>%\n  map_dfr(get_playlist_tracks) %>%\n  as_tibble()\n\nnew_songs <- \n  new_songs %>%\n  select(track.id,\n         track.name,\n         track.popularity) %>%\n  rename_with(~stringr::str_replace(.x, \"\\\\.\", \"_\")) %>%\n  distinct(track_id, .keep_all = TRUE) %>%\n  arrange(desc(track_popularity)) %>%\n  filter(!track_id %in% ding_dong$track_id) %>%\n  slice_head(n = 100)\n\nnew_songs %>%\n  slice_head(n = 10) %>%\n  knitr::kable()\n\n\n\n\n\n\n\n\n\n\ntrack_id\ntrack_name\ntrack_popularity\n\n\n\n\n0yLdNVWF3Srea0uzk55zFn\nFlowers\n100\n\n\n4nrPB8O7Y7wsOCJdgXkthe\nShakira: Bzrp Music Sessions, Vol. 53\n96\n\n\n2dHHgzDwk4BJdRwy9uXhTO\nCreepin’ (with The Weeknd & 21 Savage)\n94\n\n\n3nqQXoyQOWXiESFLlDF1hG\nUnholy (feat. Kim Petras)\n93\n\n\n4uUG5RXrOk84mYEfFvj3cK\nI’m Good (Blue)\n93\n\n\n5ww2BF9slyYgNOk37BlC4u\nLa Bachata\n93\n\n\n0V3wPSX9ygBnCm8psDIegu\nAnti-Hero\n92\n\n\n1Qrg8KqiBpW07V7PNxwwwL\nKill Bill\n91\n\n\n0WtM2NBVQNNJLh6scP13H8\nCalm Down (with Selena Gomez)\n91\n\n\n78Sw5GDo6AlGwTwanjXbGh\nHere With Me\n91\n\n\n\n\n\nNow let’s assign these 100 news songs to the clusters we found earlier based on their valence and energy!\n\n\nCode\nnew_song_features <- \n  new_songs %>%\n  pull(track_id) %>%\n  get_track_audio_features()\n\nnew_songs <- \n  new_songs %>%\n  left_join(new_song_features, by = c(\"track_id\" = \"id\"))\n\nnew_songs_clustered <- \n  ding_dong_clusters %>%\n  augment(new_songs) %>%\n  select(track_name,\n         valence,\n         energy,\n         .pred_cluster) %>%\n  mutate(vibe = valence + energy)\n\nobj <- \n  new_songs_clustered %>%\n  ggplot(aes(x = valence,\n             y = energy,\n             color = .pred_cluster,\n             tooltip = track_name)) +\n  ggiraph::geom_point_interactive(size = 3.5, alpha = 0.75) +\n  scale_x_continuous(labels = scales::label_percent(accuracy = 1)) +\n  scale_y_continuous(labels = scales::label_percent(accuarcy = 1)) + \n  theme(legend.position = \"none\") +\n  labs(title = \"New songs, same old clusters\",\n       subtitle = glue::glue(\"Clustered into\",\n                             \"**{riekelib::color_text('zesty bops',pal[1])}**,\",\n                             \"**{riekelib::color_text('angsty bangers', pal[3])}**,\",\n                             \"and\",\n                             \"**{riekelib::color_text('mellow jams', pal[2])}**\",\n                             .sep = \" \")) +\n  MetBrewer::scale_color_met_d(\"Egypt\")\n\nggiraph::girafe(\n  ggobj = obj,\n  options = list(\n    ggiraph::opts_tooltip(opacity = 0.8,\n                          use_fill = TRUE,\n                          css = \"color:white;padding:2px;border-radius:2px;font-family:Roboto Slab;\"),\n    ggiraph::opts_hover(css = \"fill:#1279BF;stroke:#1279BF;cursor:pointer;\")\n  )\n)\n\n\n\n\n\n\nNice! It looks like the new songs are far more broad than the original playlist, but we can look at just the songs in the first cluster with the biggest vibe.\n\n\nCode\nnew_songs_clustered %>%\n  filter(.pred_cluster == \"Cluster_1\") %>%\n  arrange(desc(vibe)) %>%\n  slice_head(n = 10) %>%\n  knitr::kable()\n\n\n\n\n\ntrack_name\nvalence\nenergy\n.pred_cluster\nvibe\n\n\n\n\nIn The Yuma (feat. Aatig)\n0.940\n0.891\nCluster_1\n1.831\n\n\nMERCHO\n0.962\n0.790\nCluster_1\n1.752\n\n\nZona De Perigo\n0.970\n0.767\nCluster_1\n1.737\n\n\nI’m Not Here To Make Friends\n0.838\n0.895\nCluster_1\n1.733\n\n\nPRC\n0.893\n0.826\nCluster_1\n1.719\n\n\nBoy’s a liar Pt. 2\n0.857\n0.809\nCluster_1\n1.666\n\n\nLate Night Talking\n0.901\n0.728\nCluster_1\n1.629\n\n\nI Ain’t Worried\n0.825\n0.797\nCluster_1\n1.622\n\n\nAll By Myself\n0.773\n0.848\nCluster_1\n1.621\n\n\nCalm Down (with Selena Gomez)\n0.802\n0.806\nCluster_1\n1.608\n\n\n\n\n\nNow for the true vibe check — do these songs belong on the playlist?\n\nOh hell yeah!\n\nThis analysis was originally done on Aug. 20th, 2022 — Spotify’s featured playlists and tracks change on on a regular basis and also are time dependent on unique user data. When remapping from blogdown to Quarto in February 2023, it’s likely that the songs mentioned in the text differ from the songs pulled in from Spotify’s API."
  },
  {
    "objectID": "posts/2022-09-16-forecast-launch/index.html",
    "href": "posts/2022-09-16-forecast-launch/index.html",
    "title": "Forecast Launch!",
    "section": "",
    "text": "For those who aren’t glued to electoral politics, Labor Day typically marks the beginning of election season. Primaries are settled, pollsters stop sampling all adults to prioritize likely voters, and campaigns kick into high-gear. Labor Day also marks the release of my 2022 midterm forecast:\nAt the time of this writing, Democrats are favored to keep the senate while Republicans are favored to flip the House:\nThe most up-to-date information for each chamber (as well as individual races) can be found on the respective pages for the Senate and House. There is also a forecast for each Governor’s race.\nIn this post, I’ll walk through how the model works and point out some of its shortcomings. I’ll cover the broad strokes here, but for those who are interested in digging into the source code, I’ve released the model publicly on github."
  },
  {
    "objectID": "posts/2022-09-16-forecast-launch/index.html#how-this-works",
    "href": "posts/2022-09-16-forecast-launch/index.html#how-this-works",
    "title": "Forecast Launch!",
    "section": "How this works",
    "text": "How this works\n\nFilter down candidates/races\nThe first step taken is to filter out non-competitive races and candidates. Non-competitive, used here, doesn’t mean “races that aren’t close” but instead means “races that literally don’t have any competition.” In each race, only the chances of the top democrat/republican (or independent that would caucus with one of the major parties) are modeled. In uncontested races or races between two members of the same party, the controlling party’s probability of winning is set to 100%.\n\nRemoving third parties and intra-party races allows us to model each candidate’s projected voteshare via a beta distribution, which is useful for modeling proportional data of binary outcomes.\n\n\n\nEstimate the polling average\nThe next step is to estimate the polling average in each race. For races with polls, this can be done directly, but most races (especially in the House), aren’t polled. For these races, the poll average is constructed from the generic congressional ballot (GCB) and the seat’s partisan voter index (PVI). For example, for a R+5 seat, if the GCB is at D+1 the seats poll average will be R+4.\n\nThe poll model is really simple, but does increase slightly with complexity as more polls come in/as election day draws nearer. When there are three or fewer polls, a simple average is used. When there are between 4 and 6 polls, a linear model is used (i.e., lm(pct ~ date)). When there are more than 6 polls, a loess model is used (loess(pct ~ date, span = span)). The span parameter is scaled by the number of days between the polling period and election day — as election day approaches, span moves from 1 to 0.75.\n\n\n\nTrain the model\nPolls are a great tool and the most reliable predictor, but not the only one! With the polling average in each seat, the model is trained to estimate the outcome based on polls, partisanship (via PVI), incumbency, and a blend of demographics.\n\n\nCode\n# here's the actual model itself!\n# estimate: poll average, \n# poll_bucket: has this race been polled, y/n?\n# incumbent: incumbent party - democrat/republican/neither?\nelections_model <-\n  gamlss(result ~ estimate * poll_bucket + pvi + incumbent + white + black + hispanic + aapi,\n         sigma.formula = ~ log10(num_polls + 2),\n         family = BE(),\n         data = elections_train)\n\n\n\n\nSimulate outcomes\nThe final step is to simulate! To do so, 10,000 possible voteshare outcomes are generated each day for each race. The probability of any candidate winning is simply the percentage of simulations where the candidate has the greater voteshare. Similarly, the probability that each party controls each chamber is simply the percentage of simulations where that party controls a majority of seats (though Democrats only need 50 seats for control of the Senate, as Vice-President Harris serves as the tie-breaking vote).\n\nIn each of the simulations, a bit of polling error is introduced. This introduced error is normally distributed around 0. There’s been quite a bit of debate recently regarding the direction of that error (some folks think we should assume polls are undercounting Republicans, given the errors in 2016 and 2020), but the consensus amongst the modeling at FiveThirtyEight and the Economist is to set the average polling bias to 0. Each prediction is a single draw from one of the 10,000 possible distributions — when aggregated for each candidate we can estimate the 80% quantile range for their expected voteshare."
  },
  {
    "objectID": "posts/2022-09-16-forecast-launch/index.html#model-shortcomings",
    "href": "posts/2022-09-16-forecast-launch/index.html#model-shortcomings",
    "title": "Forecast Launch!",
    "section": "Model shortcomings",
    "text": "Model shortcomings\nWhile I’d love to believe that my model is professional quality, the truth is that this is represents my best (amateur) attempt at putting together a forecast in my limited free time. Of the model’s shortcomings, the three most egregious (in my opinion) are listed below:\n\nThe poll model is probably too simple. I’d spent a lot of time putting together a custom poll models for the generic ballot average and presidential approval average, both of which are fairly complex and adjust for pollster bias, survey size, sample population, and recency. While these are good enough poll models on their own, they take quite a bit of time to update. Extending this out to all the races in the midterms would mean that daily updates may take hours, which is a non-starter. So instead, I’ve opted for the simpler poll aggregate described above. This simplicity means that it’s a bit jumpy and a bit too bullish on recent polls.\nThis is a “now-cast”. Some models allow poll averages to drift between the current day and election day via random walks. This model, however, doesn’t do so — the forecast can really be thought of as the chance each party has if elections were held today with the information available today.\nThis is neither a Bayesian, nor a hierarchical model. In this model, the poll average and voteshare forecast are actually two separate models — ideally, these should both be roped-up in an overarching Bayesian model since they are both part of the same data generation process. Furthermore, this model assumes that all races are fully independent, which is wrong. House races in Georgia, for example, are not independent from other house races in Georgia. Ideally, we’d partially pool information across different races — this model doesn’t do that.\n\nDespite all this, I believe this relatively simple model results in an overall directionally correct forecast — you should view it in concert with a host of other reputable forecasts (listed below). I’d encourage you to check back intermittently to see how the race for each chamber progresses!\n\nOther midterm forecasts\n\nFiveThirtyEight: Senate, House, Governor\nThe Economist: Senate, House\nDecision Desk HQ: Senate, House\nSplit Ticket: Senate, House, Governor\nJHK Forecasts: Senate, House\nRace to the WH: Senate, House, Governor\nCNalysis: Senate, House, Governor"
  },
  {
    "objectID": "posts/2022-11-14-hierarchical-hospitals/index.html",
    "href": "posts/2022-11-14-hierarchical-hospitals/index.html",
    "title": "Hierarchical Hospitals",
    "section": "",
    "text": "Code\nggplot2::theme_set(\n  ggplot2::theme_minimal(base_family = \"Roboto Slab\",\n                         base_size = 13) +\n    ggplot2::theme(plot.title.position = \"plot\",\n                   plot.background = ggplot2::element_rect(fill = \"white\", color = \"white\"),\n                   plot.title = ggtext::element_markdown(),\n                   plot.subtitle = ggtext::element_markdown(),\n                   plot.caption = ggtext::element_markdown(color = \"gray40\"))\n)"
  },
  {
    "objectID": "posts/2022-11-14-hierarchical-hospitals/index.html#hierarchical-hospitals",
    "href": "posts/2022-11-14-hierarchical-hospitals/index.html#hierarchical-hospitals",
    "title": "Hierarchical Hospitals",
    "section": "Hierarchical Hospitals",
    "text": "Hierarchical Hospitals\nIf the past year of working at a large hospital system has taught me one thing, it’s that hospitals are a Russian nesting doll of structure. Within the hospital system, there are several campuses. Within each campus, there are several service areas (inpatient, outpatient, emergency, day surgery, etc.). And finally, within each service area at each campus, there can be many individual hospital units.\nHaving worked with patient satisfaction data, I know that each of these levels contains useful information that may be beneficial to include in a model. Hospital A, for example, tends to receive better reviews than Hospital B, but within Hospital A the labor & delivery unit tends to receive better reviews than the intensive care unit. Including every single unit as a categorical predictor isn’t a great modeling choice, since information about each unit remains separate (no pooling). On the other hand, ignoring the nested structure lumps all data points together (complete pooling), implicitly making the assumption that the data is independent, which can generate misleading predictions!\nThis is where hierarchical models come into play! Hierarchical models offer a happy middle ground and allow for partial pooling of information between groups. This approach allows for information to be shared across groups while still treating each group as unique (this is a pretty simplistic summary of hierarchical models; for a more detailed introduction, see Chapter 15 of Bayes Rules!).\nWhile there are non-Bayesian approaches to hierarchical models, they mesh well with a Bayesian framework, so in this post I’ll build a Bayesian model to predict satisfaction scores based on simulated hospital data."
  },
  {
    "objectID": "posts/2022-11-14-hierarchical-hospitals/index.html#simulating-hospital-data",
    "href": "posts/2022-11-14-hierarchical-hospitals/index.html#simulating-hospital-data",
    "title": "Hierarchical Hospitals",
    "section": "Simulating Hospital Data",
    "text": "Simulating Hospital Data\nI can’t share live data, so I’ll need to simulate some fake data for this example. Let’s start with five hospitals, each with different baseline levels of satisfaction.\n\n\nCode\nlibrary(tidyverse)\nlibrary(rstanarm)\nlibrary(tidybayes)\nlibrary(ggdist)\nlibrary(tidytext)\n\n# reproducibility!\nset.seed(54321)\n\n# manually assign hospital-level intercept\nhospital_prob <- \n  tibble(hospital = paste(\"Hospital\", seq(1:5)),\n         hospital_prob = seq(from = 0.6, to = 0.8, length.out = 5) ,\n         hospital_sigma = rep(0.2, 5))\n\nhospital_prob %>%\n  knitr::kable()\n\n\n\n\n\nhospital\nhospital_prob\nhospital_sigma\n\n\n\n\nHospital 1\n0.60\n0.2\n\n\nHospital 2\n0.65\n0.2\n\n\nHospital 3\n0.70\n0.2\n\n\nHospital 4\n0.75\n0.2\n\n\nHospital 5\n0.80\n0.2\n\n\n\n\n\nIn this example, Hospital 1 will tend to have the lowest scores while Hospital 5 will tend to have the highest scores. Within each hospital, we want individual unit-level scores to be able to vary randomly.\n\n\nCode\n# simulate 5 hospitals within the system, each with 100 units (500 total)\nsatisfaction <- \n  tibble(hospital = rep(paste(\"Hospital\", seq(1:5)), 100)) %>%\n  arrange(hospital) %>%\n  \n  # add in the units at each hospital\n  bind_cols(unit = rep(paste(\"Unit\", seq(1:100)), 5)) %>%\n  mutate(unit = paste(hospital, unit)) %>%\n  \n  # add in the hospital-level intercept\n  left_join(hospital_prob, by = \"hospital\") %>%\n  \n  # estimate a unit-level intercept \n  rowwise() %>%\n  mutate(unit_offset = rnorm(1, 0, 0.05),\n         unit_prob = gamlss.dist::rBE(1, hospital_prob + unit_offset, hospital_sigma)) %>%\n  select(hospital, unit, unit_prob) %>%\n  \n  # generate fake responses\n  mutate(n = round(rlnorm(1, log(100), 1.5)),\n         topbox = rbinom(1, n, unit_prob)) %>%\n  ungroup() %>%\n  select(-unit_prob)\n\n# display example at each hospital\nset.seed(333)\nsatisfaction %>%\n  group_by(hospital) %>%\n  slice_sample(n = 1) %>%\n  mutate(score = topbox/n) %>%\n  knitr::kable()\n\n\n\n\n\nhospital\nunit\nn\ntopbox\nscore\n\n\n\n\nHospital 1\nHospital 1 Unit 14\n35\n21\n0.6000000\n\n\nHospital 2\nHospital 2 Unit 41\n137\n107\n0.7810219\n\n\nHospital 3\nHospital 3 Unit 55\n298\n252\n0.8456376\n\n\nHospital 4\nHospital 4 Unit 66\n12\n7\n0.5833333\n\n\nHospital 5\nHospital 5 Unit 39\n211\n169\n0.8009479\n\n\n\n\n\nThis unit level variation is important! Even though units within certain hospitals tend to perform worse than units in others, individual units at lower-rated hospitals can still outperform units at highly-rated hospitals! An easier way to see both the hospital-level and unit-level variation is to place all on the same plot.\n\n\nCode\nsatisfaction %>%\n  mutate(score = topbox/n) %>%\n  ggplot(aes(x = hospital,\n             y = score,\n             size = n,\n             color = hospital)) + \n  geom_boxplot() + \n  geom_jitter(alpha = 0.25) + \n  coord_flip() +\n  scale_color_brewer(palette = \"Dark2\") +\n  scale_size_continuous(range = c(1, 15)) +\n  scale_y_continuous(labels = scales::label_percent()) +\n  theme(legend.position = \"none\") +\n  labs(title = \"It's in the way that you Units\",\n       subtitle = \"Satisfaction scores vary both **across** and **within** hospitals\",\n       x = NULL,\n       y = NULL)\n\n\n\n\n\nHere, each point represents an individual unit within a hospital — larger points indicate units with more responses. There’s clearly variation across hospitals, but also variation within each hospital. We can generally trust that the satisfaction score for a unit with lots of responses is accurate, but a unit with few responses can provide misleading scores — some have scores of 100%! I don’t think that these units are actually perfect, it’s likelier that they got lucky.\nA hierarchical model will allow us to pool all this information together — when a unit has lots of responses, the model’s estimate of their true score will land pretty close to their raw score. When a unit only has a few responses, however, the model will shrink the estimate of their true score towards the hospital group-level average."
  },
  {
    "objectID": "posts/2022-11-14-hierarchical-hospitals/index.html#fitting-a-model",
    "href": "posts/2022-11-14-hierarchical-hospitals/index.html#fitting-a-model",
    "title": "Hierarchical Hospitals",
    "section": "Fitting a Model",
    "text": "Fitting a Model\nI’ve found recently that writing out a model specification helps, so let’s write out the model and priors.\n\\[\n\\begin{gather}\ny_{unit} \\sim Binomial(\\pi_{unit}, n_{unit}) \\\\\nlogit(\\pi_{unit}) = \\mu + \\beta_{hospital} + \\beta_{unit} \\\\\n\\mu \\sim Normal(0, 2) \\\\\n\\beta_{hospital} \\sim Normal(0, 2) \\\\\n\\beta_{unit} \\sim Normal(0, 2)\n\\end{gather}\n\\]\nIn this case, the number of topbox responses at each unit, \\(y_{unit}\\), is estimated with a binomial distribution where each patient within that visits the unit has a probability \\(\\pi_{unit}\\) of selecting the topbox response. \\(\\pi_{unit}\\) is allowed to vary from the global mean, \\(\\mu\\), both by hospital (\\(\\beta_{hospital}\\)) and by unit (\\(\\beta_{unit}\\)). This can be implemented in Stan via the {rstanarm} package.\n\n\nCode\n# run chains on separte cores\noptions(mc.cores = parallel::detectCores())\n\n# fit a bayesian model!\nsatisfaction_model <- \n  stan_glmer(\n    cbind(topbox, n - topbox) ~ (1 | hospital) + (1 | unit),\n    data = satisfaction,\n    family = binomial(),\n    prior_intercept = normal(0, 2, autoscale = TRUE),\n    prior = normal(0, 2, autoscale = TRUE),\n    prior_covariance = decov(regularization = 1, concentration = 1, shape = 1, scale = 1),\n    chains = 4,\n    iter = 2000,\n    seed = 999\n  )\n\n\nThis model gives us exactly what we were looking for — units with many responses have posterior estimations of \\(\\pi_{unit}\\) that are close to the raw score and have relatively small credible intervals, while the posterior estimate of \\(\\pi_{unit}\\) for a unit with few responses is shrunken towards the hospital average with relatively wide credible intervals.\n\n\nCode\nset.seed(88)\nsatisfaction %>%\n  \n  # draw 1000 posterior predictions of pi for each unit\n  tidybayes::add_epred_draws(satisfaction_model, ndraws = 1000) %>%\n  ungroup() %>%\n  \n  # select a sample of 3 random units from each hospital to plot\n  nest(preds = -c(hospital, unit, n, topbox)) %>%\n  group_by(hospital) %>%\n  slice_sample(n = 3) %>%\n  mutate(unit = str_sub(unit, start = 12),\n         unit = glue::glue(\"{unit}\\n(n = {scales::label_comma()(n)})\"),\n         med_pred = map_dbl(preds, ~quantile(.x$.epred, probs = 0.5))) %>%\n  ungroup() %>%\n  unnest(preds) %>%\n  \n  # plot!\n  ggplot(aes(x = reorder_within(unit, med_pred, hospital),\n             y = .epred,\n             color = hospital)) +\n  stat_pointinterval() +\n  scale_x_reordered() +\n  scale_y_continuous(labels = scales::label_percent()) +\n  coord_flip() +\n  facet_wrap(~hospital, scales = \"free\") +\n  theme(legend.position = \"none\") +\n  labs(title = \"\\u03C0 in the sky\",\n       subtitle = \"Posterior estimations of \\u03C0 for a random sampling of units\", \n       x = NULL,\n       y = NULL,\n       caption = \"Pointrange indicates the<br>66% & 95% posterior credible interval\") +\n  scale_color_brewer(palette = \"Dark2\")\n\n\n\n\n\nWith a hierarchical model, we can even make predictions for new units that didn’t appear in the original training data. If we were to introduce a new unit at each hospital, the model can still rely on the hospital-level term to estimate scores.\n\n\nCode\nset.seed(1)\ntibble(hospital = paste(\"Hospital\", seq(1:5))) %>%\n  mutate(unit = glue::glue(\"{hospital}\\nNew Unit\")) %>%\n  add_epred_draws(satisfaction_model) %>%\n  ggplot(aes(x = unit,\n             y = .epred,\n             color = unit)) + \n  stat_pointinterval() +\n  scale_y_continuous(labels = scales::label_percent()) +\n  coord_flip() +\n  scale_color_brewer(palette = \"Dark2\") +\n  theme(legend.position = \"none\") +\n  labs(title = \"New unit, who this?\",\n       subtitle = \"Posterior estimations of \\u03C0 for hypothetical new units at each hospital\",\n       x = NULL,\n       y = NULL,\n       caption = \"Pointrange indicates the<br>66% and 95% posterior credible interval\")"
  },
  {
    "objectID": "posts/2022-11-14-hierarchical-hospitals/index.html#some-closing-thoughts",
    "href": "posts/2022-11-14-hierarchical-hospitals/index.html#some-closing-thoughts",
    "title": "Hierarchical Hospitals",
    "section": "Some closing thoughts",
    "text": "Some closing thoughts\nThe model I used here can be referred to as a random intercept model. In this case, the intercept is allowed to vary by hospital and unit. Had I included a predictor term — age, for example — I could have put together a random slope model, which would have allowed the age term to also vary by hospital and unit. This would allow for one hospital to be modeled as having better scores for young patients while another hospital could see better scores for older patients. This sort of flexibility is useful, but in my experience, simply accounting for the hierarchical structure of the data with an intercept-only model gets you 90% of where you need to go!"
  },
  {
    "objectID": "posts/2022-12-16-chief-twit/index.html",
    "href": "posts/2022-12-16-chief-twit/index.html",
    "title": "Chief Twit",
    "section": "",
    "text": "Code\nggplot2::theme_set(\n  ggplot2::theme_minimal(base_family = \"Roboto Slab\",\n                         base_size = 14) +\n    ggplot2::theme(plot.title.position = \"plot\",\n                   plot.background = ggplot2::element_rect(fill = \"white\", color = \"white\"),\n                   plot.title = ggtext::element_markdown(),\n                   plot.subtitle = ggtext::element_markdown(),\n                   plot.caption = ggtext::element_markdown(color = \"gray40\"))\n)\n\n\nUmm… twitter is a weird place right now. Since Elon Musk’s $44 billion deal to take over twitter closed in late October, there have been mass layoffs, a floodgate of advertisers leaving the platform, and a near-daily deluge of disasters (for in depth coverage, I recommend visiting Platformer). It feels like the ship is going down, but it’s been pretty funny to watch everything unfold.\n\nFolks who are invested in Tesla may find the situation somewhat less humorous — Tesla’s stock price has dropped 18% over the past month. That’s a lot to lose, but can it really be causally linked to Musk’s antics on twitter?\nAs it turns out, yes, it can. Following the approach taken by Alex Hayes and Fabian Dablander, we can use the {CausalImpact} package to compare Tesla’s stock price pre/post Musk’s takeover of twitter, using the S&P500 as a synthetic control.\n\n\nCode\nlibrary(tidyverse)\nlibrary(riingo)\nlibrary(CausalImpact)\n\n# pull in stock from tiingo\nstonks <- \n  bind_rows(\n    riingo_prices(\"TSLA\"), \n    riingo_prices(\"SPY\")\n  )\n\n# adjust for tesla 3-1 stock split in aug\nstonks <- \n  stonks %>%\n  select(ticker, date, close) %>%\n  mutate(close = if_else(date < lubridate::mdy(\"8/25/22\") & ticker == \"TSLA\",\n                         close/3,\n                         close))\n\n\nLooking at the two tickers side by side, Tesla seems to follow the index’s movement until the takeover.\n\n\nCode\nstonks %>% \n  mutate(date = lubridate::as_date(date)) %>%\n  ggplot(aes(x = date,\n             y = close,\n             color = ticker)) + \n  geom_line(linewidth = 1) + \n  scale_color_brewer(palette = \"Dark2\") + \n  facet_wrap(~ticker, \n             scales = \"free_y\",\n             ncol = 1) +\n  geom_vline(xintercept = lubridate::mdy(\"10/27/22\"),\n             linetype = \"dashed\") +\n  scale_x_date(labels = scales::label_date(format = \"%b\")) +\n  scale_y_continuous(labels = scales::dollar_format()) +\n  theme(legend.position = \"none\") +\n  labs(title = \"STONKS: Tesla's and S&P500's daily close over the past year\",\n       x = NULL,\n       y = NULL,\n       caption = \"Data from Dec 16, '21 -- Dec 16, '22\")\n\n\n\nPlugging this in blindly to CausalImpact() shows that Musk’s twitter antics have had an effect on Tesla’s price.\n\n\nCode\nstonks <- \n  stonks %>%\n  pivot_wider(names_from = ticker,\n              values_from = close)\n\nfit <- \n  CausalImpact(\n    zoo(cbind(stonks$TSLA, stonks$SPY), stonks$date), \n    stonks$date[c(1, 217)],  # 12/16/21 - 10/26/22\n    stonks$date[c(218, 253)] # 10/27/22 - 12/16/22\n  )\n\nfit %>% plot()\n\n\n\nPrior to Musk’s twitter takeover, Tesla’s shares could be reliably estimated by the S&P500. After the takeover, however, Tesla’s share price has fallen outside of what the model would expect based on S&P500 data. The implied cost to Tesla shareholders is about $77 per share on average, though the credible interval could put the true cost anywhere between $17 and $133 per share.\nThis makes pretty strong assumptions — that Musk’s antics don’t affect S&P500 prices and that no other event is influencing Tesla’s price but not the S&P500 price. There’s lot’s more worth digging into in the paper (Brodersen, 2015) that {CausalImpact} accompanies. Since this was mostly a quick exploration on a Friday afternoon, however, I’ll leave the additional investigating to the reader. For me, it’s back to watching the site crash and burn.\n\n\n\nCitationBibTeX citation:@online{rieke2022,\n  author = {Mark Rieke},\n  title = {Chief {Twit}},\n  date = {2022-12-16},\n  url = {https://www.thedatadiary.net/posts/2022-12-16-chief-twit},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2022. “Chief Twit.” December 16, 2022. https://www.thedatadiary.net/posts/2022-12-16-chief-twit."
  },
  {
    "objectID": "posts/2022-12-30-my-2022-magnum-opus/index.html",
    "href": "posts/2022-12-30-my-2022-magnum-opus/index.html",
    "title": "My 2022 Magnum Opus",
    "section": "",
    "text": "Code\nggplot2::theme_set(\n  ggplot2::theme_minimal(base_family = \"Roboto Slab\",\n                         base_size = 13) +\n    ggplot2::theme(plot.title.position = \"plot\",\n                   plot.background = ggplot2::element_rect(fill = \"white\", color = \"white\"),\n                   plot.title = ggtext::element_markdown(),\n                   plot.subtitle = ggtext::element_markdown(),\n                   plot.caption = ggtext::element_markdown(color = \"gray40\"))\n)\nOver the past few years, the hospital system I work for has transitioned from the old metric for measuring patient satisfaction, Likelihood to Recommend (LTR), to a newer metric, Net Promoter Score (NPS). Both metrics ask the same question — how likely are you to recommend this hospital to a friend or relative? — but they are measured very differently. The score for LTR is simply the percentage of patients who respond with the “topbox” option of Very likely on a scale from Very likely to Very unlikely. NPS, on the other hand, is a bit more involved. Patients are categorized based on their response on a 0-10 point scale: responses between 0 and 6 are considered detractors, 7 and 8s are considered passives, while 9 and 10s are considered promoters. The score for NPS is then the percentage of promoters minus the percentage of detractors.\n\\[\n\\begin{gather}\n\\text{NPS} = \\text{Promoter %} - \\text{Detractor %}\n\\end{gather}\n\\]\nAs a metric, NPS is a bit better than the alternative of LTR, since it is somewhat able to take into account the distribution of responses along the 0-10 scale. Consider the following set of responses (and let’s just pretend for sake of example that “promoter” here is equivalent to “topbox”). LTR’s topbox isn’t able to detect a difference in scores since promoters comprise 50% of responses in both sets. NPS, however, can detect a difference, since the second set is rewarded for have fewer detractors than the first set.\nWith only a few sets of responses to compare, this seems like a trivial improvement — since we have all the data, why don’t we just look at the response distribution for every set? In practice, however, I’m often looking at responses for hundreds of individual hospital units across the system — encoding this extra bit of information into a single number allows for a more nuanced comparison without any costs to the viewer’s cognitive load.\nUnfortunately, there’s no free lunch here, and the additional nuance that NPS provides comes at the cost of modeling complexity. Relative modeling binary choices like LTR’s topbox, the ecosystem for modeling the choice between three or more categories is far smaller. Additionally, the order of the categories matters — a promoter response is better than a passive response, which is better than a detractor response. This adds a layer of complexity over unordered categories (e.g., red, blue, or green).\nFortunately, I’m not the first person to run into this problem. I’ve been (slowly) working through Richard McElreath’s Statistical Rethinking, which conveniently covers this topic directly (and comes with the added benefit of utilizing a Bayesian approach via Stan).\nLet’s test both my understanding of the ordered categorical data-generating process and my ability to model it by doing a few things:"
  },
  {
    "objectID": "posts/2022-12-30-my-2022-magnum-opus/index.html#the-data-generating-process",
    "href": "posts/2022-12-30-my-2022-magnum-opus/index.html#the-data-generating-process",
    "title": "My 2022 Magnum Opus",
    "section": "The data generating process",
    "text": "The data generating process\n\n\nCode\nlibrary(tidyverse)\nlibrary(rethinking)\nlibrary(riekelib)\nlibrary(broom.mixed)\n\n# I've been having ~issues~ with cmdstan, so switching default to rstan\nset_ulam_cmdstan(FALSE)\n\n\nEach patient’s response \\(R_i\\) can be described as a probability \\(p_i\\) of selecting from each of the three available categories:\n\\[\n\\begin{gather}\nR_i \\sim \\text{Categorical}(p_i) \\\\\np_i = \\langle p_{\\text{detractor}[i]}, \\ p_{\\text{passive}[i]}, \\ p_{\\text{promoter}[i]} \\rangle \\\\\n\\end{gather}\n\\]\nThere’s a useful math trick we can use to enforce the order of the categories. Rather than working with the individual probability of each category directly, we can instead define the probabilities in terms of the cumulative probability of each category. For example, in the set below, the probability of selecting “passive” is 10%, but the cumulative probability of selecting a rating of passive or lower is 30%:\n\n\nCode\nprobs_example <- \n  tibble(nps_group = as_factor(c(\"detractor\", \"passive\", \"promoter\")),\n         prob = c(0.2, 0.1, 0.7),\n         cumulative_prob = cumsum(prob))\n\nprobs_example %>%\n  mutate(across(ends_with(\"prob\"), ~scales::label_percent(accuracy = 1)(.x))) %>%\n  knitr::kable()\n\n\n\n\n\nnps_group\nprob\ncumulative_prob\n\n\n\n\ndetractor\n20%\n20%\n\n\npassive\n10%\n30%\n\n\npromoter\n70%\n100%\n\n\n\n\n\nWith this in mind, any individual probability can be described as the difference between two cumulative probabilities \\(q_k\\).\n\n\nCode\nprobs_example %>%\n  ggplot(aes(x = nps_group,\n             xend = nps_group)) + \n  geom_hline(yintercept = c(0.2, 0.3),\n             linetype = \"dashed\",\n             color = \"gray60\") + \n  geom_segment(aes(y = 0,\n                   yend = cumulative_prob)) +\n  geom_point(aes(y = cumulative_prob)) +\n  geom_segment(aes(y = cumulative_prob - prob,\n                   yend = cumulative_prob),\n               color = \"blue\",\n               position = position_nudge(x = 0.125)) + \n  geom_point(aes(y = cumulative_prob),\n             color = \"blue\",\n             position = position_nudge(x = 0.125)) + \n  geom_text(x = 1 - 0.1,\n            y = 0.1,\n            label = \"q1: 20%\",\n            hjust = \"right\") +\n  geom_text(x = 1 + 0.125 + 0.1,\n            y = 0.1,\n            label = \"p1: 20%\",\n            hjust = \"left\",\n            color = \"blue\") + \n  geom_text(x = 2 - 0.1,\n            y = 0.25,\n            label = \"q2: 30%\",\n            hjust = \"right\") +\n  geom_text(x = 2 + 0.125 + 0.1,\n            y = 0.25,\n            label = \"p2: 10%\",\n            hjust = \"left\",\n            color = \"blue\") +\n  geom_text(x = 3 + 0.125 + 0.1,\n            y = 0.625,\n            label = \"p3: 70%\",\n            color = \"blue\",\n            hjust = \"left\") +\n  expand_limits(y = c(0, 1)) +\n  scale_y_continuous(labels = scales::label_percent()) +\n  labs(title = glue::glue(\"**Cumulative** and \n                          **{color_text('individual', 'blue')}** \n                          probabilities of each response\"),\n       x = NULL,\n       y = NULL)\n\n\n\n\n\nThe probability of selecting a response less than detractor is 0% and the probability of selecting a response of promoter or lower is 100%, so we can rewrite the individual probabilities in terms of just two cumulative probabilities.\n\\[\n\\begin{gather}\nR_i \\sim \\text{Categorical}(p_i) \\\\\np_i = \\langle p_{\\text{detractor}[i]}, \\ p_{\\text{passive}[i]}, \\ p_{\\text{promoter}[i]} \\rangle \\\\\n\\color{blue}{p_{\\text{detractor}[i]} = q_{1, i} \\\\\np_{\\text{passive}[i]} = q_{2,i} - q_{1,i} \\\\\np_{\\text{promoter}[i]} = 1 - q_{2,i}}\n\\end{gather}\n\\]\nIn the logit space, these two cumulative probabilities can be represented by a linear model’s output \\(\\phi_i\\) relative to a set of \\(k = 2\\) “cutpoints” \\(\\kappa_k\\).\n\\[\n\\begin{gather}\nR_i \\sim \\text{Categorical}(p_i) \\\\\np_i = \\langle p_{\\text{detractor}[i]}, \\ p_{\\text{passive}[i]}, \\ p_{\\text{promoter}[i]} \\rangle \\\\\np_{\\text{detractor}[i]} = q_{1, i} \\\\\np_{\\text{passive}[i]} = q_{2,i} - q_{1,i} \\\\\np_{\\text{promoter}[i]} = 1 - q_{2,i} \\\\\n\\color{blue}{\\text{logit}(q_{k, i}) = \\kappa_k - \\phi_i \\\\\n\\phi_i = \\text{some linear model}}\n\\end{gather}\n\\]\nThis is all a bit involved but I wouldn’t worry about the details too much. The important takeaway is that we now have a linear model \\(\\phi\\) that maps to a categorical outcome while preserving the order of the categories."
  },
  {
    "objectID": "posts/2022-12-30-my-2022-magnum-opus/index.html#simulating-data",
    "href": "posts/2022-12-30-my-2022-magnum-opus/index.html#simulating-data",
    "title": "My 2022 Magnum Opus",
    "section": "Simulating data",
    "text": "Simulating data\nIn this case, let’s let \\(\\phi\\) vary by the patient’s age and the hospital unit they visit:\n\\[\n\\begin{gather}\nR_i \\sim \\text{Categorical}(p_i) \\\\\np_i = \\langle p_{\\text{detractor}[i]}, \\ p_{\\text{passive}[i]}, \\ p_{\\text{promoter}[i]} \\rangle \\\\\np_{\\text{detractor}[i]} = q_{1, i} \\\\\np_{\\text{passive}[i]} = q_{2,i} - q_{1,i} \\\\\np_{\\text{promoter}[i]} = 1 - q_{2,i} \\\\\n\\text{logit}(q_{k, i}) = \\kappa_k - \\phi_i \\\\\n\\phi_i = \\color{blue}{\\beta_{\\text{unit}[i]} + \\beta_{\\text{age}} \\ \\text{age}_i}\n\\end{gather}\n\\]\nWe’ll manually fix the \\(\\beta_{\\text{unit}}\\) term for each unit. Additionally, let’s define a sampling weight so that the simulated data ends up with a wide range of response counts.\n\n\nCode\nunit_params <-\n  tribble(\n    ~unit, ~beta, ~weight,\n    \"A\", 1.00, 2,\n    \"B\", 0.66, 3,\n    \"C\", 0.33, 2,\n    \"D\", 0.00, 4,\n    \"E\", -0.50, 1\n  )\n\nunit_params %>%\n  knitr::kable()\n\n\n\n\n\nunit\nbeta\nweight\n\n\n\n\nA\n1.00\n2\n\n\nB\n0.66\n3\n\n\nC\n0.33\n2\n\n\nD\n0.00\n4\n\n\nE\n-0.50\n1\n\n\n\n\n\nHere, unit A is likely to have the best scores, while unit E is likely to have the worst. Unit D is likely to have the most returns, while unit E is likely to have the fewest. The randomization/discretization means that the simulated scores won’t match the expected scores exactly, but if we set cutpoints in the logit space, we can work backwards through the data-generating process to see the expected score for each unit.\n\n\nCode\n# set cutpoints in the logit space\ncutpoints <- c(-0.5, -0.15)\n\n# here's how we expect the units to score for an average aged patient\nunit_params %>%\n  mutate(q1 = cutpoints[1] - beta,\n         q2 = cutpoints[2] - beta,\n         detractor = expit(q1),\n         passive = expit(q2) - expit(q1),\n         promoter = 1 - expit(q2)) %>%\n  select(unit, weight, promoter, passive, detractor) %>%\n  mutate(nps = promoter - detractor,\n         across(c(promoter:nps), ~scales::label_percent(accuracy = 1)(.x))) %>%\n  knitr::kable()\n\n\n\n\n\nunit\nweight\npromoter\npassive\ndetractor\nnps\n\n\n\n\nA\n2\n76%\n6%\n18%\n58%\n\n\nB\n3\n69%\n7%\n24%\n45%\n\n\nC\n2\n62%\n8%\n30%\n31%\n\n\nD\n4\n54%\n9%\n38%\n16%\n\n\nE\n1\n41%\n9%\n50%\n-9%\n\n\n\n\n\nNow let’s simulate patient visits. We’ll have 500 patients return surveys and the number of returns at each unit will be proportional to the weight set earlier.\n\n\nCode\nn_patients <- 500\n\n# simulate patient visits\nset.seed(30)\nunit_samples <-\n  sample(\n    unit_params$unit,\n    size = n_patients,\n    prob = unit_params$weight,\n    replace = TRUE\n  )\n\n\n\n\n\n\n\nCode\ntibble(unit = unit_samples) %>%\n  percent(unit, .keep_n = TRUE) %>%\n  mutate(pct = scales::label_percent(accuracy = 1)(pct)) %>%\n  knitr::kable()\n\n\n\n\n\nunit\nn\npct\n\n\n\n\nA\n69\n14%\n\n\nB\n111\n22%\n\n\nC\n78\n16%\n\n\nD\n195\n39%\n\n\nE\n47\n9%\n\n\n\n\n\nNow let’s add in each patient’s age. In this case, we won’t include any relationship between age and unit; age will just vary randomly across all units. In reality, this often isn’t the case — you can imagine, for example, that patients visiting a Labor & Delivery unit will tend to be younger than patients visiting a Geriatric unit! Ignoring this reality, in our simulated patient population the ages will vary generally between 25 and 65.\n\n\nCode\n# simulate ages of patients & combine with the unit visited\nset.seed(31)\npatients <-\n  tibble(\n    unit = unit_samples,\n    age = round(rnorm(n_patients, 45, 10))\n  )\n\n\n\n\n\n\n\nCode\npatients %>%\n  slice_head(n = 10) %>%\n  knitr::kable()\n\n\n\n\n\nunit\nage\n\n\n\n\nD\n46\n\n\nB\n43\n\n\nB\n61\n\n\nB\n55\n\n\nD\n60\n\n\nD\n41\n\n\nA\n49\n\n\nD\n54\n\n\nE\n32\n\n\nD\n38\n\n\n\n\n\nFinally, we’ll set \\(\\beta_{\\text{age}}\\) such that there is a modest positive relationship between age and the probability of a positive response — older patients at any unit will be likelier than younger patients to be a promoter!\nWith all that wrapped up, we can finally simulate individual responses.\n\n\nCode\nbeta_age <- 0.35\n\n# simulate individual patient responses \nset.seed(32)\nresponses <- \n  patients %>%\n  left_join(unit_params) %>%\n  mutate(phi = beta + beta_age * ((age - 45)/10),\n         q1 = cutpoints[1] - phi,\n         q2 = cutpoints[2] - phi,\n         detractor = expit(q1),\n         passive = expit(q2) - expit(q1),\n         promoter = 1 - expit(q2)) %>%\n  select(unit, age, promoter, passive, detractor) %>%\n  rowwise() %>%\n  mutate(response = sample(c(\"promoter\", \"passive\", \"detractor\"),\n                           size = 1, \n                           prob = c(promoter, passive, detractor))) %>%\n  ungroup() %>%\n  select(unit, age, response)\n\n\n\n\n\nHere’s the distribution of responses for each unit — as expected, unit A has lots of promoters while units D and E have the highest proportion of detractors, and unit D has the most responses while unit E has the fewest.\n\n\nCode\negypt_blu <- MetBrewer::MetPalettes$Egypt[[1]][2]\negypt_red <- MetBrewer::MetPalettes$Egypt[[1]][1]\negypt_grn <- MetBrewer::MetPalettes$Egypt[[1]][3]\n\nresponses %>%\n  mutate(response = fct_relevel(response, c(\"detractor\", \"promoter\", \"passive\"))) %>%\n  ggplot(aes(x = age,\n             fill = response)) + \n  geom_histogram(position = \"identity\",\n                 alpha = 0.5) + \n  facet_wrap(~unit, scales = \"free_y\") +\n  MetBrewer::scale_fill_met_d(\"Egypt\") +\n  theme(legend.position = \"none\") +\n  labs(title = glue::glue(\"Simulated **{color_text('promoters', egypt_blu)}**, \n                          **{color_text('passives', egypt_grn)}**, and \n                          **{color_text('detractors', egypt_red)}**\"),\n       subtitle = \"Distribution of patient responses by age at each unit\",\n       x = \"Patient age\",\n       y = NULL)\n\n\n\n\n\nHere’s how each simulated unit scored for NPS:\n\n\nCode\nresponses %>%\n  group_by(unit) %>%\n  count(response) %>%\n  pivot_wider(names_from = response,\n              values_from = n,\n              values_fill = 0) %>%\n  mutate(n = promoter + passive + detractor,\n         nps = (promoter - detractor)/n,\n         nps = scales::label_percent(accuracy = 1)(nps)) %>%\n  knitr::kable()\n\n\n\n\n\nunit\ndetractor\npassive\npromoter\nn\nnps\n\n\n\n\nA\n8\n2\n59\n69\n74%\n\n\nB\n27\n6\n78\n111\n46%\n\n\nC\n25\n7\n46\n78\n27%\n\n\nD\n68\n21\n106\n195\n19%\n\n\nE\n23\n0\n24\n47\n2%\n\n\n\n\n\nImportantly, this differs from the expected outcome at each unit! For smaller sample sizes, each individual patient response has an outsized impact on NPS. Despite this, we should be able to recover the underlying parameters used to simulate the data with a model."
  },
  {
    "objectID": "posts/2022-12-30-my-2022-magnum-opus/index.html#model",
    "href": "posts/2022-12-30-my-2022-magnum-opus/index.html#model",
    "title": "My 2022 Magnum Opus",
    "section": "Model",
    "text": "Model\nRemember the lengthy data-generating process nonsense from beforehand? As is, that’d be a bit of a mess to implement by hand. Luckily for us, however, McElreath’s {rethinking} package contains a useful function, dordlogit(), that interfaces nicely with Stan’s ordered logistic model. This plunks some of the rote computational steps under the hood and leaves us with the most important bits: the linear model \\(\\phi\\) and the cutpoints \\(\\kappa\\).\n\\[\n\\begin{gather}\nR_i \\sim \\text{Ordered-logit}(\\phi_i, \\kappa_k) \\\\\n\\phi_i = \\text{some linear model} \\\\\n\\text{~priors~}\n\\end{gather}\n\\]\nLet’s build a series of increasingly complex models using this framework. I’m in a mood for raccoons, so the models are named appropriately:\n\nraccoon_01: a term-less model that just estimates the cutpoints.\nraccoon_02: a model with terms for age and unit.\nraccoon_03: a model with a term for age and a hierarchical term for unit.\nraccoon_04: a model with a term for age and a non-centered hierarchical term for unit.\n\nBefore doing any of that, however, we’ll need to prep the data for Stan. Each unit and response category will get assigned a numeric ID and we’ll standardize patient ages across the population.\n\n\nCode\nresponses <- \n  responses %>%\n  left_join(tibble(unit = LETTERS[1:5],\n                   unit_id = seq(1:5))) %>%\n  mutate(response_id = case_when(response == \"promoter\" ~ 3,\n                                 response == \"passive\" ~ 2,\n                                 response == \"detractor\" ~ 1),\n         response_id = as.integer(response_id),\n         age_std = (age - mean(age))/sd(age))\n\nresponses_stan <- \n  responses %>%\n  select(response_id,\n         unit_id,\n         age_std) %>%\n  as.list()\n\n\n\nRaccoon #01\nThe first model doesn’t contain any terms and just estimates the cutpoints from the data. In McElreath’s words, this sort of model is little more than a Bayesian histogram of the data. To get started, we just need to provide a prior for the cutpoints \\(\\kappa_k\\).\n\\[\n\\begin{gather}\nR_i \\sim \\text{Ordered-logit}(\\phi_i, \\kappa_k) \\\\\n\\color{blue}{\\phi_i = 0 \\\\\n\\kappa_k \\sim \\text{Normal}(0, 1)}\n\\end{gather}\n\\]\nModeling in Stan via rethinking::ulam() is essentially as basic as re-writing the mathematical model and supplying the data.\n\n\nCode\nraccoon_01 <-\n  ulam(\n    alist(\n      # model\n      response_id ~ dordlogit(0, cutpoints),\n      \n      # priors\n      cutpoints ~ dnorm(0, 1)\n    ),\n    \n    data = responses_stan,\n    chains = 4,\n    cores = 4\n  )\n\n\n\n\n\nThis initial model doesn’t do a good job of recovering the manually set cutpoints:\n\n\nCode\nprecis(raccoon_01, depth = 2)\n\n\n#>                    mean         sd       5.5%      94.5%    n_eff    Rhat4\n#> cutpoints[1] -0.8350663 0.09496125 -0.9825748 -0.6847435 1078.130 1.002124\n#> cutpoints[2] -0.5054729 0.08830633 -0.6494612 -0.3641978 1291.444 1.001888\n\n\nThis is expected! This model doesn’t account for the variation by unit/age and instead lumps all the data together. As mentioned before, this really can be thought of as a Bayesian histogram — while it doesn’t recover the cutpoint parameters, raccoon_01 matches the overall proportion of promoters, passives, and detractors really well.\n\n\nCode\nraccoon_01@stanfit %>%\n  \n  # extract posterior draws & convert to tibble\n  posterior::as_draws_df() %>%\n  as_tibble() %>%\n  select(starts_with(\"cut\")) %>%\n  rename_with(~str_remove_all(.x, \"[:punct:]\")) %>%\n  \n  # summarise each category w/50/80% quantiles\n  mutate(detractor = expit(cutpoints1),\n         passive = expit(cutpoints2) - expit(cutpoints1),\n         promoter = 1 - expit(cutpoints2)) %>%\n  select(-starts_with(\"cut\")) %>%\n  pivot_longer(cols = everything(),\n               names_to = \"nps\",\n               values_to = \"estimate\") %>%\n  group_by(nps) %>%\n  tidybayes::median_qi(estimate, .width = c(0.5, 0.8)) %>%\n  \n  # plot alongside original data\n  ggplot() + \n  geom_col(data = percent(responses, response),\n           aes(x = response,\n               y = pct),\n           fill = egypt_red,\n           alpha = 0.5,\n           width = 0.5) +\n  ggdist::geom_pointinterval(aes(x = nps,\n                                 y = estimate,\n                                 ymin = .lower,\n                                 ymax = .upper),\n                             color = egypt_blu) +\n  scale_y_continuous(labels = scales::label_percent()) + \n  labs(title = \"**Raccoon #01** Posterior Fit\",\n       subtitle = glue::glue(\"Comparison of each category's \n                             **{color_text('true proportion', egypt_red)}** \n                             to the \n                             **{color_text('model\\\\'s estimate', egypt_blu)}**\"),\n       x = NULL,\n       y = NULL,\n       caption = \"Pointrange indicates 50/80% <br>posterior credible interval\")\n\n\n\n\n\nThis model isn’t terribly useful since we could have gotten the same inference from just plotting the data directly, but this serves as a base upon which we can build more complicated and useful models.\n\n\nRaccoon #02\nThe second model is where things get a bit more interesting — now we’ll actually include predictors for \\(\\beta_{\\text{unit}}\\) and \\(\\beta_{\\text{age}}\\).\n\\[\n\\begin{gather}\nR_i \\sim \\text{Ordered-logit}(\\phi_i, \\kappa_k) \\\\\n\\phi_i = \\color{blue}{\\beta_{\\text{unit}} + \\beta_{\\text{age}} \\ \\text{age}_i} \\\\\n\\kappa_k \\sim \\text{Normal}(0, 1) \\\\\n\\color{blue}{\\beta_{\\text{unit}} \\sim \\text{Normal}(0, 1) \\\\\n\\beta_{\\text{age}} \\sim \\text{Normal}(0, 0.5)}\n\\end{gather}\n\\]\nI’ve upped the number of samples for this particular model to avoid a warning from Stan.\n\n\nCode\nraccoon_02 <- \n  ulam(\n    alist(\n      # model\n      response_id ~ dordlogit(phi, cutpoints),\n      phi <- b[unit_id] + b_age * age_std,\n      \n      # priors\n      cutpoints ~ dnorm(0, 1), \n      b[unit_id] ~ dnorm(0, 1),\n      b_age ~ dnorm(0, 0.5)\n    ),\n    \n    data = responses_stan,\n    chains = 4,\n    cores = 4,\n    iter = 2000\n  )\n\n\n\n\n\nThis model does a pretty good job! Extracting the parameter estimates shows that all of the parameter values that we set manually fall within the 80% posterior credible range estimated by the model.\n\n\nCode\nraccoon_02@stanfit %>%\n  \n  # extract parameter draws & summarise with 50/80% quantiles\n  posterior::as_draws_df() %>%\n  as_tibble() %>%\n  select(-c(lp__:.draw)) %>%\n  pivot_longer(cols = everything(),\n               names_to = \"term\",\n               values_to = \"estimate\") %>%\n  mutate(term = if_else(str_sub(term, 1, 2) == \"b[\", \n                        LETTERS[as.integer(str_sub(term, 3, 3))], \n                        term)) %>%\n  group_by(term) %>%\n  tidybayes::median_qi(estimate, .width = c(0.5, 0.8)) %>%\n  \n  # append with actual values used to simulate data\n  left_join(unit_params, by = c(\"term\" = \"unit\")) %>%\n  rename(true_value = beta) %>%\n  mutate(true_value = case_when(term == \"cutpoints[1]\" ~ cutpoints[1],\n                                term == \"cutpoints[2]\" ~ cutpoints[2],\n                                term == \"b_age\" ~ beta_age,\n                                TRUE ~ true_value),\n         term = fct_relevel(term, c(paste0(\"cutpoints[\", 1:2, \"]\"),\n                                    \"b_age\",\n                                    LETTERS[5:1]))) %>%\n  \n  # plot!\n  ggplot(aes(x = term,\n             y = estimate,\n             ymin = .lower,\n             ymax = .upper)) + \n  ggdist::geom_pointinterval(color = egypt_blu) +\n  geom_point(aes(y = true_value),\n             color = egypt_red,\n             size = 2.5) + \n  coord_flip() + \n  labs(title = \"**Raccoon #02** Posterior Fit\",\n       subtitle = glue::glue(\"Comparison of each parameter's \n                             **{color_text('true value', egypt_red)}** \n                             to the \n                             **{color_text('model\\\\'s estimate', egypt_blu)}**\"),\n       x = NULL,\n       y = NULL,\n       caption = \"Pointrange indicates 50/80% <br>posterior credible interval\")\n\n\n\n\n\nThis model, however, could be improved. The model only uses categorical indicators for the unit, which causes two issues. Firstly, we can only make predictions for the few units that are in the dataset — this model would fail if we tried to make a prediction on a hypothetical new unit, unit F. Secondly, information about each unit is contained just to that unit. In this case, unit E has relatively few responses, and therefore can only draw inference from those responses. A hierarchical model, however, can help in both these areas.\n\n\nRaccoon #03\nTo add a hierarchical term for the unit-level intercept, \\(\\beta_{\\text{unit}}\\), we don’t actually need to make any changes to the linear model, just how \\(\\beta_{\\text{unit}}\\) is defined underneath. Rather than estimating each unit intercept directly, this new model will allow them to vary around a group mean, \\(\\overline{\\beta}\\) with a standard deviation \\(\\sigma\\).\n\\[\n\\begin{gather}\nR_i \\sim \\text{Ordered-logit}(\\phi_i, \\kappa_k) \\\\\n\\phi_i = \\beta_{\\text{unit}} + \\beta_{\\text{age}} \\ \\text{age}_i \\\\\n\\kappa_k \\sim \\text{Normal}(0, 1) \\\\\n\\beta_{\\text{unit}} \\sim \\text{Normal}(\\color{blue}{\\overline{\\beta}}, \\color{blue}{\\sigma}) \\\\\n\\beta_{\\text{age}} \\sim \\text{Normal}(0, 0.5) \\\\\n\\color{blue}{\\overline{\\beta} \\sim \\text{Normal}(0, 1) \\\\\n\\sigma \\sim \\text{Exponential}(1)}\n\\end{gather}\n\\]\nThis new definition means that we no longer set priors for \\(\\beta_{\\text{unit}}\\) directly. Instead, our new terms are considered hyper-priors or adaptive priors.\n\n\nCode\nraccoon_03 <-\n  ulam(\n    alist(\n      # model\n      response_id ~ dordlogit(phi, cutpoints),\n      phi <- b[unit_id] + b_age*age_std,\n      \n      # priors\n      cutpoints ~ dnorm(0, 1),\n      b[unit_id] ~ dnorm(b_bar, sigma),\n      b_age ~ dnorm(0, 0.5),\n      \n      # hyper-priors\n      b_bar ~ dnorm(0, 1),\n      sigma ~ dexp(1)\n    ),\n    \n    data = responses_stan,\n    chains = 4,\n    cores = 4\n  )\n\n\n\n\n\nSimilar to the previous model, all the true parameter values fall within the model’s 80% credible interval estimates. And, we’re now accounting for the group structure with a hierarchical model! If you look at Unit E, however, it looks like the model has gotten worse — the median parameter estimate here is further away from the true value than in the previous model. This, however, is actually what we want. Because there are so few responses for unit E, the estimates are shrunken towards the group mean. In the previous model, we were a bit too over-indexed on the responses we had — if this were real data, where we don’t inherently know the underlying parameter value, we’d want to be similarly cautious for a unit with few responses.\n\n\nCode\nraccoon_03@stanfit %>%\n  \n  # extract posterior parameters and summarise with 50/80% quantiles\n  posterior::as_draws_df() %>%\n  as_tibble() %>%\n  rename_with(~str_remove(.x, \"]\")) %>%\n  rename_with(~str_replace(.x, \"\\\\[\", \"_\")) %>%\n  mutate(A = b_1,\n         B = b_2,\n         C = b_3,\n         D = b_4,\n         E = b_5) %>%\n  select(.draw, A, B, C, D, E, starts_with(\"cut\"), b_age) %>%\n  pivot_longer(cols = -.draw,\n               names_to = \"term\",\n               values_to = \"estimate\") %>%\n  group_by(term) %>%\n  tidybayes::median_qi(estimate, .width = c(0.5, 0.8)) %>%\n  \n  # append with actual values used to simulate data\n  mutate(term = if_else(str_detect(term, \"cutpoint\"), paste0(str_replace(term, \"_\", \"\\\\[\"), \"]\"), term)) %>%\n  left_join(unit_params, by = c(\"term\" = \"unit\")) %>%\n  rename(true_value = beta) %>%\n  mutate(true_value = case_when(term == \"cutpoints[1]\" ~ cutpoints[1],\n                                term == \"cutpoints[2]\" ~ cutpoints[2],\n                                term == \"b_age\" ~ beta_age,\n                                TRUE ~ true_value),\n         term = fct_relevel(term, c(paste0(\"cutpoints[\", 1:2, \"]\"),\n                                    \"b_age\",\n                                    LETTERS[5:1]))) %>%\n  \n  # plot!\n  ggplot(aes(x = term,\n             y = estimate,\n             ymin = .lower,\n             ymax = .upper)) + \n  ggdist::geom_pointinterval(color = egypt_blu) +\n  geom_point(aes(y = true_value),\n             color = egypt_red,\n             size = 2.5) + \n  coord_flip() + \n  labs(title = \"**Raccoon #03** Posterior Fit\",\n       subtitle = glue::glue(\"Comparison of each parameter's \n                             **{color_text('true value', egypt_red)}** \n                             to the \n                             **{color_text('model\\\\'s estimate', egypt_blu)}**\"),\n       x = NULL,\n       y = NULL,\n       caption = \"Pointrange indicates 50/80% <br>posterior credible interval\")\n\n\n\n\n\nDespite all this hierarchical goodness, this model’s diagnostics could stand to be improved. Although Stan didn’t throw any errors, each parameter’s effective sample size, n_eff, is low relative to the number of actual samples drawn (in this case, we used the default of 500 samples per chain for a total of 2000 samples) and the convergence statistic, Rhat4, is often a hair or two above the target value of 1.00.\n\n\nCode\nprecis(raccoon_03, depth = 2)\n\n\n#>                     mean         sd       5.5%     94.5%     n_eff    Rhat4\n#> cutpoints[1] -0.41376023 0.60190950 -1.4433861 0.5471729  373.8733 1.018584\n#> cutpoints[2] -0.06246023 0.60423520 -1.0766518 0.8993494  389.2378 1.018645\n#> b[1]          1.49374559 0.69139567  0.3692997 2.6091664  479.3414 1.014100\n#> b[2]          0.74360352 0.62753994 -0.2911371 1.7151677  408.1696 1.017661\n#> b[3]          0.33785619 0.63617237 -0.7061142 1.3145339  385.0501 1.016526\n#> b[4]          0.20898156 0.61467500 -0.8026615 1.1898645  366.1409 1.019565\n#> b[5]         -0.06365551 0.66665904 -1.1210397 0.9557759  431.5194 1.017986\n#> b_age         0.24898479 0.08989783  0.1096759 0.3935037 1137.4021 1.001321\n#> b_bar         0.48423691 0.65357409 -0.5809470 1.5103410  416.2923 1.011756\n#> sigma         0.78583383 0.39324244  0.3537180 1.5136274 1023.1633 1.002546\n\n\nThis is not-so-much an issue with the model specification, but with the computation. Stan’s sampler has a bit of difficulty estimating the shape of the posterior for each \\(\\beta_{\\text{unit}}\\) because they are dependent on \\(\\overline{\\beta}\\) and \\(\\sigma\\), which are estimated separately (this post provides a good visual of the “Devil’s Funnel” — a difficult shape to explore that can arise from this sort of model).\nOnce again, I am fortunate to not be the first person to encounter this issue, and there is a relatively standard approach that we can take to address. We can respecify the model using a non-centered parameterization for the \\(\\beta_{\\text{unit}}\\) terms.\n\n\nRaccoon #04\nA non-centered parameterization is mathematically equivalent to it’s centered counterpart (which is what was used in the previous model), but makes it easier for Stan’s sampler to explore the parameter space. To convert to a non-centered parameterization, we need to respecify the model such that each parameter is sampled directly, rather than being dependent on another parameter.\nIn our case, we want each unit’s intercept to be offset from the global mean by some amount. We can think of this offset as being \\(z\\) standard deviations away from the mean. Because the model is additive, we can simply replace the \\(\\beta_{\\text{unit}}\\) term in the linear model with the mean \\(\\overline{\\beta}\\) and unit offset \\(z_{\\text{unit}} \\ \\sigma\\).\n\\[\n\\begin{gather}\nR_i \\sim \\text{Ordered-logit}(\\phi_i, \\kappa_k) \\\\\n\\phi_i = \\color{blue}{\\underbrace{\\overline{\\beta} + z_{\\text{unit}} \\ \\sigma}_{\\beta_{\\text{unit}} \\ \\text{replacement}}} + \\beta_{\\text{age}} \\ \\text{age}_i \\\\\n\\kappa_k \\sim \\text{Normal}(0, 1) \\\\\n\\beta_{\\text{age}} \\sim \\text{Normal}(0, 0.5) \\\\\n\\overline{\\beta} \\sim \\text{Normal}(0, 1) \\\\\n\\color{blue}{z_{\\text{unit}} \\sim \\text{Normal}(0, 1) \\\\\n\\sigma \\sim \\text{Exponential}(1)}\n\\end{gather}\n\\]\nAgain, this is mathematically equivalent to the previous model, but the sampler will now complain less about exploring the parameter space since each term is sampled directly.\n\n\nCode\nraccoon_04 <- \n  ulam(\n    alist(\n      # model \n      response_id ~ dordlogit(phi, cutpoints),\n      phi <- b_bar + z[unit_id]*sigma + b_age*age_std,\n      \n      # priors\n      cutpoints ~ dnorm(0, 1),\n      b_age ~ dnorm(0, 0.5),\n      \n      # non-centered parameters\n      b_bar ~ dnorm(0, 1),\n      z[unit_id] ~ dnorm(0, 1),\n      sigma ~ dexp(1)\n    ),\n    \n    data = responses_stan,\n    chains = 4,\n    cores = 4\n  )\n\n\n\n\n\nWe have to do a bit more work to pull out the unit estimates for this model but, as expected, the parameter estimates here are practically equivalent to the previous model’s estimates.\n\n\nCode\nraccoon_04@stanfit %>%\n  \n  # extract parameters and summarise with 50/80% quantiles\n  posterior::as_draws_df() %>%\n  as_tibble() %>%\n  rename_with(~str_replace(str_remove(.x, \"]\"), \"\\\\[\", \"_\"),\n              .cols = starts_with(\"z\")) %>%\n  mutate(A = b_bar + z_1 * sigma,\n         B = b_bar + z_2 * sigma,\n         C = b_bar + z_3 * sigma,\n         D = b_bar + z_4 * sigma,\n         E = b_bar + z_5 * sigma) %>%\n  select(A, B, C, D, E, b_age, starts_with(\"cut\")) %>%\n  pivot_longer(cols = everything(),\n               names_to = \"term\",\n               values_to = \"estimate\") %>%\n  group_by(term) %>%\n  tidybayes::median_qi(estimate, .width = c(0.5, 0.8)) %>%\n  \n  # append with actual values used to simulate data\n  left_join(unit_params, by = c(\"term\" = \"unit\")) %>%\n  rename(true_value = beta) %>%\n  mutate(true_value = case_when(term == \"cutpoints[1]\" ~ cutpoints[1],\n                                term == \"cutpoints[2]\" ~ cutpoints[2],\n                                term == \"b_age\" ~ beta_age,\n                                TRUE ~ true_value),\n         term = fct_relevel(term, c(paste0(\"cutpoints[\", 1:2, \"]\"),\n                                    \"b_age\",\n                                    LETTERS[5:1]))) %>%\n  \n  # plot!\n  ggplot(aes(x = term,\n             y = estimate,\n             ymin = .lower,\n             ymax = .upper)) + \n  ggdist::geom_pointinterval(color = egypt_blu) +\n  geom_point(aes(y = true_value),\n             color = egypt_red,\n             size = 2.5) + \n  coord_flip() +\n  labs(title = \"**Raccoon #04** Posterior Fit\",\n       subtitle = glue::glue(\"Comparison of each parameter's \n                             **{color_text('true value', egypt_red)}** \n                             to the \n                             **{color_text('model\\\\'s estimate', egypt_blu)}**\"),\n       x = NULL,\n       y = NULL,\n       caption = \"Pointrange indicates 50/80% <br>posterior credible interval\")\n\n\n\n\n\nWith this new parameterization, however, this inference stands on a bit sturdier ground. While still not near the actual 2000 total samples, the effective sample size of each parameter has greatly improved and the convergence statistic is better across the board.\n\n\nCode\nprecis(raccoon_04, depth = 2)\n\n\n#>                    mean         sd       5.5%     94.5%     n_eff     Rhat4\n#> cutpoints[1] -0.4528105 0.61734428 -1.4141411 0.5646185 1080.2276 0.9999476\n#> cutpoints[2] -0.1034459 0.61438529 -1.0705393 0.8963293 1085.7692 0.9997501\n#> b_age         0.2540631 0.09263271  0.1073939 0.4032082 1969.5320 0.9993506\n#> b_bar         0.4308891 0.63042797 -0.5693130 1.4471711  925.0096 1.0018934\n#> z[1]          1.4513916 0.65032581  0.4481160 2.5227073  862.1820 1.0065399\n#> z[2]          0.3795392 0.54168883 -0.4556955 1.2506734  681.4293 1.0058323\n#> z[3]         -0.2313011 0.56399174 -1.2076518 0.6440465  619.6718 1.0043170\n#> z[4]         -0.4386073 0.53846049 -1.3433651 0.3940326  592.6804 1.0029844\n#> z[5]         -0.7838474 0.62014640 -1.8038760 0.1606955  815.9599 1.0022972\n#> sigma         0.7803627 0.37862771  0.3673002 1.4990210  683.2843 1.0042488"
  },
  {
    "objectID": "posts/2022-12-30-my-2022-magnum-opus/index.html#exploring-the-posterior",
    "href": "posts/2022-12-30-my-2022-magnum-opus/index.html#exploring-the-posterior",
    "title": "My 2022 Magnum Opus",
    "section": "Exploring the posterior",
    "text": "Exploring the posterior\nWith this finalized model, we can answer interesting counterfactual questions even if there isn’t data directly in the dataset. For example, what do we expect each unit’s score to be across all ages?\n\n\nCode\n# sequence of standardized ages for each unit\ncounterfactual_data <- \n  crossing(unit_id = 1:5,\n           age_std = seq(-2, 2, length.out = 50))\n\n# extract a sample of 100 cutpoints from the posterior \ncutpoints <- \n  extract.samples(\n    raccoon_04,\n    n = 100,\n    pars = paste0(\"cutpoints[\", 1:2, \"]\")\n  )\n\n# convert to tibble & add sim index\ncutpoints <- \n  tibble(\n    sim = seq(1:100),\n    cutpoint1 = cutpoints$`cutpoints[1]`,\n    cutpoint2 = cutpoints$`cutpoints[2]`\n  )\n  \ncounterfactual_output <- \n  \n  # extract phi & convert to wide tibble format\n  raccoon_04 %>%\n  link(as.list(counterfactual_data),\n       post = extract.samples(., n = 100)) %>%\n  t() %>%\n  as_tibble() %>%\n  \n  # add unit/age data; convert to long format\n  bind_cols(counterfactual_data, .) %>%\n  rowid_to_column() %>%\n  pivot_longer(starts_with(\"V\"),\n               names_to = \"sim\",\n               values_to = \"phi\") %>%\n  mutate(sim = as.numeric(str_remove(sim, \"V\"))) %>%\n  \n  # estimate probabilities for each category\n  left_join(cutpoints) %>%\n  mutate(q1 = cutpoint1 - phi,\n         q2 = cutpoint2 - phi,\n         detractor = expit(q1),\n         passive = expit(q2) - expit(q1),\n         promoter = 1 - expit(q2)) %>%\n  select(unit_id, age_std, sim, promoter, passive, detractor)\n\ncounterfactual_output %>%\n  slice_head(n = 10) %>%\n  mutate(across(c(promoter:detractor), ~scales::label_percent(accuracy = 1)(.x))) %>%\n  knitr::kable()\n\n\n\n\n\nunit_id\nage_std\nsim\npromoter\npassive\ndetractor\n\n\n\n\n1\n-2\n1\n76%\n6%\n19%\n\n\n1\n-2\n2\n78%\n5%\n17%\n\n\n1\n-2\n3\n81%\n5%\n14%\n\n\n1\n-2\n4\n72%\n5%\n23%\n\n\n1\n-2\n5\n80%\n4%\n15%\n\n\n1\n-2\n6\n74%\n6%\n20%\n\n\n1\n-2\n7\n79%\n5%\n16%\n\n\n1\n-2\n8\n64%\n8%\n28%\n\n\n1\n-2\n9\n79%\n4%\n17%\n\n\n1\n-2\n10\n68%\n8%\n24%\n\n\n\n\n\nHere, we’ve taken 100 samples from raccoon_04 for each combination of unit_id and age_std and extracted the probability of selecting promoter, passive, or detractor. If we put together in a plot, we can see what the model expects of each unit across each age and how confident hte model is in that expectation.\n\n\nCode\ncounterfactual_output %>%\n  pivot_longer(c(promoter, passive, detractor),\n               names_to = \"nps_group\",\n               values_to = \"prob\") %>%\n  mutate(nps_group = fct_relevel(nps_group, c(\"detractor\", \"promoter\", \"passive\")),\n         unit = paste(\"Unit\", LETTERS[unit_id]),\n         age = age_std * 10 + 45) %>%\n  ggplot(aes(x = age,\n             y = prob,\n             color = nps_group,\n             group = paste0(sim, nps_group))) +\n  geom_line(alpha = 0.2) +\n  facet_wrap(~unit) +\n  scale_y_continuous(labels = scales::label_percent()) + \n  MetBrewer::scale_color_met_d(\"Egypt\") +\n  theme(legend.position = \"none\") + \n  labs(title = \"Counterfactual odds and oddities\",\n       subtitle = glue::glue(\"Probability of selecting \n                             **{color_text('promoter', egypt_blu)}**, \n                             **{color_text('passive', egypt_grn)}**, or \n                             **{color_text('detractor', egypt_red)}** \n                             as age increases\"),\n       x = NULL,\n       y = NULL,\n       caption = \"Sample of 100 posterior draws\")\n\n\n\n\n\nThere are quite a few items to note from this plot. Firstly, across all age ranges, the early-alphabet units are more likely to have promoter responses than the late-alphabet units. Additionally, there is a relatively small chance of selecting passive at each unit across the ages. As age increases, each unit is expected to receive more favorable scores. Finally, Unit D, which had the most responses, has the tightest posterior intervals while Unit E, which had the fewest, has the widest intervals. All of this is expected, given how the data was simulated. In combination with the true/estimated parameter plot, this serves as a good confirmation that raccoon_04 models the process appropriately.\nSince each sample gives the probability of selecting promoter, passive, or detractor, we can simply plug these probabilities into the formula for NPS to get the expected NPS for each unit across the ages.\n\n\nCode\ncounterfactual_output %>%\n  \n  # get nps for each posterior sample\n  mutate(nps = promoter - detractor,\n         unit = paste(\"Unit\", LETTERS[unit_id]),\n         age = age_std * 10 + 45) %>%\n  \n  # plot!\n  ggplot(aes(x = age,\n             y = nps,\n             group = sim)) + \n  geom_line(alpha = 0.25,\n            color = RColorBrewer::brewer.pal(3, \"Dark2\")[3]) +\n  facet_wrap(~unit) + \n  scale_y_continuous(labels = scales::label_percent()) +\n  labs(title = \"Counterfactual odds and oddities 2: NPS drift\",\n       subtitle = glue::glue(\"**{color_text('Expected NPS', RColorBrewer::brewer.pal(3, 'Dark2')[3])}** \n                             at each unit as age increases\"),\n       x = NULL,\n       y = NULL,\n       caption = \"Sample of 100 posterior draws\")"
  },
  {
    "objectID": "posts/2022-12-30-my-2022-magnum-opus/index.html#in-summary",
    "href": "posts/2022-12-30-my-2022-magnum-opus/index.html#in-summary",
    "title": "My 2022 Magnum Opus",
    "section": "In summary…",
    "text": "In summary…\nIn this post, we’ve done the following:\n\nDefined a data-generating process that links NPS to a linear model while preserving the order of the categories.\nManually set the parameters of the linear model and simulated patient responses.\nRecovered the parameters with a series of models.\n\nThe models that were built increased in both complexity and utility:\n\nraccoon_01 didn’t contain any terms and only estimated the cutpoints \\(\\kappa_k\\) — this effectively gave us a Bayesian histogram of the data.\nraccoon_02 added terms for the unit each patient visited and their age. This recovered the parameters we set manually, but didn’t pool any information across units and only allowed us to draw inferences from the units in the dataset.\nraccoon_03 converted \\(\\beta_{\\text{unit}}\\) to a hierarchical term, which addressed some of the shortcomings of raccoon_02. However, the way the model was written resulted in a difficult parameter space for Stan’s sampler to explore, which gave less-than-desirable diagnostics.\nraccoon_04 was a non-centered reparameterization of raccoon_03. The two models were mathematically equivalent, but raccoon_04 was easier to for Stan to sample from, which gave us a larger effective sample size and smaller convergence statistic for each parameter (which are both good things!).\n\nWith the fit from raccoon_04, we also were able to look at how the model expected responses to vary with age at each unit. This served as another visual confirmation that the model was doing what we expected based on how the data was simulated. These expected responses also allowed us to plot the expected NPS score at each unit as age varies."
  },
  {
    "objectID": "posts/2022-12-30-my-2022-magnum-opus/index.html#some-additional-closing-thoughts",
    "href": "posts/2022-12-30-my-2022-magnum-opus/index.html#some-additional-closing-thoughts",
    "title": "My 2022 Magnum Opus",
    "section": "Some (additional) closing thoughts",
    "text": "Some (additional) closing thoughts\nAs mentioned in the opening section, NPS is a difficult metric to model (or, at least, it was prior to picking up McElreath’s book). In the past, I’d used some hack-ish methods to model NPS, such as:\n\nIgnoring passives and detractors by modeling promoters with a binomial.\nAggregating scores at the unit-level, rescaling NPS from [-100, 100] to [0, 1], tossing out any zeroes or ones, then modeling with a beta distribution.\nSeparately modeling promoters, passives, and detractors with three binomial models.\n\nEach of these is wrong in their own way, but, fundamentally, they all ignore the data-generating process of a patient’s experience influencing an ordered response on a 0-10 scale.\nSpeaking of a 0-10 scale, this ordinal model extends to any number of categories — we could have have directly modeled the 11 response categories using \\(k = 10\\) cutpoints. While NPS is more granular (and therefore, in my opinion, better) than LTR/topbox, modeling and evaluating the mean response on the 0-10 scale is even more granular/better than NPS! That being said, however, it’s unlikely that much of my work at the hospital will incorporate that more-granular view. NPS is our chosen metric, so while there are more potential categories, we really only care about the three big buckets of promoter, passive, or detractor. Additionally, from a benchmarking perspective, NPS is more widely available and allows for a quick comparison to other hospital systems that are picking up the metric or even other industries where NPS is the standard satisfaction metric."
  },
  {
    "objectID": "posts/2023-01-21-trump-vs-desantis-in-2024-republican-primary-polling/index.html",
    "href": "posts/2023-01-21-trump-vs-desantis-in-2024-republican-primary-polling/index.html",
    "title": "Trump vs. Desantis in 2024 Republican Primary Polling",
    "section": "",
    "text": "Late last year, Donald Trump officially announced his candidacy for the 2024 presidential election. To secure the Republican party’s nomination, he’ll have to best Florida’s governor, Ron DeSantis, who, despite not having yet announced his intention to run, is currently viewed as the only serious challenger to Trump for the nomination. It’s really far too early to be digging into the 2024 presidential election, but pollsters are gonna do what pollsters are gonna do, so we already have a cadre of primary polls comparing Trump to DeSantis.\nNathaniel Rakich recently wrote an article for FiveThirtyEight in which he examined recent Republican presidential primary polls and came to an interesting conclusion. When pollsters ask respondents to choose from a sea of potential primary candidates, Trump easily bests DeSantis. In head-to-head polls, however, DeSantis more often comes up as the front-runner.\n\n\nThis is a classic example of the spoiler effect, in which the presence of alternative candidates on the ballot curbs one candidate’s ability to win a plurality of votes against an opposition candidate — in this case, the alternative candidates draw votes away from DeSantis. Standard statistical assumptions/rules state that questions with different possible responses should be evaluated separately, and Rakich rightly splits his analysis between the multiway and head-to-head polls.\nFrom an intuitive sense, however, it feels like we should be able to evaluate these different sets of polls jointly. While the set of candidates may differ, they’re asking the same sort of question — which candidate Republican primary voters would like to see as the party’s nomination. The only difference in response options is the inclusion or exclusion of alternative candidates to Trump/DeSantis. With a little nudging, however, we may be able to link the two different response scales by first estimating the proportion of respondents who would select an alternative to Trump/DeSantis, then estimating the proportion of these “Other” votes that would go to Trump or DeSantis if forced to make a choice in a head-to-head poll.\nAnother way of looking at it: we know that these “Other” votes need to go somewhere when presented with a different response scale. Graphically, our goal is to link the two different response scales by estimating the size of the orange/green arrows below.\n\nUsing the same polls that were included in Rakich’s analysis and plunking them into a model that accounts for the structure above comes to largely the same topline conclusions as Rakich — when there are many candidates on the ballot Trump handily wins but in head-to-head competitions DeSantis bests Trump.\n\nAlternatively, expressed as a margin, Trump would be expected to beat DeSantis in the primary by 10-13% if there are many candidates on the ballot, while he would expect to lose to DeSantis by 1-5% in a head-to-head matchup.\n\nAgain, this is thus far very similar to what Rakich found with a simple average of polls. The benefit of modeling, however, means that we can additionally estimate the proportion of voters who would switch from an alternative to Trump/DeSantis if forced to do so! Of the voters who select other candidates in multiway polls, we expect that somewhere between 80-93% would prefer DeSantis in a head-to-head matchup, with Trump receiving the remaining 7-20%.\n\nUnder the hood, this uses Stan to estimate the model parameters (you can view the full model here). This is a bit like using a sledgehammer to put a nail into the wall — it’s a bit overkill. This is a pretty simple model that could’ve been estimated analytically, but this was also a good coding exercise that opened the door to building more complicated/useful models with this linked structure in the future. You should take the results with a bit of a grain of salt — the relatively simple model is probably overconfident in its estimations and there’s a lot of time for things to change between now and the 2024 election.\n\n\n\nCitationBibTeX citation:@online{rieke2023,\n  author = {Mark Rieke},\n  title = {Trump Vs. {Desantis} in 2024 {Republican} {Primary}\n    {Polling}},\n  date = {2023-01-21},\n  url = {https://www.thedatadiary.net/posts/2023-01-21-trump-vs-desantis-in-2024-republican-primary-polling},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMark Rieke. 2023. “Trump Vs. Desantis in 2024 Republican Primary\nPolling.” January 21, 2023. https://www.thedatadiary.net/posts/2023-01-21-trump-vs-desantis-in-2024-republican-primary-polling."
  },
  {
    "objectID": "about/about.html",
    "href": "about/about.html",
    "title": "the data diary",
    "section": "",
    "text": "My name is Mark Rieke and I am a senior consumer experience (CX) analyst at Memorial Hermann Health System where I use survey data to improve patient satisfaction. I love making beautiful charts, working on home improvement projects, and playing jazzy piano.\nI earned my bachelor’s degree in Mechanical Engineering from the University of Tulsa in 2018. I worked with Siemens Energy for three years designing mobile gas-turbine power plants before moving into a more data-centric role. I currently use R and tidymodels to provide actionable insights from Qualtrics survey data. In my spare time, I love analyzing public political datasets. You can find my work on GitHub and my unedited stream of consciousness on Twitter.\nI live in Houston, TX, with my fiance and two obnoxious yet lovable pets.\nThis blog is built with blogdown and Hugo, and deployed using Netlify. The content on this site is released under the MIT License."
  },
  {
    "objectID": "projects/projects.html#midterm-forecast",
    "href": "projects/projects.html#midterm-forecast",
    "title": "Projects",
    "section": "2022 Midterm Forecast",
    "text": "2022 Midterm Forecast\nA daily forecast for each seat in each congressional chamber.\n\nSenate\n\n\n\n\n\n\n\n\n\n\n\n\nHouse\n\n\n\n\n\n\n\n\n\n\n\n\nGovernor"
  },
  {
    "objectID": "projects/projects.html#rstudioconf2022",
    "href": "projects/projects.html#rstudioconf2022",
    "title": "Projects",
    "section": "rstudio::conf(2022)",
    "text": "rstudio::conf(2022)"
  },
  {
    "objectID": "projects/projects.html",
    "href": "projects/projects.html",
    "title": "Projects",
    "section": "",
    "text": "Author: Mark Rieke  License: MIT\n\n    \nGenerate bootstrap 🥾 prediction intervals from a tidymodel workflow.\n\n\n\n\nAuthor: Mark Rieke License: MIT\n\n    \nnplyr: a grammar of (nested) data manipulation 🐦.\n\n\n\n\nAuthor: Mark Rieke  License: MIT\nA collection of functions I use regularly."
  },
  {
    "objectID": "projects/2022-midterms/senate.html",
    "href": "projects/2022-midterms/senate.html",
    "title": "2022 Senate Forecast",
    "section": "",
    "text": "“\n\n”\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n“\n\n”"
  },
  {
    "objectID": "projects/2022-midterms/governor.html",
    "href": "projects/2022-midterms/governor.html",
    "title": "2022 Governor Forecast",
    "section": "",
    "text": "|                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |=                                                                     |   1%\n  |                                                                            \n  |=                                                                     |   2%\n  |                                                                            \n  |==                                                                    |   2%\n  |                                                                            \n  |==                                                                    |   3%\n  |                                                                            \n  |===                                                                   |   4%\n  |                                                                            \n  |====                                                                  |   5%\n  |                                                                            \n  |====                                                                  |   6%\n  |                                                                            \n  |=====                                                                 |   7%\n  |                                                                            \n  |=====                                                                 |   8%\n  |                                                                            \n  |======                                                                |   8%\n  |                                                                            \n  |======                                                                |   9%\n  |                                                                            \n  |=======                                                               |  10%\n  |                                                                            \n  |========                                                              |  11%\n  |                                                                            \n  |========                                                              |  12%\n  |                                                                            \n  |=========                                                             |  12%\n  |                                                                            \n  |=========                                                             |  13%\n  |                                                                            \n  |==========                                                            |  14%\n  |                                                                            \n  |==========                                                            |  15%\n  |                                                                            \n  |===========                                                           |  16%\n  |                                                                            \n  |============                                                          |  17%\n  |                                                                            \n  |============                                                          |  18%\n  |                                                                            \n  |=============                                                         |  19%\n  |                                                                            \n  |==============                                                        |  19%\n  |                                                                            \n  |==============                                                        |  20%\n  |                                                                            \n  |===============                                                       |  21%\n  |                                                                            \n  |===============                                                       |  22%\n  |                                                                            \n  |================                                                      |  23%\n  |                                                                            \n  |================                                                      |  24%\n  |                                                                            \n  |=================                                                     |  25%\n  |                                                                            \n  |==================                                                    |  25%\n  |                                                                            \n  |==================                                                    |  26%\n  |                                                                            \n  |===================                                                   |  27%\n  |                                                                            \n  |====================                                                  |  28%\n  |                                                                            \n  |====================                                                  |  29%\n  |                                                                            \n  |=====================                                                 |  29%\n  |                                                                            \n  |=====================                                                 |  30%\n  |                                                                            \n  |=====================                                                 |  31%\n  |                                                                            \n  |======================                                                |  31%\n  |                                                                            \n  |=======================                                               |  33%\n  |                                                                            \n  |========================                                              |  34%\n  |                                                                            \n  |========================                                              |  35%\n  |                                                                            \n  |=========================                                             |  35%\n  |                                                                            \n  |=========================                                             |  36%\n  |                                                                            \n  |==========================                                            |  37%\n  |                                                                            \n  |==========================                                            |  38%\n  |                                                                            \n  |===========================                                           |  39%\n  |                                                                            \n  |============================                                          |  41%\n  |                                                                            \n  |=============================                                         |  41%\n  |                                                                            \n  |=============================                                         |  42%\n  |                                                                            \n  |==============================                                        |  42%\n  |                                                                            \n  |==============================                                        |  43%\n  |                                                                            \n  |===============================                                       |  44%\n  |                                                                            \n  |================================                                      |  45%\n  |                                                                            \n  |================================                                      |  46%\n  |                                                                            \n  |=================================                                     |  47%\n  |                                                                            \n  |=================================                                     |  48%\n  |                                                                            \n  |==================================                                    |  48%\n  |                                                                            \n  |==================================                                    |  49%\n  |                                                                            \n  |===================================                                   |  50%\n  |                                                                            \n  |====================================                                  |  51%\n  |                                                                            \n  |=====================================                                 |  52%\n  |                                                                            \n  |=====================================                                 |  53%\n  |                                                                            \n  |======================================                                |  54%\n  |                                                                            \n  |======================================                                |  55%\n  |                                                                            \n  |=======================================                               |  55%\n  |                                                                            \n  |=======================================                               |  56%\n  |                                                                            \n  |========================================                              |  57%\n  |                                                                            \n  |=========================================                             |  58%\n  |                                                                            \n  |=========================================                             |  59%\n  |                                                                            \n  |==========================================                            |  59%\n  |                                                                            \n  |==========================================                            |  60%\n  |                                                                            \n  |==========================================                            |  61%\n  |                                                                            \n  |===========================================                           |  61%\n  |                                                                            \n  |===========================================                           |  62%\n  |                                                                            \n  |============================================                          |  63%\n  |                                                                            \n  |=============================================                         |  64%\n  |                                                                            \n  |=============================================                         |  65%\n  |                                                                            \n  |==============================================                        |  65%\n  |                                                                            \n  |==============================================                        |  66%\n  |                                                                            \n  |===============================================                       |  67%\n  |                                                                            \n  |===============================================                       |  68%\n  |                                                                            \n  |================================================                      |  68%\n  |                                                                            \n  |================================================                      |  69%\n  |                                                                            \n  |=================================================                     |  70%\n  |                                                                            \n  |=================================================                     |  71%\n  |                                                                            \n  |==================================================                    |  71%\n  |                                                                            \n  |==================================================                    |  72%\n  |                                                                            \n  |===================================================                   |  73%\n  |                                                                            \n  |====================================================                  |  74%\n  |                                                                            \n  |====================================================                  |  75%\n  |                                                                            \n  |=====================================================                 |  76%\n  |                                                                            \n  |======================================================                |  77%\n  |                                                                            \n  |======================================================                |  78%\n  |                                                                            \n  |=======================================================               |  78%\n  |                                                                            \n  |=======================================================               |  79%\n  |                                                                            \n  |========================================================              |  80%\n  |                                                                            \n  |========================================================              |  81%\n  |                                                                            \n  |=========================================================             |  82%\n  |                                                                            \n  |==========================================================            |  83%\n  |                                                                            \n  |===========================================================           |  84%\n  |                                                                            \n  |===========================================================           |  85%\n  |                                                                            \n  |============================================================          |  85%\n  |                                                                            \n  |============================================================          |  86%\n  |                                                                            \n  |=============================================================         |  86%\n  |                                                                            \n  |=============================================================         |  87%\n  |                                                                            \n  |=============================================================         |  88%\n  |                                                                            \n  |==============================================================        |  88%\n  |                                                                            \n  |==============================================================        |  89%\n  |                                                                            \n  |===============================================================       |  89%\n  |                                                                            \n  |===============================================================       |  90%\n  |                                                                            \n  |================================================================      |  91%\n  |                                                                            \n  |================================================================      |  92%\n  |                                                                            \n  |=================================================================     |  92%\n  |                                                                            \n  |==================================================================    |  94%\n  |                                                                            \n  |===================================================================   |  95%\n  |                                                                            \n  |===================================================================   |  96%\n  |                                                                            \n  |====================================================================  |  97%\n  |                                                                            \n  |====================================================================  |  98%\n  |                                                                            \n  |===================================================================== |  98%\n  |                                                                            \n  |===================================================================== |  99%\n  |                                                                            \n  |======================================================================| 100%"
  }
]